# Pre-温故而知新之练习赛

# 群Group

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 106 总提交人数: 109

## 题目描述

输入两个整数 a,ba,b，请输出 a+b+a∗b 的值

## 输入格式

一行，两个用空格分隔的整数 a,b ；

## 输出格式

输出一个数，为 a+b+a∗b 的结果

## 输入样例

```
1 2
```

## 输出样例

```
5
```

## 样例解释

输入的 a 是 1 ， bb 是 2 ， 1+2+1∗2=5 ，所以输出 5。

## 数据范围

−104≤a,b≤104

*AUTHOR:cbd*

# Easy-Div

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 98 总提交人数: 106

## 题目介绍

给出非负整数 a,b ，请你计算 a 除以 b 的商和余数。

## 输入格式

一行，两个非负整数 a,b，0≤a,b≤100，且 a,b不同时为 0。

## 输出格式

一行字符串；

如果除数为 0 ，请直接输出`ERROR. The divisor is ZERO.`；

否则，请输出 `a div b = c ... d`，其中`a`和`b`代表题中的两个非负整数，`c`代表得到的商，`d`代表得到的余数。

## 输入样例1

```
10 3
```

## 输出样例1

```
10 div 3 = 3 ... 1
```

## 输入样例2

```
5 0
```

## 输出样例2

```
ERROR. The divisor is ZERO.
```

## HINT

注意字符串中的空格，建议直接复制；

# LCM Problem

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 100 总提交人数: 102

## 题目描述

在数论中，约数与倍数是很常见的概念。若有一个正整数 xx 可以被另外两个正整数 a,b 整除，则 xx 为 a,b的公倍数，其中最小的公倍数叫做**最小公倍数**（LCM, Least Common Multiple），记为 lcm(a,b)。

现在给定 a,b，请你求出 lcm(a,b) 的值。

## 输入格式

输入一行，两个用空格隔开的正整数 a,b (1≤a,b≤1,000)。

## 输出格式

输出一行一个整数 lcm(a,b)lcm(a,b)。

## 样例输入1

```
12 8
```

## 样例输出1

```
24
```

## 样例输入2

```
299 943
```

## 样例输出2

```
12259
```

## 提示1

还记得课件中计算两个正整数的**最大公约数**（GCD, Greatest Common Divisor）的方法吗？如何直接改造课件中的程序，使得计算的东西变成最小公倍数？

## 提示2

如果你不想改造程序，也可以利用下面的性质：

gcd(a,b)×lcm(a,b)=a×b

其中 gcd(a,b) 表示 a,b 的最大公约数。用这个方法，课件里的代码就成为本方法的一个组成部分。

## 思考

采用提示1和提示2的方法，哪种方法更有效？为什么？

*题面来源于廖纪童，AUTHOR：cbd*

# 小兔子能有什么坏心眼呢？

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 72 总提交人数: 92

## 题目描述

当你正在认真学习沙河联盟C语言的课程时，突然有一只小兔子跑过来，想要你给它画一幅画像，它的要求很简单，随便的画亿下就行，毕竟小兔子又能有什么坏心眼呢？

## 输入

无

## 输出

输出小兔子的肖像画，具体样式见输出样例

## 输出样例

```
     0\\\-                              0\\0           
     \   \\0                          0\   \0          
    0\     -\'                      0\      \          
    0\       \0                    \        \          
    0\        -0                  \         \          
    0\         -\                \          \          
    0\          \0              \          -\          
     \'          \0            \           \           
      \           \\\\\\\\\\\\\\          \0           
      \\          -\\\\\\\\\\\\          \0            
       -\          \\\\\\\\\\\-         -0             
        0\         \\\\\\\\\\\         \0              
       -\\\        '\\\\\\\\\\        \\\\             
      0\\\\\'                        \\\\\\            
     0\\\\\\\                       \\\\\\\\           
     \\\\\\-                          \\\\\\0          
    0\\\\\                             '\\\\\          
    \\\\\      \\\             \\\\     \\\\\'         
    \\\\       \\\\\\       \\\\\\-      \\\\0         
    \\\\       \  \\          \   \      \\\\          
    0\\\        -\     \\\\    '\'       \\\\          
     \\\'           \\  \'  \            \\\0          
      \\\\                              \\\0           
       \\\\-                          \\\\0            
        0\\\\\\                   -\\\\\\              
          0\\\\\\\\\\\\\\\\\\\\\\\\\\\\\               
            0\\\\\\\\\\\\\\\\\\\\\\\0                  
               '0\\\\\\\\\\\\\\\\0                     
                   0\\\\\\\\\\0                        
                      '0000                             
```

## HINT

如果觉得这么多的转义符处理不过来的话，可以复制粘贴到记事本上，然后批量化进行替换。

这幅画总共有 30 行，可以检查一下复制粘贴的时候是否有疏漏。

*Author: 计组OO两开花*

*p.s. 题面部分素材来源于爱吃猪脚的猪脚*

## 思路

可以尝试在记事本上，按照顺序对所有需要转义的字符进行批量转换

# 好好学习，天天向上（取整）！

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 80 总提交人数: 94

## 题目描述

开花学长在刚刚学习C语言的时候，想着要好好学习，天天向上！所有的题目，他都在尽力的向上取整，也就是力争拿到一道题目的所有分数，获得那个令他充满成就感的`Accepted`。

现在摆在他眼前的是，两个正整数做除法。众所周知，C语言中**整数**的除法默认向下取整，可是不服输的开花学长就是喜欢向上取整，你能帮帮他吗？

## 输入

第一个数为数据组数 n (1≤n≤10000)

接下来 n 行，每行 2 个整数 a,b (1≤a,b≤10^18)

## 输出

对于每组数据，输出一行，⌈a÷b⌉ 的值

## 输入样例

```
2
1 2
3 2
```

## 输出样例

```
1
2
```

## 样例解释

对于第一组数据， ⌈1/2⌉=⌈0.5⌉=1

对于第二组数据， ⌈3/2⌉=⌈1.5⌉=2

## HINT

想想看，有没有什么方法来控制输入 n 组数据，用什么数据类型范围存储a,b，有没有合理利用整数运算向下取整的方式完成向上取整呢？

*Author: 计组OO两开花*

## 思路

严格来说，`double`表示整数的精度比`long long`低，所以建议用`long long`

# 翘课的倒霉蛋

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 61 总提交人数: 72

## 题目描述

开花助教在班上点名的时候，发现有太多的同学翘课啦！

这可让他很生气，所以他决定**从今天翘课的学生当中**挑选**学号最小**的那个倒霉蛋出来下周公开处刑。

同学们的学号都是**自然数**，所有同学中，**学号最小是 0** ，他们学号**连续排布**，即 0,1,2,3... 而且这门课对于所有的同学都是必修科目，不存在哪个学号的同学不用上课，如果他今天没来，**一定就是翘课了！**

**有的同学还很机灵，会找其他的同学代答到，甚至有的同学会代答好几次。但是这又有什么用呢？还是会被发现的！**

## 输入

第一行输入一个正整数 n，表示今天到场的有 n 个同学（**可能出现重复的学号，这是因为这位同学帮别人代答到被揪出来了，于是重复记录了这位同学原有的学号**）。

第二行输入给定的 n 个自然数，每一个数代表上课同学的学号，相邻两个自然数之间用一个空格隔开。

## 输出

输出只有一行，一个自然数，表示翘课学生中，最小的学号。

## 输入样例1

```
7
2 1000 7 0 1 2 5
```

## 输出样例1

```
3
```

## 输入样例2

```
5
1 2 3 4 5
```

## 输出样例2

```
0
```

## 样例解释

样例 1 ，到场的同学中，学号为 0,1,2 的同学出现了，学号为 3 的同学没有出现，所以下周他要挑选的倒霉蛋就是学号为 3 的同学。

样例 2 ，到场的同学中，0 首先就没有出现，所以要处刑的就是学号为 0 的同学（话说作为第一个被点名的同学还不到场，那可真是赶倒霉呀~）。

## 数据范围

1≤n≤1000，

输入的 n 个自然数都**不大于** 1000。

*Author: 计组OO两开花*

## 思路

直接用数组记录他们出现的次数，再顺序遍历即可

这个玩意儿其实就是mex函数，所以本题再给一个区间mex函数查询的cpp版本，以供参考。
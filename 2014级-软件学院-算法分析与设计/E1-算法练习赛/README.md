# E1-算法练习赛

# `A` 优先队列应用

时间限制：2000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

最近，Nova君遇到了一件非常棘手的问题。他需要整理非常多的解题报告。每份解题报告的题目数量是不定的。Nova君每次需要将两份报告的题目解析合成到一份里。假设两份报告的题解数分别为a和b，那么合成这两份报告消耗Nova君a+b的hp值。现在有n份报告，题解数分别为a0,a1,a2,,,an-1，请问Nova最少消耗多少hp？

## 输入

多组测试数据。每组数据，第一行为一个正整数n（INT范围内），代表报告份数，接下来一行，包含n个正整数（INT范围内）a0,a1,a2,,,an-1，代表每份报告的题解数。

## 输出

对于每组数据，输出一行，代表Nova需要付出的最少的hp值

## 输入样例

```
4
3 5 7 11
```

## 输出样例

```
49
```

## Hint

```
陈题，然而请用优先队列实现
```

## 思路

哈夫曼树最小带权距离的经典问题

这题说用优先队列做那就直接用优先队列来做呗，没啥说的...

# `B` 简单的二分法

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

给你一非降序数列，以及一组查询，查询某一特定元素是否存在于数列之中，如果存在，则输出该元素首次出现的位置，否则输出"error"。

## 输入

多组测试数据。 对于每组数据，第一行为两个整数n,m(1<=n,m<=250000)，表示数列中有n个元素以及m次查询。 第二行包含n个正整数，用空格分隔，表示有序数列。 接下来m行，每行一个整数，表示每次查询的元素。

## 输出

输出m行，每行输出内容见题目描述及样例

## 输入样例

```
5 3
1 2 3 4 5
3
5
7
```

## 输出样例

```
3
5 
error
```

## Hint

注意是下界二分查找

## 思路

自己手写几个二分查找的模板也行，用STL也行

由于是下界二分，所以lower_bound不管用，用upper_bound查找第一个比x-1大的可以

# `C` 零崎的战争

时间限制：1500ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

不知道各位听没听说过《This War of Mine》这个游戏，不过没听说过也没有关系。简单来说，这是一个生存游戏，作为一个被战争波及到的无辜平民，你需要在战争中探索周边地区获得补给从而活下去。

现在无聊的零崎有这样一个设想，如果这把这个游戏的地图挂在Google Map上，以真实地图为背景做成一个网络游戏可能会很好玩。假设世界上所有的城市已经被分为玩家初始所在地和可探索区域两类，玩家自由选择一个初始所在地，那么作为一个机智的玩家，你应该选择哪里才能让自己被FTK(首轮击杀)的可能性最小呢？

## 输入

第一个数为测试轮数K。

每轮测试以N开始，下面N行，代表初始地点，每行两个整数X Y表示其坐标。接下来N行代表可探索区域，每行两个整数X Y表示其坐标。

1 ≤ N ≤ 100000. 0 ≤ X，Y ≤ 1000000000

## 输出

每轮测试一行，输出为初始地点和可探索区域间的最近距离，结果保留小数点后三位。

## 输入样例

```
2
1
0 0
0 0
4
0 0
0 1
1 0
1 1
2 2
2 3
3 2
3 3
```

## 输出样例

```
0.000    
1.414
```

## Hint

原题POJ 3714，喜欢做英语阅读的同学可以去看一下

## 思路

最近点对问题变形

什么？拆成两类节点就不会做了？你把同一类节点的距离强制修正成无穷不就得了

# `D` 大整数相乘

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

计算A*B

## 输入

第一个数为数据组数n

接下来n行，每行2个整数a,b

## 输出

对于每组数据，输出一行，a*b的值

## 输入样例

```
1
1 2
```

## 输出样例

```
2
```

## 思路

普通的写一个大数的A乘B就行，管你是普通高精还是压位高精都能过

这题还不需要用到FFT，后面的题会练到的

# `E` DP大作战—多重背包

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

在之前的上机中，零崎已经出过了01背包和完全背包，也介绍了使用-1初始化容量限定背包必须装满这种小技巧，接下来的背包问题相对有些难度，可以说是01背包和完全背包的进阶问题。

多重背包：物品可以有0-n件。

对于第i种物品，我们有取0件，1件…n [ i ] 件共n [ i ] +1种策略，状态转移方程为f [ i ] [ v ] = max { f [ i - 1 ] [ v - k × c [ i ] ] + k × w [ i ] | 0 <=k<= n [ i ] }。在这里，很自然的有一种策略可以将其转化为01背包，即将物品换为n[i]件01背包中的物品，但是复杂度为O(VΣni)，时间复杂度没有降低。实际上，对于所有类似情况，我们都可以利用二进制求和来降低时间复杂度。即将物品替换为价值和费用 * 系数=1,2,2^2,…,2^k,n[i]-2^k+1的物品。系数之和为n [ i ]，表明不能取到多于n [ i ]件物品，但可以取到0…n[ i ]中任意一个整数件。利用这一优化，算法事件复杂度可以降到O(VΣlogni)。

实际上F [ i ] [ j ] 只依赖于 F [ i-1 ] [ j - k * w [ i ] ]，这里依赖项之间构成了一个 { j mod w [ i ] }剩余类，不同剩余类之间无关，注意到这点利用单调队列，每个状态均摊O(1)的时间，可以进一步将算法时间复杂度优化至O(VN)级别的，不过在此不再详细阐述。（其实也就是NOIP程度，放在大学应该可以接受，但是这个优化个人感觉已经脱离dp）

```
DD大牛给出的伪代码。
def MultiplePack(F,C,W,M)
    if C * M >= V
        CompletePack(F,C,W)
        return //考虑这里为什么可以直接用完全背包
    k := 1
    while k < M
        ZeroOnePack(kC,kW)
        M := M - k
        k := 2k
        ZeroOnePack(C M,W M)
```

## 输入

第一个数为数据组数n 1<=n<=10

接下来n组测试数据，每组测试数据由2部分组成。

第一行为背包容量V，物品种类数N。1<=V<=30000,1<=N<=200

接下来N行每行三个数为物品价值v，物品重量w，物品件数M。

1<=v,w<=200, 1<=M<=25

## 输出

对于每组数据，输出一行，背包能容纳的最大物品价值

## 输入样例

```
1
10 2
1 2 3
2 3 2
```

## 输出样例

```
6
```

## 思路

板子，写不写单调队列都能过，毕竟核心问题不在这里

# `F` DP大作战—组合背包

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

组合背包：有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。

```
DD大牛的伪代码
for i = 1 to N
    if 第i件物品属于01背包
        ZeroOnePack(F,Ci,Wi)
    else if 第i件物品属于完全背包
        CompletePack(F,Ci,Wi)
    else if 第i件物品属于多重背包
        MultiplePack(F,Ci,Wi,Ni)
```

## 输入

第一个数为数据组数n 1<=n<=10

接下来n组测试数据，每组测试数据由2部分组成。

第一行为背包容量V，物品种类数N。1<=V<=30000,1<=N<=200

接下来N行每行三个数为物品价值v，物品重量w，物品件数M。M=233表示物品无限。

1<=v,w<=200, 1<=M<=25

## 输出

对于每组数据，输出一行，背包能容纳的最大物品价值

## 输入样例

```
1
10 3
2 2 233
3 2 1
4 3 3
```

## 输出样例

```
13
```

## 思路

板子，不多说了

# `G` DP大作战—状态压缩dp

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

阿姆斯特朗回旋加速式阿姆斯特朗炮是一种非常厉害的武器，这种武器可以毁灭自身同行同列两个单位范围内的所有其他单位（其实就是十字型），听起来比红警里面的法国巨炮可是厉害多了。现在，零崎要在地图上布置一片阿姆斯特朗回旋加速式阿姆斯特朗炮，那么在N行M列单位长度大小的地图上，求解阿姆斯特朗回旋加速式阿姆斯特朗炮最大的部署数量和对应部署方案总数。

## 输入

每组输入一行，为两个整数N,M （N <= 100；M <= 10）

## 输出

每组一行两个整数，

第一个为阿姆斯特朗回旋加速式阿姆斯特朗炮的个数，第二个为此数量下的摆放方式总数。

## 输入样例

```
3 3
```

## 输出样例

```
3 6
```

## Hint

```
100   1为阿姆斯特朗回旋加速式阿姆斯特朗炮的位置，方案不唯一。  
010
001
```

状态压缩是一种特殊的技巧，不止可以用在dp中。状态压缩其实是在利用数据结构，由于基础数据类型int有32位，一个int变量就可以表示2^32个状态。状态压缩其实是一种优化方法，有很大局限性。第一，单元状态通常只有两种(0、1，其实多了压缩的道理是一样的，但是没有位运算就没什么优势了)，第二，单元维度通常不超过50 ( int才32，多了longlong都爆掉难道用高精度大整数压缩不成……)

状压dp本质上还是dp，问题大多数还是求解最大值或者解决方案总数之类的，但是状态数量巨大普通方法难以表示，所以利用整数可以将状态维度压缩到1维。

## 思路

状压dp这东西吧比较不好理解，上来就做这题可能会很困难...

状压dp这个东西基本上用于解决NP完全或NP难问题，或者解决一些搜索复杂度不稳定，需要搜索多重信息的问题。虽然无法把时间控制在多项式时间范围，但是一般可以控制在指数函数的范围内

建议先做点什么最短哈密顿回路这类的问题再回来做这题吧...


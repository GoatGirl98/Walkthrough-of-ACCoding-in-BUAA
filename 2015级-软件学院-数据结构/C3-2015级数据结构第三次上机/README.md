# C3-2015级数据结构第三次上机

# `A` AZY的白色情人节

时间限制：5ms  内存限制：1500kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

3月14日是[白色情人节](http://baike.baidu.com/subview/9083/7693767.htm)，AZY决定要给喜欢的妹子送一束玫瑰作为礼物。

正如你们所知，AZY是个[大预言家](https://biancheng.love/problem/276/index)。他上一次已经预知到，为了真切地打动心爱的姑娘，他所送的玫瑰必须满足一个条件，那就是这些玫瑰的个数必须是**“PPLGG”数**，而按照预言书的启示，“PPLGG”数有一种奇特的数学性质，那就是**它们分解质因数后，质因子只包括2,3,5三个数中的一个或多个。**

大概是上天被AZY真挚的感情所打动，这天早上醒来，AZY发现桌子上凭空出现了好大一束玫瑰花，但他并不擅长数数，请你帮他看看，这束玫瑰花是否满足“PPLGG”数的要求呢？

![img](http://pic1.win4000.com/wallpaper/8/5029bdbe47a34.jpg)

## 输入

多组测试数据。每组数据为一个数字n，int范围内，表示这些玫瑰花的个数。

## 输出

对于每组输入数据输出一行，如果这束玫瑰能够让AZY完成一个完美的白色情人节，输出"Oh yeah!"，否则输出"Oh shit!"

## 输入样例

```
12
11
```

## 输出样例

```
Oh yeah!
Oh shit!
```

## Warning

一朵玫瑰代表“我的心里只有你”，所以如果只有一朵的话，当然也是满足要求的。

## Hint

水题，随意做吧。

## P.S.

AZY这种剁手党，当然根本没钱买那么多花，这个故事只是为了出题给你们编的。

不过，故事是虚构的，不代表故事本身不存在。

## 思路

直接做质因数分解即可，如果被卡常了记住换C风格的输出

# `B` 鸡蛋的小小愿望

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

话说软院的足球队加入了15级的新鲜血液之后变得更强了，在上周末对阵传说中北航最强的飞行学院的比赛中，竟然让一向所向披靡的飞院同学叫苦连连，直到下半段才用一颗十分有争议的球锁定胜局。作为当年追不上风的追风少年，鸡蛋开始意识到自己的地位不保！

俗话说，好马配好鞍，他决定整理一下自己的足球装备，可是，他突然发现**自己连一个足球包都没有！**气愤的他准备去体育商场买一个╮(╯_╰)╭

商场中有很多价格不同的足球包，而于鸡蛋身上带的是各种不同面值的钞票：1元，5元，10元，20元，50元，100元 。作为一个很懒很懒的人，鸡蛋希望在购买足球包的时候花出尽量少的钞票数量，可是他上次比赛被球闷到了之后脑子不太好用。现在需要聪明的你来帮帮他，看看最少需要掏出几张钱就能把包买走呐？（假设一定有一种方案能够买走）

## 输入

多组测试数据（组数不超过10）。

对于每组数据，输入两行，第一行为6个正整数，分别代表1元、5元、10元、20元、50元、100元的钞票个数，第二行为一个正整数S，代表需要支付的钱数。所有正整数都在INT范围内。

## 输出

对于每组数据，输出一行，为最少的钞票数量。

## 输入样例

```
4 2 1 4 10 3
112
```

## 输出样例

```
4
```

## Hint

这就叫“贪心”。

## Other

"宝宝真的想要个足球包！ "——于鸡蛋

## 思路

**这就是算法导论上经典的贪心问题，只需要无脑从上往下数即可**

# `C` jhljx又来了(III)

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

听说大家开始学习数据结构。唔呼呼~~ jhljx决定先给你们复习下基础知识。

jhljx需要你来构造一个从小到大排列的序列。支持三种操作。

- 1.Add操作，向序列中添加一个数（当然是**将这个数放在适当位置，保证从小到大排列**）
- 2.Delete操作，向序列中删除一个数（删除这个数即可，**如果有多个这样的数，删除一个即可**）
- 3.Sum操作，假设整个序列为a1,a2,a3……an,**求出a3+a8+a13+……的值**。

## 输入

输入多组数据。

每组数据第一行为一个正整数n(1<=n<=1000)。

下面n行为三种操作中的一种。 如果是Add操作或者Delete操作，需要再输入一个数a(1<=a<=10^9) 如果是Sum操作，不需要再输入数字。具体见样例。

## 输出

当操作为sum时，输出结果。

## 样例输入

```
9
Add 1
Add 2
Add 3
Add 4
Add 5
Sum
Add 6
Del 3
Sum
6
Add 1
Add 3
Add 5
Add 7
Add 9
Sum
```

## 样例输出

```
3
4
5
```

## Hint

请用**线性表**实现。 如果超时，可以尝试scanf和printf。

Powered by jhljx, given by AZY

## 知识点

线性表

## 思路

上面说了用线性表，那就线性表呗

**但是我本人的代码是水过的，千万别学我的！数据结构课程有好几个题是不希望你使用STL的，作为初学者可以自己认真手写一遍**

# `D` Thor’s Necklace

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

某日，Thor收到了来自匿名仰慕者的一串项链。

仰慕者为了表示自己的爱慕之情，在项链上面串了各种各样的宝石。

只可惜，在端详项链的时候，Thor的强迫症犯了——他发现项链上的宝石居然有重样的！

这怎么能忍？于是他对项链进行了喜（can）闻（jue）乐（ren）见（huan）的拆解，将上面的宝石都拆了下来，进行编号，去掉重复的并进行重组。 经过一个学期，大家都知道Thor很懒的，于是他又将这个任务交给了你们……

## 输入

多组测试数据，每组测试数据包括两行。

第一行为一个整数n(1≤n≤10^6)，为宝石的个数。

第二行有n个整数，用空格隔开，分别表示每一枚宝石的编号，相同宝石具有相同的编号，为了方便起见，宝石的编号已经升序排列。具体见样例。

## 输出

对于每组数据，输出两行。

第一行为重组后项链上宝石的个数，以及重复了的宝石中重复最多的次数。

第二行为重组后的宝石排列。具体见样例。

## 输入样例

```
5
1 2 3 4 5
7
1 2 2 2 2 3 3
```

## 输出样例

```
5 0
1 2 3 4 5
3 4
1 2 3
```

## Other

第一组数据中没有重复的宝石，所以输出中第一行第二个数为0

“虽然是老题，但是Kevin给你们定制了新版本。”——A.Z.Y

## 思路

**这是一个有序数组去重的经典问题，复杂度O(n)。具体参照邓俊辉《数据结构》第二章的有序向量唯一化部分**

**顺带一提，C++的Algorithm库是自带unique函数的，但是无法满足这一个题的需求，所以，就自己写咯~反正也不难= =**

# `E` Arthur的收藏夹

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

Arthur是一个收藏狂人，依仗着5TB的硬盘容量，四处搜刮奇奇怪怪的东西（图片，视频、文本、种子神马的）。然而某天，当他遇到同样是收藏狂人的Thor时，Arthur发现Thor的收藏与自己的收藏居然有很多是重样的！
这怎么可以——于是Arthur想知道自己有哪些收藏是Thor没有的，他请Thor来解这个问题，Thor又将这个问题扔给了Jeffrey，Jeffrey觉得这是一个好问题，于是他将这个问题交给你来解决。
为了方便解决问题，所有的藏品都用一个整数来表示，相同的整数表示相同的藏品。

## 输入

多组测试数据。 第一行为一个整数t(1≤t≤10)，为数据组数。接下来t组数据，每组数据包含三行。
第一行为两个整数m,n,分别表示Arthur的收藏品个数与Thor的收藏品个数。（Arthur和Thor自己不会收集同样的东西哦）
第二行包含m个不同整数，用空格隔开，为Arthur的收藏品。
第三行包含n个不同整数，用空格隔开，为Thor的收藏品。
对于80%的数据，1≤m,n≤1000
对于20%的数据，1≤m,n≤100000

## 输出

对于每组数据，输出两行。
第一行为一个整数x，为Arthur的藏品中Thor没有的个数。
第二行为x个整数，用空格隔开，按照升序输出这些Thor没有的藏品。
如果Arthur的藏品Thor都有，则仅输出“LOSER!”

## 输入样例

```
2
2 3
1 7
2 5 7
3 5
1 2 5
1 2 5 3 19
```

## 输出样例

```
1
1
LOSER!
```

## HINT

请用顺序表实现，除此之外，暂无禁手。
Arthur 刘瀚诚 13级数据结构助教
Thor 梁明阳 13级C++助教
Jeffrey 王剑锋 13级数据结构助教（北航的剑锋大大，比你们不知道高到哪里去）

## 思路

**这题为啥会当做线性表来处理啊...这难道不应该是集合的差集操作吗？**

**直接调用Algorithm库的set_difference ,计算Arthur-Thor，如果计算集合的元素个数是0，则是LOSER**

# `F` 赌神AZY

时间限制：20ms  内存限制：10000kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

不知道你们看过赌神没有？

<s>这图怎么又裂了？这我怎么看嘛</s>

AZY为了成为千王之王，便向赌神高进拜师学艺，然而他必须先学会基本的扑克洗牌才有那么点希望。

现在桌子上有一排扑克，从左到右点数依次为1.....n（假设点数可以无限增长），对这些牌有以下操作：

- 1 X Y表示将X牌移动到Y牌的左边（如果X已经在Y左边则无视该操作）
- 2 X Y表示将X移动到Y的右边（如果X已经在Y右边则无视该操作）
- 3 X Y表示交换X和Y的位置
- 4 表示将全部这排扑克反转

**保证操作合法，X不等于Y。以上X,Y代表点数。左边右边表示相邻的左右位置。**

## 输入

多组数据（不超过20组），每组数据第一行为牌的个数n，和操作个数m，1<=n<=1000010, 0=<m<=100

接下来m行，每行一个操作。

## 输出

每组数据输出一行，为操作结束后所有**奇数位置的牌的点数之和**。位置序号从左到右设为1~n.

## 输入样例

```
6 4 
1 1 4
2 3 5
3 1 6
4
```

## 输出样例

```
12
```

## Warning

本题不强求具体做法，只是说明**链表不一定是指针实现的**。其实数据很弱的Orz

## 思路

**个人认为本题是本次上机最难的题目**

原题为UVA12657，如果对其他解题思路有兴趣，可以移步本题的其他题解。

**可以采用普通的一维链表模拟或者下标数组模拟**，我个人用的是后者，所以按照后者的思路来讲



**首先，因为题目描述的一些问题，为了避免歧义，以下的描述，统一将“左边/右边”表示为紧挨着卡牌左边和右边的位置；将“左侧/右侧”表示为相对的地理位置，不一定就是紧邻**

**首先先用position数组a[i]记录i元素在动态数组的位置** 

那么分析以下几种功能

1.将x挪到y的左边

 (1)x在y左侧的时候 此时x的坐标变成y的坐标-1 然后所有原坐标为[x的原坐标+1，x的现坐标]要全部自减 

(2)x在y右侧的时候 此时x的坐标变为y的坐标 然后所有原坐标为[x的现坐标，x的原坐标-1]要全部自增 不需要考虑特殊情况，上面已经全部包括了 

2.将x挪到y的右边 

(1)x在y的左侧的时候 此时x的坐标变成y的坐标 然后所有原坐标为[x的原坐标+1，x的现坐标]要全部自减 

(2)x在y的右侧的时候 此时x的坐标变成y的坐标+1 然后所有原坐标为[x的现坐标，x的原坐标-1]要全部自增 

3.交换x和y的位置

没什么可说的，x和y交换一下下标即可

4.翻转整个扑克牌

也没什么可说的，这要看自己的下标是怎么模拟的了，比如说你设置的初始下标是1到n，那么下标为k的变成n+1-k即可

**最后记录所有下标是奇数的即可，注意爆精度的问题，永远都是能long long就不int**



**本题纯模拟毫无疑问会吃TLE，但是我不确定使用Splay/Treap这种平衡搜索树会不会过去，从时间复杂度上，O(logn)的序列操作显然比我的题解思路更加优秀，但是只有20ms，我还是会担心这样的操作会不会被直接卡常TLE了...**

**update:原cpp版本在复杂度上有本质问题，更新的c语言版本的复杂度才是正确的**

# `G` Z君的日常之海绵宝宝

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

Z君无聊的时候喜欢看《海绵宝宝》，但他不满足于此，他还想自己做一些海绵宝宝。大家都知道海绵宝宝是个**正方形**状的，所以Z君购买了一张 n\*m ( n , m 均为正整数)的大矩形海绵块，然后从中切割出来他想要的大小的海绵宝宝。虽然Z君的数学水平还停留在中学，但他还是很轻松的算出来了凭借这张海绵块，他可以做出来 x 种海绵宝宝。（两块海绵宝宝当且仅当边长相等，且是从同一块海绵块中相同位置切割出来的时是相同种类的）

那么请问海绵块的两相邻边取哪些值的时候，Z君从这个海绵块中最多能得到 x 种海绵宝宝？

![img](http://img.blog.csdn.net/20160315003329608)

## 输入

只有一组数据，为一个整数 x (1 ≤ x ≤ 10^18)。

## 输出

首先输出一个整数 k ，表示这样海绵块的种类。（海绵块当且仅当两相邻边长度分别对应相等时为相同种类）

接下来 k 行，每行为两个整数 n , m。按照 n 的升序输出，如果 n 相同则再按 m 升序输出。

## 输入样例一

```
26
```

## 输出样例一

```
6
1 26
2 9
3 5
5 3
9 2
26 1
```

## 输入样例二

```
2
```

## 输出样例二

```
2
1 2
2 1
```

## 解释

对于一个 2 x 3 的海绵块，我们可以得到 6 个 1 x 1 大小的海绵宝宝和 2 个 2 x 2大小的海绵宝宝，所以一共能得到 8 种海绵宝宝。如图：

![img](http://img.blog.csdn.net/20160315005008606)

对于样例一的 3 * 5 的答案：边长为 1 时，有 15 种；边长为 2 时，有 8 种；边长为 3 时，有 3 种。 所以15 + 8 + 3 = 26。

## 思路

**此题难度仅次于上一问，需要一些数学推导的过程**

**首先我们给定一个n\*m的海绵(并且保证n>=m 对称情况同理)，那么他的所有子正方形的大小就有了，根据级数求和，不难计算出此时能得到的总个数是m(m+1)(3n-m+1)/6**

**所以我们可以以m(m+1)进行枚举，看看能不能找出不小于他的n，使得上述式子得到对应的目标总块数，注意，此处n必须要不小于等于m！否则得到的答案完全是错误的hhh**

**得到了所有n>=m的解之后，对称一下，就得到了所有的解**

然后根据x的范围，我们试一试，**我个人是先循环到100w，发现不能覆盖全部解，那么循环到200w就够了**


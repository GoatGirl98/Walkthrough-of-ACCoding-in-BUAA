# C2-2015级数据结构第二次上机

# `A` 大预言家

时间限制：100ms  内存限制：3000kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

有些事情，没有所谓“道理”可讲，因为冥冥之中自有天意。

其实AZY是一个大预言家，阴阳自在他心间，与天地周旋。而他预测未来的方式很简单，但十分有效——翻硬币。（也许[Kaifu Lee大大也掌握了这种很厉害的预知之术](http://www.huxiu.com/article/140938/1.html?f=index_feed_article)......）

在桌子上从左到右摆上一排硬币，共有n个。一开始，AZY会把它们全部翻到反面，这是预言前所必须的准备。

第一步，他会把所有硬币翻过来，变成正面。

第二步，他会把每两个硬币中的最后一个翻过来。

第三步，他会把每三个硬币中的最后一个翻过来。

......

直到第n步，他会把最后一个（即第n个，也就是n个硬币中的最后一个）也翻过来。

这时，预言就结束了。仍然是正面的硬币个数，指明了未来的方向。

可是AZY知道，其实，再怎么神机妙算，也唯有自己看不穿，也无法改变，那缘来缘去如水，那生死有命在天。

## 输入

多组测试数据，每组一个数，为硬币的总个数n, 0<=n<=100007

## 输出

所有操作结束后是正面的硬币个数。

## 输入样例

```
1
3
```

## 输出样例

```
1
1
```

## Hint

给个例子，对于n=3的情况，状态变化如下：

反反反 -> 正正正 -> 正反正 -> 正反反

所以最后正面的个数是1。

水题，take it easy~

## 思路

水题，看一看就知道了，如果MLE就多提交几次

# `B` Z君的日常之集合处理

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

Z君正在学习离散数学，需要处理一些集合。

现在我们定义：

集合的加运算A+B：把两个集合并起来。

集合的减运算A-B：从A中去掉A，B共有的元素。

## 输入

第一个数为数据组数T。每组数据有三行。

第一行为一个字符“+”或“-”，代表着加运算或减运算；和两个整数n，m，代表集合A，B的大小（1 ≤ n，m ≤ 100 ）。

第二行为集合A，第三行为集合B。

集合的元素均为整数。输入数据保证集合的互异性。

## 输出

对于每组数据，输出一行，按元素的升序输出，每两个元素之间有一个空格。

如果集合为空，则输出"empty"（没有引号）。

## 输入样例

```
3
+ 3 4
1 3 2
3 6 7 5
- 4 3
1 3 2 5
2 1 4
- 2 3
1 2
2 1 3
```

## 输出样例

```
1 2 3 5 6 7
3 5
empty
```

## 思路

C语言选手正常的手动模拟排序去重即可

作为C++选手，可以了解一下algorithm库当中有关set集合运算的黑科技

# `C` Z君的日常之奇怪的函数

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

大家都知道，Z君喜欢数学。这天，他的高数老师给了他一个奇怪的函数 **f :R→R**，当这个函数满足：存在一个实常数**K**，对于任意的 **x,y∈R** ，使得 **| f(x) - f(y) | ≤ K \* | x - y |** 时，我们称这个函数为[*Lipschitz continuous*](https://en.wikipedia.org/wiki/Lipschitz_continuity) 。 Z君觉得这个函数太难了，他决定先从数组开始研究。对于一个数组h[1..n]，我们定义Lipschitz 常数L(h):

1.如果n<2，![img](http://img.blog.csdn.net/20160308100826831?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

2.如果n≥2，![img](http://img.blog.csdn.net/20160308100648654?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

换句话说，L=L(h)是对于所有的**1 ≤ i, j ≤ n**使得**|h[i] - h[j]| ≤ L\*|i - j|**成立的最小非负整数。

现在给你一个大小为n的数组a，和q个询问[l,r]。对于每个询问，设子数组s=a[l..r]；求s的所有连续子数组的Lipschitz 常数的和。

## 输入

第一行为两个整数n，q ( 2 ≤ n ≤ 100 000，1 ≤ q ≤ 100 ) ——数组a的大小和询问次数。

第二行为n个整数代表a[1..n]， ( 0 ≤ a[i] ≤ 10^8 )。

接下来有q行询问。每行有两个整数 l，r（1 ≤ l ≤ r ≤ n ）。

## 输出

对于每个询问，输出数组a[l..r]的所有连续子数组的Lipschitz常数的和。

## 输入样例

```
10 4
1 5 2 9 1 3 4 2 1 7
2 4
3 8
7 10
1 9
```

## 输出样例

```
17
82
23
210
```

## 样例解释

对于第一个询问2 4

L ( [5,2] ) = 3

L ( [2,9] ) = 7

L ( [5,2,9] ) = 7

答案为他们的和3+7+7=17

## 思路

相当困难的一道题

转换一下题意，计算一下两两相邻数的差的绝对值，新的数组有n-1个数

那么实际上就等价于求[L,R-1]的所有子区间的最大值的和

要么采用RMQ+分治要么用单调栈，对于初学数据结构的同学来说都十分的困难

# `D` AZY学习顺序表

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

学习数据结构的那个夏天，是AZY心里，有关大学最美好的回忆（应该没有之一）。 而学习顺序表的那几天，则是AZY心里，有关那学期数据结构课程最轻松的回忆（也许也没有之一）。

——这就是我最想留住的幸运。

顺序表不像树那样复杂，也不像图那样难懂。它是（最）简单的数据结构之一，是线性表的一种，现规定如下操作：

Ins X Y： 在顺序表中的X位置插入Y元素，并遍历输出当前顺序表的所有元素。

Del X：删除顺序表中的X元素（即值为X的元素），如果有多个X元素，只删除第一个，并遍历输出当前顺序的所有元素。

Loc X：输出顺序表中X元素的所在的位置，如果有多个X元素，只输出第一个。

Get X：输出顺序表中X位置上的元素。

## 输入

多组测试数据， 对于每组测试数据，首先输入两个整数n,m（0<m <n<100），分别表示顺序表初始有n个元素,m次操作。

接下来是n个整数，表示顺序表中的n个元素。 然后是m次操作，命令是Ins X Y ，Del X ， Loc X ， Get X中的一种，其中的X,Y均为整数。

## 输出

对于每组数据，输出有m行，对应m次操作： 如果操作不合法，则输出"Wrong input!"。

## 输入样例

```
5 6
1 3 4 5 6
Ins 4 7
Ins 8 10
Del 6
Del 10
Loc 5
Loc 10
```

## 输出样例

```
1 3 4 7 5 6
Wrong input!
1 3 4 7 5
Wrong input!
5
Wrong input!
```

## Hint

**请务必用顺序表实现。**

可能的代码：

```
......
typedef int ElemType;
typedef struct
{
    ElemType date[MAXN];
    int length;
}SqList;

void CreatList(SqList * &L,ElemType a[],int n)
{
   int i;
    L=(SqList *)malloc(sizeof(SqList));

   for(i=0;i<n;i++)
       L->date[i]=a[i];

   L->length=n;
}
void DispList(SqList *L)
{
    int i;
     if(L->length > 0)
    {
       for(i=0;i< L->length - 1;i++)
          printf("%d ",L->date[i]);

       int j = L->length - 1;
       printf("%d\n",L->date[j]);
   }
}
......
```

只要用顺序表实现即可，不要求和上述代码完全相同。对数组实现的表的代码不熟悉的同学可查阅教材P35-P38内容。

## 思路

这题我水过来的...所以没啥好讲的

# `E` Kevin_Feng玩炉石

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

一天Kevin_Feng在跟旅店老板玩一个叫做炉石传说的游戏 这个游戏是回合制的，在两人的对决中游戏每人最多有10回合，一共也就是**20回合**。由于双方手牌上限为10张牌，所以最多有**10次出牌**，每次出牌会消耗相应的费用。Kevin_Feng想去查询之前的出牌记录，可是游戏内只显示最近的几次，所以请你来帮帮他。

## 输入

多组输入数据 每组输入数据有n+m+1行

第一行有两个数n,m分别表示该局总共有n个回合以及m个查询次数

接下来的n行每行第一个数表示有t次出牌，第二个字母表示谁出牌的，接下来有t个字符串表示出的牌，每个字符串后面有一个int类型的数字表示出此牌的费用。

接下来的m行表示查询，每行第一个字母表示谁出了牌，第二个数表示第几回合（该玩家的第几个回合），第三个数表示当前回合第几次出牌。

## 输出

对于每组数据，输出m行，每行输出选中的字符串以及此牌的费用

## 输入样例

```
2 3
1 B LeperGnome 1
2 K TheCoin 0 FaerieDragon 2
B 1 1
K 1 1
K 1 2
```

## 输出样例

```
LeperGnome 1
TheCoin 0
FaerieDragon 2
```

## Warning

**不会有一个人连续两回合出牌的情况**

**Kevin 与 Boss先后手顺序不确定**

**请务必用结构体实现**

**看不懂描述的看这里：**K和B两个玩家轮流出牌，每个人出牌的时候可以最多出10张牌，每张牌有一个特定的描述以及相应的数字

## 思路

直接模拟即可，采用结构体实现会比较方便

# `F` SimpleCalculation

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## Problem Description

复数运算……这道题要求同学们**用结构体实现，虽然很水，但会检查代码**。

## Input

输入数据有多组，先输入数据组数n，接下来n行为测试数据。

每行第一个字符为运算符号（只有加减乘除），接下来四个实数分别为两个复数的实部和虚部。

## Output

对于每组测试数据，输出运算结果，保留两位小数,如果运算非法，请输出“Wrong Input！”。 （注意：输出格式要合理！）

## Sample Input

```
4
+ 1 1 1 1   
- 2 2 1 1   
* 0 0 0 0  
/ 0 0 0 0  
```

## Sample Output

```
2.00+2.00i  
1.00+1.00i  
0  
Wrong Input!  
```

## 思路

正常的进行模拟就可以了，**可以的话，把复数采用结构体封装，C++实现运算符重载即可**

**然后注意根据正常的表示法，什么时候需要多加正负号也是可考虑的问题，基本上样例给提示了，这一点也是非常容易考虑不清楚然后WA的**

# `G` MATRIX的查询

时间限制：1009ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

今天AZY来谈谈*matrix*，没见过这个单词的同学（如果有的话）请自行查词典。

![img](http://image.tmdb.org/t/p/original/ZPMhHXEhYB33YoTZZNNmezth0V.jpg)

嗯，虽然黑客帝国很好看，但这次要说的不是这个电影，而是Linear Algebra中的“矩阵”。

Given a m×n matrix，求其**任意子矩阵中不同数字的个数**。

## 输入

多组测试数据。 对于每组数据，第一行为三个整数m，n，t（1≤m,n≤500，1≤q≤100000），表示矩阵的大小为m×n，且有t组查询。

接下来m行，每行n个元素，用空格隔开，为对应的数字矩阵M，**其中0 ≤ Mij ≤ 9。**

再接下来t行，每行四个整数x1，y1，x2，y2，为一次查询，表示子矩阵的左上角坐标为(x1,y1)，右下角坐标为(x2,y2)。坐标代表二维数组的第几行第几列。（保证数据合理，具体见样例）

## 输出

对于每组测试数据，输出对应这组数据的每次查询的结果。

## 输入样例

```
3 3 3 
1 2 3
3 2 1
5 6 3
1 1 2 3
2 2 2 2
1 1 3 3
```

## 输出样例

```
3
1
5
```

## Hint & Warning

**数据量很大，请用scanf & printf，否则可能超时。**

**数据量很大，请用scanf & printf，否则可能超时。**

**数据量很大，请用scanf & printf，否则可能超时。**

二维随机变量的分布函数满足这样一些性质（图片来自上海交通大学数学系概率统计课程教学课件）：

![QQ截图20160305224333.jpg](https://ooo.0o0.ooo/2016/03/05/56daf15fcb4ea.jpg)

AZY知道你们对于概率统计这门课还没什么概念，——Please just pay attention to 图中那个“矩阵”以及最后几行那个式子。

此题考查**多维**数组的综合操作，此题的具体实现与概率没有任何关系。

## 思路

这个玩意儿就是二维前缀和，**只要把前缀和的记录信息为每个数出现的个数，就可以直接采用加和处理了**


# Other-Daily Training

# `A` 数字游戏（Game）

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

考虑下面一个两个人玩的游戏，在一个游戏板上有 N 个正整数排成一列。玩家 1 先玩。两个玩家交替从这列数的左端或右端取出一个数。取得的数值加入玩家的总分中，取完数后，如果玩家的分数大于他的对手的分数，他就赢了。

写一个程序执行最优策略。最优策略指的是与“最好的情况”对抗，你的程序认为对手也是用最优策略的。

## 输入

第一行是一个正整数 N（2<=N<=100），是游戏板上正整数的数量；

第二行到 N+1 行，每行一个数字，表示游戏板上从左到右的 N 个数。

## 输出

只有一行，两个数，分别是玩家 1 和玩家 2 的分数，用一个空格隔开。

## 输入样例

```
6 
4 
7 
2 
9 
5 
2 
```

## 输出样例

```
18 11 
```

## Source

江苏省苏州中学 NOIP 复赛训练题 2012

## 思路

**博弈论区间dp的入门题型(然而我没有入门，我是废物，我爬爬QAQ)**

**sum(i, j)表示i到j的所有和**

**dp(i, j)表示i位到j位可以使自己取到的最大和**

无论先手还是后手，都希望最优

**先手面临[x,y]那后手就是[x+1,y]或[x,y-1]**

先手一定是希望后手去较少的

**dp(i, j) = sum(i, j) - min(dp(i + 1, j),dp(i, j-1))**

后半部分为后者的，前者所得和为总和减后者

# `B` 加工调度（Prod）

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

某工厂收到了 n 个产品的订单，这 n 个产品要分别在 A、B 两个车间加工，并且必须先在 A 车间加工后才可以到 B 车间加工。

某个产品 i 在 A、B 两车间加工的时间分别为 Ai、Bi。怎样安排这 n 个产品的加工顺序，才能使总的加工时间最短。

这里所说的加工时间是指：从开始加工第一个产品到最后所有的产品都已在 A、B 两车间加工完毕的时间。

## 输入

第一行就一个整数 n（0<n<1,000），表示产品的数量。

接下来 n 个整数表示这 n 个产品在 A 车间加工各自所要的时间（不一定在一行上）。最后的 n 个整数表示这 n 个产品在 B 车间加工各自所要的时间（不一定在一行上）。

## 输出

一行一个数据，表示最少的加工时间。

## 输入样例

```
5 
3 5 8 7 10 
6 2 1 4 9 
```

## 输出样例

```
34 
```

## 样例说明

加工的顺序为：1 5 4 2 3。

## Source

江苏省苏州中学 NOIP 复赛训练题 2012

## 思路

经典贪心题目的结论:

**A机器上加工时间短的优先，B机器上加工时间长的优先**

首先取AB时间的最小值然后排序

然后根据最小值是a还是b决定排序排哪里

# `C` 捷径（Shortcut）

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

Mirek 有一条每天从他家去大学工作的最喜欢的路。这个路径由若干个部分组成，且每个部分都是 1 单位长的直线。每一个部分都是直线连接（没有拐弯）上一个部分或垂直连接上一个部分。在走过每一个部分后，Mirek 会休息下欣赏美丽的自然景色。在他走路的过程之中，他不会重复访问一个地点。

昨天，Mirek 在 party 中熬夜到很迟，并且今天他迟起床了。他意识到他会错过第一堂课除非他改变他平时走的路径。他计划找一条捷径，但他希望捷径尽量的短。捷径必须是水平的或者是垂直的并且连接两个 Mirek 原先路径的休息的地点。

请帮助 Mirek 找到最短的捷径。

## 输入

第一行包含一个整数 n（3<=n<=250,000）作为路径的部分的个数。第二行包含一组长度为 n 的序列，每个字母为 N，E，S 或 W，之间没有空格。每一个字母描述路径的一个部分。字母 N，E，S 或 W 表示 Mirek 向这些方向走了 1 单位长。你可以假设至少存在一个捷径。

45%的数据：n<=1,000

100%的数据：n<=250,000

## 输出

仅一行，包括 L、B、E 三个整数和一个字母 D，用空格隔开。L 是最短的捷径的单位长度。B 和 E 是休息点的编号，也就是捷径的起点和终点（Mirek 的 home 的编号为 0，大学的编号为 n）。字母 D 是捷径的方向。如果有超过 1 条最短的捷径存在，你应该输出起点最小的；如果有多个起点相同的捷径，你应该输出终点编号最大的。

## 输入样例

```
12 
NNNENNWWWSSW 
```

## 输出样例

```
2 3 11 W 
```

## Source

江苏省苏州中学 NOIP 复赛训练题 2012

## 思路

将起始点作为原点( 0 , 0 )，每次移动后，坐标记为( x i , y i ) 。共n+1个点，因为捷径是直线，所以每个点只需要找到x相等或y相等的点。

暂时只考虑x相等的状态，设当前共有k个点的x相等，y分别为y 1 , y 2 , . . . , y k ​。将y顺序排列，捷径一定是y 1 − > y 2，y 2 − > y 3,…,y k − 1 − > y k 。长度就为其坐标差。

y相等时同理。所有的状态求最小值即为所求。

注意有些原本的路径就是走的捷径，这些需要忽略。且题目要求输出 捷径最短，开始编号最小，结束编号最小的，所以在计算时，不仅需要记录坐标，还要记录处于该点的时间。

# `D` 旅行（Travel）

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

starhder 突发奇想，要去 G 地，于是他搞来了一张地图，看怎么走才好。

地图上有很多城市，G 地也是一座城市。每两座城市之间都可能有直达方法，也有可能两座城市之间并不能直接相通，而要通过其他的城市转达。对于两个城市之间的直达方法，需要一定的时间，当然，如果从 A 城市到 B 城市的直达方法需要 T 时间，那么从 B 城市到 A 城市的直达方法也是 T 时间。

starhder 想要用最短的时间到达 G 地，但是有个问题，他发现，地图上有些城市对他很有吸引力。所以他要在经过这些城市的基础上时间最短。

starhder 已经用 1、2、3、4、5……n 标记了他可能经过的城市（1 代表出发地，n 代表 G 地），但是眼花缭乱的地图让他感到烦恼。他请你来解决这个问题，告诉他最小需要多少时间到达 G 地。

## 输入

第一行是三个正整数 n 和 m，t，n 表示总共有多少个城市（包括出发地和 G 地），城市数不会超过 200 个；m 是城市的直达路线数（1<=m<=20,000），t 表示一定去的城市数，0<=t<=10（不包括出发地和 G 地）。

接下来一行有 t 个整数，表示一定要去的城市。

接下来 m 行，每行包含三个正整数，前两个数表示分别代表一个城市，第三个数是这两个城市之间的直达时间。直达时间不会超过 1,000,000。

## 输出

一个数，题目要求的得最短时间。

## 输入样例

```
5 10 2
4 3
1 2 29
1 3 91
1 4 17
1 5 30
2 3 12
2 4 65
2 5 70
3 4 38
3 5 16
4 5 44
```

## 输出样例

```
71
```

## Source

江苏省苏州中学 NOIP 复赛训练题 2012

## 思路

**本题要求的，就是给定了中途途径的城市之后，需要走的最短路径**

**那么首先很显然，首先利用floyd计算全源最短路，接下来考虑的节点就只有起点终点和这些途径城市了**

**接下来直接用全排列dfs即可，或者调用STL的next_permutation也是可以的**

# `E` 神秘岛（Road）

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 难题慎入

## 题目描述

FireDancer 来到一个神秘岛，他要从岛的西头到东头然后在东头的码头离开。可是当他走了一次后，发现这个岛的景色非常的美丽，于是他从东头的传送门传到了西头，换了一种走法又走了一遍。发现还不过瘾，又走了一遍……终于，FireDancer 把所有的从西头到东头的路径都走了一遍。他站在岛东头的海滩上，突然想到了一个问题，那就是他一共花了多少时间。他把这个问题交给了你。

FireDancer 把这个岛抽象成了一个图，共 n 个点代表路的相交处，m 条边表示路，边是有向的（只能按照边的方向行走），且可能有连接相同两点的边。输入保证这个图没有环，而且从西头到东头至少存在一条路径。两条路径被认为是不同的当且仅当它们所经过的路不完全相同。

## 输入

输入数据共若干行。

第 1 行为 5 个整数，n(2<=n<=10,000)、m(1<=m<=50,000)、s、 t、t0(t0<=10,000)，分别表示点数，边数，岛西头的编号，岛东头的编号和传送一次的时间（编号是从 1 到 n）。

接下来 m 行，每行 3 个整数，x、y、t (t<=10,000)，表示从点 x 到点 y 有一条行走耗时为 t 的路。

## 输出

输出数据仅一个整数。若总耗时为 total，则输出的值为 total mod 10,000。

## 输入样例

```
3 4 1 3 7 
1 2 5  
2 3 7 
2 3 10 
1 3 15 
```

## 输出样例

```
56
```

## 样例说明

共有 3条路径可以从点 1到点 3，分别是 1-2-3,1 -2-3和 1-3。时间计算为： (5+7 )+7+(5+10 )+7+(15)=56

## Source

江苏省苏州中学 NOIP 复赛训练题 2012

## 思路

**本题是拓扑排序+dp的综合应用，推不出dp方程基本上就做不出来了...**

推导过程如下:

**首先途径某一个节点的次数是inCount 走到这里用的总时间是inTime**

在有了拓扑排序了之后

**首先初始化inCount[start]=1 inTime[finish]=0**

对于排序中的每一个元素v

设接入v的边另一端为u

**那么inCount[v]=∑inCount[u]**

**inTime[v]=∑inTime[u]+wi\*inCount[u]**

**最后inTime[finish] + (inCount[start] - 1)\*cost就是所求**


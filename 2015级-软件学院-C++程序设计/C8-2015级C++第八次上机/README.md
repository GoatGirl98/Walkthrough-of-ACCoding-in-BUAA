# C8-2015级C++第八次上机

# `A` 水水的矩阵翻转

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

签到题~
给定一个n*m的二维数组，将它横向翻转并纵向翻转后输出出来。

## 输入

多组数据。 每组数据第一行为两个数字n,m(n,m<=1000)。 接下来一个n*m的矩阵，矩阵的元素均在int范围内。

## 输出

输出翻转后的矩阵。

## 输入样例

```
2 3
1 2 3
4 5 6
```

## 输出样例

```
6 5 4
3 2 1
```



# `B` 元素查找

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

给你一个数列，以及一组查询，查询某一特定元素是否存在于数列之中，如果存在，则输出该元素是数列中第几小，否则输出"error"。

## 输入

多组测试数据。
对于每组数据，第一行为两个整数n,m(1<=n<=1000,1<=m<=250000)，表示数列中有n个元素以及m次查询。 第二行包含n个正整数，用空格分隔，表示一个数列。 接下来m行，每行一个整数，表示每次查询的元素。

## 输出

输出m行，每行输出内容见题目描述及样例

## 输入样例

```
5 3
5 4 3 2 1
3
5
7
4 2
1 2 2 3
2
3
```

## 输出样例

```
3
5
error
2
4
```

## 思路

做法多样，甚至全都存到哈希表里都可以通过，但是这样做毫无疑问是最慢的做法

# `C` 寻找方程的根!

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

已知方程
2sin（x）+sin(2x)+sin(3x)+(x-1)^2=y
现在给出y，求方程在[4,8]内的根。
若有一个根，输出这个根（保留6位小数）；若没有根，输出“No solution!”。

## 输入

输入共多组数据。
每组一个数，为y。

## 输出

若方程在[4,8]有根,则输出方程的根；若方程无根，则输出“No solution!”。

## 输入样例

```
1.0
20.0
```

## 输出样例

```
No solution!
5.776735
```

## 思路

经典的二分答案求方程根，如果WA了就再多加一点精度



# `D` 成绩统计II

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

话说宋老师拿到了大家这几次上机的成绩，一大串数字看起来很麻烦，于是让两位助教好好统计一番。两人说我们也不会啊，于是你们就自己统计自己的程序好了。
给定n个同学的学号、m次上机成绩，要求大家按照所有上机的平均成绩降序（平均成绩相同的按照学号降序排列）对所有同学排序之后，输出所有同学的平均成绩（保留三位小数）。

## 输入

多组测试数据。对于每组数据，第一行为三个数字人数n，上机次数m(n,m<=1000)。 接下来有n行，每一行开头为一串数字(保证在long long范围内)，为这位同学的学号。接下来m个100以内的数字，为历次上机成绩。

## 输出

对于每组数据，输出n行。 每位同学的成绩输出占一行，包括用空格隔开的学号跟上机平均成绩。

## 输入样例

```
2 2
111 99 99
222 90 94
```

## 输出样例

```
111  99.000
222  92.000
```



# `E` 区间求和

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

给定一个整数序列，你能求出其中位置在[a,b]区间内数字的和么喵？

## 输入

多组测试数据。
第一行为两个数字n,m(0<n<=1e6,0<m<1000)。
接下来一行为一个长度为n的序列，每个元素均不大于100。
接下来为m行，每行两个数字a、b，代表m次询问的区间。

## 输出

对于每一次询问，输出一行，为该区间内数字的和。

## 输入样例

```
3 2
1 2 3
1 2
1 3
```

## 输出样例

```
3
6
```

## 注明

这题被锁了，所以没有这道题的AC代码

但是这题非常的简单，一个前缀和直接搞出来了

# `F` 黑白棋I

时间限制：10ms  内存限制：5000kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

黑白棋是一种两人对弈的游戏，一人执黑子，一人执白子。所用的棋盘为8×8，开盘时，棋盘上正中共有4粒棋子，呈对角线排列，两白两黑，由执黑者先行。
黑白棋的走法关键在于"夹"字，无论黑白哪方，都必须将棋子下在夹住对方的棋子的地方。其夹法可以采用直线、斜 线，下在其它地方均属非法，系统将不允许落子。
被对方棋子夹住的棋子，会"投降"变成对方的棋子。同样的，不论直线斜线，只要被对方的棋子夹住，都会"投降"。 因此，你一定要落子巧妙，就可以用最少的棋子夹住最多的棋。
若有一方没有地方可以合法落子，则系统会自动跳过，由对方走。
获胜有两种情况：
当棋盘下满或双方都无棋可走时，谁的棋子多，谁获胜。
当一方将对方的全部棋子俘虏时该方获胜。
若棋盘下满或双方都无棋可走时，双方棋子数目相同，则和棋。
我们来举一个栗子：
下图是开局情况，执黑先行：
![img](http://acm.hdu.edu.cn/data/images/C288-1008-1.jpg)
如下图，透明黑子为可能的走法
![img](http://acm.hdu.edu.cn/data/images/C288-1008-2.jpg)

下完黑棋后，按照规则，黑棋与其它黑棋之间的直线（水平，竖直或对角）上的白子都会变成黑子，这些棋子之后可为黑棋所用，即被对方棋子“夹”住的棋子，会“投降”变成对方的棋子——除非白子又把它们变了回来。换句话说，一个有效的落子必须反转至少一个对方的棋子。
如果黑子下在上面的位置，位于d4的白子被反转 ：

![img](http://acm.hdu.edu.cn/data/images/C288-1008-3.jpg)
然后白棋下。按照相同的规则，白棋落子，反转位于d5的黑棋。下图，透明白子为可能的走法
![img](http://acm.hdu.edu.cn/data/images/C288-1008-4.jpg)
白子落在左下角，反转位于d5的黑棋
![img](http://acm.hdu.edu.cn/data/images/C288-1008-5.jpg)
按照上述规则，双方交替进行，如果一方没有地方可以合法落子，则跳过，由对方走。当棋盘下满或一方都无棋可走或双方无法均合法落子时，游戏结束。 现在经过几轮之后，黑棋下。你可以求出最大能反转几颗白子吗？

## 输入

第一行输入一个整数T表示数据组数
每组数据有8行，每行8个字符，（D代表黑棋，L代表白棋，*代表没有棋子） 相邻的两组数据之间有一个空行

## 输出

每组数据，输出第几组数据和最大能反转的白子数，如果没有地方可以合法落子，输出0 请按照样例输出的格式输出

## 输入样例

```
3
********
********
********
***LD***
***DL***
********
********
********

********
********
**DLL***
**DLLL**
**DLD***
********
********
********

********
********
*D******
*DLLD***
***LL***
**D*D***
********
********
```

## 输出样例

```
Case 1: 1
Case 2: 3
Case 3: 0
```

## Hint

TLE的同学注意使用scanf，同时对代码进行优化
MLE的同学注意数组的类型及大小，省去不必要的递归
WA的同学注意特殊情况
RE的同学仔细检查数组越界
学长只能帮你到这了
powered by microhhh——冬藏，期待春生

## 思路

进行dfs搜索，枚举下在每一个位置最多可以翻转多少棋子

# `G` 大只的回文数

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

想必大家对回文数一定有所了解吧：像121,1221,1这样的就是回文数啦！
现在请大家数一数[a,b]区间内到底有多少回文数呢？

## 输入

多组输入数据
每组数据共一行，每行两个int范围内的正整数a，b，以空格隔开。

## 输出

对于每组数据，输出一个数ans，表示[a,b]中回文数的个数。

## 输入样例

```
1 1
```

## 输出样例

```
1
```

## 思路

这种题一看就知道是要先求[1,n]的个数，然后拿[1,r]的个数-[1,l-1]的个数即为所求。

10^k之内有几个回文数是小奥问题，可以自行查到

首先考虑位数为偶数的时候，如1542，位数为4，将它对半分为15和42，则当前半部分为14的时候，后两位可以取00到99之间的任意数，所以前两位从10到14都可以找到对应的后两位(如01，41)来形成回文数。此时我们只需考虑前两位是15的情况。观察知道后两位至少得是51才能与15形成回文数，而42 < 51，显然不行，也就是说1542只可形成前两位10到14这样5个回文数(1001，1111，1221，1331，1441)。求出了1000以上的回文数有多少个，再加上小于1000的回文数个数，即是[1,1542]之间回文数的个数。

故：对于数abcd，大于1000时，我们只需比较cd与ba的大小，如果cd>=ba，则有(cd-10)+1个回文数，否则为cd-10个。对于任意有2 * l位数，令t=a/(10^l)(t就是该数的前面一半)，则:

ans=f[2 * l-1]+t-10^(l-1)或ans=f[2* l-1]+t-10^(l-1)+1;

同理,对于位数为奇数的数如25368，只需比较368与352的大小，答案情况同上，如abcde,比较cde与cba的大小。如果数很大的话，最好用long long,这里用的是int.

如果要是求区间[a, b]内的回文数，只需分别求出[1, b]和[1, a - 1]内的回文数，两者相减即可得出答案。
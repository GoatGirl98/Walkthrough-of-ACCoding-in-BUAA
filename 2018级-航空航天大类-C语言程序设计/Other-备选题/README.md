# Other-备选题

# 维修数列

时间限制: 1000 ms 内存限制: 131072 kb

总通过人数: 21 总提交人数: 48

## 题目描述

要求维护一个数列，支持以下5种操作：

1. 在数列末尾增加一个数
2. 在数列开头增加一个数
3. 输出数列开头的数据并把这个数据删除
4. 删除数列中从前往后第一次出现的某一个数
5. 输出数列中数的个数

最开始数列为空，保证数的范围在[0,1050,105]

具体意思请结合样例理解

## 输入

第一行一个𝑚(𝑚<=106)m(m<=106)，表示要进行操作的数目。

接下来𝑚m行，每行的第一个数𝑜𝑝op为操作的编号

如果op为1，2，4，这行会有第二个数𝑥x，表示要被增加或者被删除的数字

如果op为3，5，不会有第二个数字

## 输出

输出若干行 当op为1，2时，不输出

当op为3时，如果数列为空输出error(此时不操作数列)，否则输出数列的第一个数

当op为4时，如果数列中没有x输出error(此时不操作数列)，否则不输出

当op为5时，输出数列中数的个数

最后一行按顺序从前往后输出最终的数列(为空输出null)

## 样例输入1

```
8
1 1
2 2
1 2
5
4 2
4 2
4 2
3
```

## 样例输出1

```
3
error
1
null
```

## 样例解释1

给出数列的变化

[] →→ [1] →→ [2, 1] →→ [2, 1, 2] →→ [1, 2] →→ [1] →→ []

## 样例输入2

```
4
1 1
2 2
2 3
2 4
```

## 样例输出2

```
4 3 2 1
```

## 样例解释2

[] →→ [1] →→ [2, 1] →→ [3, 2, 1] →→ [4, 3, 2, 1]

## 数据范围

对于第1, 2, 3组数据, m <= 1000，共30分

对于第4, 5, 6组数据，m <= 1000000, 没有4操作，共70分

## 挑战

这个题在m = 1000000且有操作4的时候也是可以做的，这里留给有兴趣的同学思考，也欢迎与出题人讨论

## 思路

**在这个范围下，用C语言最好想出的思路是直接用链表来模拟**

**拥有操作4的话，可以采用序列操作一系列的方法，比如说Splay平衡树/pb_ds等方式进行优化，当然有一种最快的方式，可以保证如果询问次数是k，那么时间复杂度就是O(k)，虽然我不清楚这个咋做= =**
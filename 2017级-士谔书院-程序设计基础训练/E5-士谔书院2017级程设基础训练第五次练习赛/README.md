# E5-士谔书院2017级程设基础训练第五次练习赛

# `A` 矩阵乘法

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

计算
$$
\left(
\begin{matrix}
   a_{00} & a_{01}  \\
   a_{10} & a_{11}
\end{matrix}
\right)
\left(
\begin{matrix}
   b_{00} & b_{01}  \\
   b_{10} & b_{11}
\end{matrix}
\right)
=
\left(
\begin{matrix}
   c_{00} & c_{01}  \\
   c_{10} & c_{11}
\end{matrix}
\right)
$$
保证所有输入输出数据均在 `int` 范围内。

## 输入

第一行空格隔开的四个整数，分别表示 a00,a01,a10,a11a00,a01,a10,a11。

第二行空格隔开的四个整数，分别表示 b00,b01,b10,b11b00,b01,b10,b11。

## 输出

输出一行，空格隔开的四个整数，分别表示 c00,c01,c10,c11c00,c01,c10,c11。

## 输入样例

```
1 0 0 1
1 2 3 4
```

## 输出样例

```
1 2 3 4
```

## 思路

学过线代就好说了

# `B` 字符统计

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

输入一行字符串，每个字符都是可见字符（也即 `ASCII` 码在[32,126] 以内）。输出这些字符中数字、小写字母、大写字母每种分别各有多少个。

请使用 `EOF` 判断输入结束。

## 输入

一行字符串。长度在 1000 以内。

## 输出

输出三行。

第一行空格隔开的 1010 个整数，分别表示 `'0'`,`'1'`,...,`'9'` 的个数。

第二行空格隔开的 2626 个整数，分别表示 `'a'`,`'b'`,...,`'z'` 的个数。

第三行空格隔开的 2626 个整数，分别表示 `'A'`,`'B'`,...,`'Z'` 的个数。

## 输入样例

```
{2}[a] Z.
```

## 输出样例

```
0 0 1 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
```

## 来源

课件第 1414 页

## 思路

直接模拟，如果想省事，使用ctype.h头文件也可

# `C` 排序

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

输入一个整数序列 a1,a2,…,ana1,a2,…,an，将其降序排序之后输出。

## 输入

第一行，一个整数 n ，表示序列长度。1≤n≤1000。

第二行空格隔开的 n 个整数，均在 `int` 范围内。

## 输出

一行，空格隔开的 n 个整数，表示排序之后的序列。

## 输入样例

```
3
6 6 6
```

## 输出样例

```
6 6 6
```

## 来源

课件 21∼39页。

## 思路

如果手写cmp函数使用qsort，请**务必不要学书上直接return a-b，因为会出现精度溢出的问题**

# `D` 求集合交集

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

从标准输入中读入两个正整数可重集合，在标准输出上升序输出它们的交集。

## 输入

第一行空格隔开的两个整数 n,m(1≤n,m≤1000)n,m(1≤n,m≤1000) ，分别表示两个可重集合的大小。

第二行空格隔开的 nn 个正整数 ai(1≤ai≤1000)ai(1≤ai≤1000)，可以有重复。

第三行空格隔开的 mm 个正整数 bi(1≤bi≤1000)bi(1≤bi≤1000)，可以有重复。

## 输出

如果交集为空，那么输出 `"Intersection set empty!"`（不含引号，注意大小写）。

否则，升序输出空格隔开的若干个整数，表示两个集合的交集，重复元素只输出一次。

## 输入样例

```
3 3
1 1 3
3 2 1
```

## 输出样例

```
1 3
```

## 来源

课后题第 22 题。

## 思路

一般来说，直接排序然后模拟即可

但是对于c++来说，采用algorithm库的黑科技就变得很重要了

# `E` 折半查找

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

给定一个严格升序整数序列 a1,a2,…,ana1,a2,…,an（没有相同元素）。并给出 qq 次询问，每次询问一个整数 xx，要求输出它在序列中的下标。请使用**折半查找**算法。

## 输入

第一行两个整数 n,qn,q。分别表示序列长度和询问次数。1≤n,q≤1051≤n,q≤105。

第二行空格隔开的 nn 个整数 aiai，均在 `int` 范围内。保证没有相同元素，且以升序给出。

接下来 qq 行，每行一个整数 xx 表示询问的数字。如果该数字在序列中出现，输出其下标，否则输出 `"tan90"`（不含引号）。

## 输出

对于每次询问，输出一行一个整数，表示答案。

## 输入样例

```
5 4
-3 0 1 45 100
1
-3 
-1
100
```

## 输出样例

```
3
1
tan90
5
```

## 来源

课件 40∼44 页。注意不要超过**时间限制**。

## 思路

手写二分查找即可

c++选手可以直接使用lower_bound
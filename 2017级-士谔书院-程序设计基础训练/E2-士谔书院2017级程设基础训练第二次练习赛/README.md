# E2-士谔书院2017级程设基础训练第二次练习赛

# `A` 数位各位之和

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

输入一个数字，求其各位数字之和。例如 123123 ，那么其各位数字之和为 1+2+3=61+2+3=6。

## 输入

第一个数为数据组数 TT, T≤20T≤20。

接下来 TT 行，每行 1 个正整数 nn，n≤106n≤106。

## 输出

对于每组数据，输出一行，表示其各位数字之和。

## 输入样例

```
2
123
55
```

## 输出样例

```
6
10
```

## 思路

可以采用类似快速读入整数的做法进行读入，逐位读入并加和。

**题解中给出的做法，读入的速度比scanf更快，可以更好地用在其他题目当中。**

# `B` 判断质数

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

输入若干个正整数 nn，判断其是否为质数。

## 输入

第一个数为数据组数 TT, T≤20T≤20。

接下来 TT 行，每行 1 个正整数 nn，n≤106n≤106。

## 输出

对于每组数据，输出一行，如果 nn 是质数，输出 `"YES"` ，否则输出 `"NO"`（均不含引号，注意大小写）。

## 输入样例

```
2
10
11
```

## 输出样例

```
NO
YES
```

## 思路

**要么暴力枚举到sqrt(n)检查是否存在整除的因子，要么直接预处理打表，直接得出哪些是质数**

其实采用更快的MillerRabin会更快

# `C` 逆序对统计（naive版）

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

```
此题需要用数组，没学过的同学请跳过
```

有兴趣的同学可以去做[加强版](https://accoding.cn/problem/14/index)。

输入一个 1 到 n 的排列，要求输出逆序对的个数。

**排列**：1 到 n 的排列是指，一个长度为 n 的数列，且数列元素只由 1 到 n 的正整数组成。每个元素出现有且仅有一次。

**逆序对**：对于数列，其逆序对的个数定义为有序对 (i,j)(i,j) 的个数，且满足 i<ji<j 以及 a[i]>a[j]a[i]>a[j]。

## 输入

第一个数为数据组数 TT, T≤10T≤10。

接下来 TT 组数据，每组数据由两行组成。

每组数据第一行为 1 个正整数 nn，n≤103n≤103。第二组为空格分隔的 nn 个正整数，表示一个 1 到 nn 的排列。

## 输出

对于每组数据，输出一行，表示该组数据的逆序对个数。

## 输入样例

```
2
3
1 2 3
5
5 4 3 2 1
```

## 输出样例

```
0
10
```

## 思路

本题解代码是**加强版题目（题目编号14）的归并排序模板，**正常的话采用冒泡排序等O(n^2)的算法即可

# `D` 今天是星期几呀

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

已知 2000 年 1 月 1 日是星期六，现在告诉你一个日期，要求你输出该天是星期几。

## 输入

第一个数为数据组数 TT, T≤20T≤20。

接下来 TT 行，每行用空格隔开的三个整数，分别表示年份，月份，日期。保证输入数据合法，且不在 2000 年 1 月 1 日之前。年份在 1000010000 以内。

## 输出

对于每组数据，输出一行，用数字 1 到 7 表示星期一到星期天。

## 输入样例

```
2
2000 1 2
2017 10 30
```

## 输出样例

```
7
1
```

## 思路

你听说过蔡勒公式吗？

# `E` 阶乘的小尾巴

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

读入一个整数 nn ，输出 n!n! 去掉末尾的 00 后的最低 1010 位。如果不足 1010 位，在前面补足 00。

例如 5!=1205!=120 ，那么去掉末尾的 00 之后，数值为 1212，所以应该输出 00000000120000000012。

**请大家注意使用 64 位整数。**

*ps*：在c语言的较新标准中，可以包含头文件 `stdint.h` ，然后使用数据类型 `int64_t` 定义64位整型。输出的时候格式控制符由 `%d` 改为 `%lld`。

输出10位不足补0的控制符为 `%010lld` 。

## 输入

第一个数为数据组数 TT, T≤10T≤10。

接下来 TT 行，每行一个整数 nn 。 0≤n≤200000≤n≤20000。

## 输出

对于每组数据，输出一行，含义见题目描述。

## 输入样例

```
2
5
10
```

## 输出样例

```
0000000012
0000036288
```

## Hint

由数论知识我们知道，在模某个数 pp 的意义下，是不能直接做除法的。而应该乘上除数在模 pp 意义下的逆元。但是本题中 1010 在模 10101010 的意义下没有逆元，所以我们应该用其他算法。

我们考虑枚举 11 到 nn 的每个数，将其乘到答案上的这个过程。我们可以先去掉它里面的 22 和 55 这两种因子，并分别记录一下个数。这样我们在做乘法的时候，中间过程的数末尾不会出现 00，我们也就不用像之前那样除以 1010 了，可以在中途对 10101010 取模。最后再把剩余的 22 乘到答案上即可。

本题模数和除数比较特殊，用一些其他的方法也可以卡过。

## 思路

本题既然说了，显然本题用逆元是做不出来的（逆元最首要的就是需要互质条件）

**采用高精度卡过本题是一种方法，但是不推荐写，因为完全没有必要**

考虑到需要去掉所有的最末尾0，那么我们就考虑n的阶乘当中，**质因子2和5都分别出现了多少次。先把所有的2和5都剔除掉，然后明显可以发现，2出现的次数一定是大于等于5的，所以等价需要去掉的10的个数就是5出现的次数，把2比5多出现的次数重新补回来，乘起来即为所求**

**别忘了边乘边模10的10次方，采用printf输出的时候记得补足够宽度的0**


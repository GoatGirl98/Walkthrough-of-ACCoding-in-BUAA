# C7-士谔书院2017级程设基础训练第七次上机

**E题出处是2015级C++程序设计，请读者到对应课程进行查找**

# `A` 粒子加速

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

由于TQ的精致睡眠又一次被打游戏的室友打扰，他的怒气值已经达到了2147483648（没错，已经溢出了！）。

进入狂暴状态的TQ决定用新入手的阿姆斯特朗回旋加速喷气式阿姆斯特朗炮教给舍友一些做人的道理。

现在已知粒子的初始速度 xx ，并且经过阿姆斯特朗回旋加速喷气式阿姆斯特朗炮加速后的粒子速度 yy 满足y=arcsin(x1+x)∗2.33+(x+2)3y=arcsin⁡(x1+x)∗2.33+(x+2)3。TQ想知道加速后粒子的速度。

## 输入

第一个数为数据组数 n(1≤n≤100)n(1≤n≤100)。

接下来 nn 行，每行一个整数 x(1≤x≤10)x(1≤x≤10)。

## 输出

对于每组数据，输出一行，为加速后粒子的的速度，要求保留两位小数。

## 输入样例

```
1
1
```

## 输出样例

```
28.22
```

## Hint

arcsin 可以用 `math.h` 库中的 `asin` 函数实现。

# `B` 成绩统计

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

 要到期末了，各位助教需要统计大家每次的上机成绩。但是各位助教太忙了，需要你们来帮助统一一下。成绩标准如下：
$$
A :500< X\le 600
\\B:400<X\le 500
\\C:300<X\le400
\\D:200<X\le 300
\\E:X\le200
$$
我们需要你们输出该成绩对应的等级。

## 输入

多组数据输入。

第一行输入数据组数T(T≤1000)T(T≤1000)

接下来T行，每行一个整数X(0≤X≤600)X(0≤X≤600)代表一个成绩。

## 输出

每个成绩输出一行对应的等级

## 输入样例

```
6
123
234
345
456
567
600
```

## 输出样例

```
E
D
C
B
A
A
```

# `C` 回文串判断

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

我们把形如 `abba` ， `ab3h3ba` 这种首尾对称的字符串称为回文串，现在请你设计一个程序判断任何一个字符串是不是回文串（包括单个字符的字符串，比如 `a` 也是回文串）。

## 输入

输入一行字符串，字符串长度最长为 5050。该字符串只包含字母及数字。

## 输出

如果该字符串是回文串，则输出 11 ,否则输出 00。

## 输入样例1

```
ab267g929g762ba
```

## 输出样例1

```
1
```

## 输入样例2

```
abc
```

## 输出样例2

```
0
```

# `D` 计算行列式的值

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

给定一个 nn 阶行列式，请求出它的值。

## 输入

第一行输入行列式的阶数 n(1≤n≤10)n(1≤n≤10)。

接下来为 nn 行，每行 nn 个整数，用空格分开，表示行列式xij(−100≤xij≤100)xij(−100≤xij≤100)。

## 输出

输出行列式的值，测试数据保证计算过程和结果中产生的值均不会超过 `int` 的范围。

**提示**：

- 回想线代课上学习的按行展开的方法，可以每次按照行列式的第一行展开，然后递归处理。

以样例作为例子：
$$
\begin{aligned}
\left(
\begin{matrix}
   2 & 3 & 0\\
   -1 & 4 & 2\\
   1 & -2 & 3
\end{matrix}
\right)
&=
2\cdot 
\left(
\begin{matrix}
   4 & 2\\
   -2 & 3
\end{matrix}
\right)
+
(-1)\cdot 3\cdot
\left(
\begin{matrix}
   -1 & 2\\
   1 & 3
\end{matrix}
\right)
+0\cdot 
\left(
\begin{matrix}
   -1 & 4\\
   1 & -2
\end{matrix}
\right)\\
&=2\cdot 16 + (-3)\cdot (-5)=47
\end{aligned}
$$

- 或者可以按照求行列式的定义，枚举排列求解。

也即使用公式：
$$
\det(A)=\sum_{j_1j_2\dots j_n}(-1)^{\tau(j_1j_2\dots j_n)}\prod_{i=1}^n a_{ij_i}
$$

## 输入样例

```
3
2 3 0
-1 4 2
1 -2 3
```

## 输出样例

```
47
```

## 思路

**直接根据题目给的两种思路，要么采用展开定理递归计算行列式值，要么全排列再乘以(-1)^逆序对**

无论如何都要用到dfs递归就是啦

**但是我们也可以考虑采用O(n^3)的高斯消元来做**

# `F` 角谷定理（伪）

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

我们要求的是：给定一个数 nn，求它在不超过 kk 次操作（每次操作选择 “乘 22 ” 或 “乘 33 加 11 “ ）内，能得到的所有数（至少操作一次），按升序输出。

## 输入

两个整数n,k(0≤n≤100,0<k≤10)n,k(0≤n≤100,0<k≤10)。

## 输出

按升序输出所有可能得到的数（若某个数重复出现，只输出一次）。

## 输入样例

```
1 2
```

## 输出样例

```
2 4 7 8 13
```

## 样例解释：

$$
1\begin{cases}
1*2 = 2\begin{cases}
2 * 2 = 4
\\ 2* 3 + 1 = 7
\end{cases}
\\ 1* 3 + 1 = 4\begin{cases}
4 * 2 = 8
\\ 4 * 3 + 1 = 13
\end{cases}
\end{cases}
$$

所以我们可能得到的数为 `2 4 7 8 13`。

## 思路

本题解法较多

包括采用dfs进行搜索，或者随机数暴力求值也可

如果是c++选手，可以直接利用优先队列进行bfs，还避免了爆栈的可能

注意去重输出即可

# `G` TQ的图像处理

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

铁拳最近在做一个视觉火灾识别系统，在进行训练前，铁拳得对图像进行预处理。然而铁拳最近学数学不开心，这种事情就只能扔给你们来做了啦。输入一个 n×nn×n 的灰度图。对该图做以下几种操作：

1. `getH`: 对给定区域的每个点的灰度值 xx，求 HH，并用 HH 替代。H=(x2+233)%1773H=(x2+233)%1773。若该点已求过 HH 值，则不做处理。
2. `normalize`:对给定区域的每个点进行判断，如果求过 HH 值，HH 值不为零就取为 11，否则取 00。若没有取过 HH 值，就不做处理。
3. `display`：以 `#`+66位1616进制大写（没有加号，如 `#123ABC`）输出给定区域的当前状态（即输出现在该区域每个点对应的 HH 或 xx 值，两个数之间有**两个**空格，允许行末空格）。

## 输入

多组数据，第一行一个数 T(1<T≤1000)T(1<T≤1000)，表示数据组数。

对于每组输入第一行输入n,mn,m，nn 为图的大小，mm 为操作的个数，n∈[1,100],m∈[0,100]n∈[1,100],m∈[0,100]。

接下来 nn 行，每行 nn 个空格分隔的整数，表示 n×nn×n 的灰度图。(灰度值的范围为 [0,256][0,256]）。

在接下来 mm 行代表 mm 组操作。输入操作的名称（一个字符串，含义见题目描述），接着四个整数 x1,y1,x2,y2x1,y1,x2,y2 为给定区域的对角线两点。

保证所有的输入合法。

## 输出

在所有操作结束后以 44 位**十进制**（不足四位前补 00）输出最后整幅图的状态。（即输出现在整幅每个点对应的 HH 或 xx 值，两个数之间有**两个**空格，允许行末空格，输出格式见样例）。

## 输入样例

```
1
4 5
234 97 23 247
187 198 242 256
98 66 96 90
13 43 88 54
display 1 1 4 4
getH 2 2 4 4
normalize 3 3 4 4
getH 1 1 3 3
normalize 2 2 3 3
```

## 输出样例

```
#0000EA  #000061  #000017  #0000F7  
#0000BB  #0000C6  #0000F2  #000100  
#000062  #000042  #000060  #00005A  
#00000D  #00002B  #000058  #000036  
0026  0777  0762  0247  
1515  0001  0001  0168  
0972  0001  0001  0001  
0013  0309  0001  0001
```

## 思路

没啥能说的，好像2016级C++也有个类似的题目，没准就是直接搬过来改了改的

但是本题容易0.6WA，和那个题类似...

# Special-2020级航类庆五一专题赛

LaTeX公式如果无法在线渲染，请下载查看。

所有的标题与题目描述均经过删改（**以防整个项目被github干掉**），**原始题面请前往OJ查看。**

# `A` 

时间限制：1000ms  内存限制：65536kb

通过率：456/498 `(91.57%) `  正确率：456/965 `(47.25%)`

## 题目描述

## 输入

无

## 输出

输出下图中的文字

[插图敏感,请前往OJ查看]

## HINT

在使用输出函数直接输出**中文字符**时，平台会自动转为`UTF-8`编码进行输出。如果只输出ASCII码值，请确保你的码值对应`UTF-8`的编码。

## 备注

本题由于政治敏感原因（**害怕这个项目直接被扬了**），请各位直接前往OJ平台对应题目查看输出要求。本项目上传的代码为纯UTF-8码输出的做法。

# `B` 猜拳擂台

时间限制：1000ms  内存限制：65536kb

通过率：167/243 `(68.72%) `  正确率：167/732 `(22.81%)`

## 题目介绍

AAUB猜拳擂台来了！每位参加比赛的选手均有一个四位数的编号，第一位选手即是擂主。每轮比赛仅进行一局，获胜者成为新的擂主。请你输出最后的擂主。

## 输入格式

本题中，大写字母`A, B, C`分别代表剪刀、石头、布。

第一行，一个数字，代表第一位选手的编号。

接下来不定行，每一行为一位打擂选的手编号，以及比赛情况。每行格式举例如下：

`0001 A C`： 其中第一个数字打擂选手的编号，对于每一次猜拳，第一个字符为**擂主**的出拳，第二个字符为**打擂选手**的出拳。

例如：编号后第一个非空字符`A`代表**擂主**出了剪刀，第二个非空字符`C`代表**打擂选手**出了布。

请使用`EOF`判断输入结束。

## 输出格式

输出最终擂主的编号，以及他总共参与的对局数，使用空格分隔。

## 输入样例

```
1001
1002 A C
1003 A B
1004 B C
```

## 输出样例

```
1004 1
```

## 数据范围

保证不会出现平局的情况。

## HINT

需要注意：如果最终擂主为`0001`，必须原样输出其四位数编号`0001`。

注意选手可能重复上台哦。

不要问我最多有多少位选手，不想告诉你。

*AUTHOR: Xutian Jing*

## 思路分析

需要注意的是，如果一个人中间被挑战下去了，又重新登上了擂主席，那么他之前的博弈次数也要计算进去

# `C` cbj统计很多个班的成绩

时间限制：1000ms  内存限制：65536kb

通过率：80/111 `(72.07%) `  正确率：80/322 `(24.84%)`

## 题目描述

## 输入

若干行字符串 每一行字符串是空格分开的若干个整数，结尾可能有空格或者换行符`\r`

每个整数表示**姜老师**教授的一门课程的一位学生的期末考试成绩

本题字符串数量不确定，请使用`EOF`判断结尾。

## 输出

对于每组数据,输出一行,格式如下(详见样例)

行号:学生人数 平均分(保留2位小数)

## 数据范围

保证每组输入字符串长度小于$5000$

保证每个成绩为$[0,100]$的整数

## 输入样例

```
1
1 2
11 45 1 41 91 98 10
```

## 输出样例

```
1:1 1.00
2:2 1.50
3:7 42.43
```

## HINT

`姜老师`:可以参考课件

*author:cbj*

## 思路分析

一行的不定组输入，C语言要实现的话需要一定技巧

# `D` 合成OJ排行榜（青春版）

时间限制：1000ms  内存限制：65536kb

通过率：97/105 `(92.38%) `  正确率：97/238 `(40.76%)`

试着做一个简单的OJ排行榜吧！

OJ排名的条件：分数高的排名在前，分数相同情况下用时少的同学在前，当分数，用时均相同时学号小的同学在前

## 输入格式

第一行一个整数`n`，表示共`n`个同学，之后`n`行，每行包括：

同学的`id`(一个只由英文字母，`%`，数字组成的字符串，长度不超过`50`)

同学的学号（一个`int`范围内的正整数，任意两个同学不相同）

同学的分数（一个`float`范围内的实数）

同学的罚时（一个时间，格式为`%d:%d:%d`，分别代表时，分，秒，每个整数有且只有两位）

这四部分都用一个空格隔开，具体见输入样例

## 输出格式

输出完整的排行榜，每个同学分数保留两位小数，其他信息与输入要求相同，

## 输入样例1

```
4
lzq 183741430 100 12:59:59
lzqpro 183741431 200 11:59:59
lzqpromax 183741432 200 00:12:01
lzqlite 18371433 0 12:59:59
```

## 输出样例1

```
lzqpromax 183741432 200.00 00:12:01
lzqpro 183741431 200.00 11:59:59
lzq 183741430 100.00 12:59:59
lzqlite 18371433 0.00 12:59:59
```

## 输入样例2

```
3
a 1 1 00:00:01
b 2 1 00:00:01
c 3 1 00:00:00
```

## 输出样例2

```
c 3 1.00 00:00:00
a 1 1.00 00:00:01
b 2 1.00 00:00:01
```

## 数据范围

$1≤n≤1000$

## HINT

请用`%02d`控制时,分,秒的输出

`Author:`摸鱼的雒子清

# `E` 

时间限制：128ms  内存限制：2048kb

通过率：101/124 `(81.45%) `  正确率：101/332 `(30.42%)`

## 题目描述

一次行军中，有**一位**战士落单，没有回到终点。
每位战士有一个**编号**`id`，现在给出起点处登记的编号，终点处登记的编号，请输出没有回到终点的战士编号。

## 输入格式

三行。 第一行输入从起点出发的战士人数`n`
第二行为起点处记录的`n`个编号，随机排列，用空格隔开。
第三行为终点处记录的`n-1`个编号，随机排列，用空格隔开。

## 输出格式

一行，输出没有回到终点的战士编号

## 输入样例

```
10
227 8 3 144 176 60 215 130 253 67
176 8 144 253 60 215 67 130 3
```

## 输出样例

```
227
```

## 数据范围

$0≤id≤2^{32}−1$
$1≤n≤10^5$

## HINT

这么精彩的五一赛怎么能不出现位运算呢。
*Author:资深工具人孟大师*

## 思路

一看到时间空间限制，就要想到直接用异或和来解决这题

# `F` 众志成城

时间限制：300ms  内存限制：65536kb

通过率：25/53 `(47.17%) `  正确率：25/162 `(15.43%)`

## 题目介绍

现在我们可以直观感受一下团结的力量，现在有$a,b,c$三个正整数，他们个人的力量可能是微小的，但是团结起来的力量却很大。你现在可以计算$a^{b^{c}}$的值来进行直观感受，因为团结的力量实在是太大了，因此请输出该数字对$100000007$（是一个质数）取模的结果。

## 输入格式

多组输入，每行三个正整数$a,b,c$

## 输入样例

```
7 4 9
8 9 1
2 6 7
9 1 2
11 1 9
77 8 7
```

## 输出样例

```
95820093
34217721
19401972
9
11
6308007
```

## 数据范围

$a,b,c$均是`int`范围内的正整数

## HINT

$a^{bc}$和$a^{b^{c}}$可不一样哦

了解一下费马小定理，当$p$为一个质数时，$ap−1≡1 (mod p)$

如果TLE请使用更好的求幂方法

*AUTHOR：ZJD*

## 思路

费马小定理+快速幂/扩展欧拉引理+快速幂

# `G` 

时间限制：1000ms  内存限制：65536kb

通过率：19/32 `(59.38%) `  正确率：19/129 `(14.73%)`

## 题目描述

$$
1→2→3→……→n−1→n
$$

我会对这个链进行m次调整，每一次的调整都会是如下**2种指令**之一：

- 指令1 `1 x`，表示**将编号为x从链中删除**，他的前驱和后继直接进行传递；
- 指令2 `2 x y`， 表示**将编号为y插入到编号为x后面**，即x向y传递，y向x原来的后继传递。（**保证x在链且y不在链中**）

所有的指令保证合法，且不存在当前链人数小于2人的情况。

现在请你输出经过m次调整之后的链。

## 输入格式

输入共$m+1$行.

第$1$行，两个正整数$n,m$，含义如题面所示。

第$2$到$m+1$行，每行为一个指令，具体如下： - 指令1 `1 x` - 指令2 `2 x y`

指令的含义如题面所示，保证$1≤x,y≤n$，且当前操作合法。

## 输出格式

一行，表示最终的链，每两个数用**一个空格**分开。

## 输入样例

```
5 5
1 2
1 3
1 4
2 1 4
2 5 3
```

## 输出样例

```
1 4 5 3
```

## 数据范围

对于$40\%$的数据：$1≤n,m≤1000$.

对于$100\%$的数据：$1≤n,m≤10^6.$

## HINT

练一下链表嗷。

注意一下xx为表头和表尾的情况。

*Author: JJJ.*

## 思路

C语言模拟双向链表

# `H` 

时间限制：1000ms  内存限制：65536kb

通过率：17/23 `(73.91%) `  正确率：17/58 `(29.31%)`

## 题目介绍

给一`n×n`的字母方阵，内可能蕴含多个“`communism`”单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着 8 个方向的任一方向，同一单词摆放时不再改变方向（即不会出现两个单词共用一个`c`），单词与单词之间可以交叉,因此有可能共用字母。输出时，将不是单词的字母用`*`代替，以突出显示单词。

## 输入格式

第一行输入一个数`n`。$(9≤n≤100)$。

第二行开始输入$n×n$的字母矩阵。

## 输出格式

突出显示单词的$n×n$矩阵。

## 输入样例

```
10
tcommunism
mcfmujakes
snokkzmwzs
ialmnnahqs
nxpmmfbmyo
upohfuzwkb
mvjbarnmsr
mzwdefvizo
olsrzbddsa
clventzhum
```

## 输出样例

```
*communism
mc********
s*o*******
i**m******
n***m*****
u****u****
m*****n***
m******i**
o*******s*
c********m
```

*AUTHOR：LJF*

# `I` 

时间限制：1000ms  内存限制：65536kb

通过率：14/33 `(42.42%) `  正确率：14/110 `(12.73%)`

## 题目介绍

在坐标系上有无数条平行的，间隔为 $L$ 的平行直线。有一个边长为 $l$ 的等边三角形，随手一挥，三角形便会落在坐标系中，请问三角形和任意直线相交的概率是多少。可以认为三角形落地时的角度和位置随机(均匀)。聪明而睿智的你必然会算出来。

## 输入

第一行一个正整数 $n$ ，为数据组数

接下来 $n$ 行，每行 $2$ 个用空格分开的整数 $L,l$

## 输出

对于每组数据，输出一行一个浮点数，表示答案，四舍五入保留到小数点后 $6$ 位。

## 输入样例

```
2
2 1
2 3
```

## 输出样例

```
0.477465
1.000000
```

## 数据范围

$1≤n≤10^4$

$1≤L,l≤100$

数据不保证 $l≤L$

## HINT

如果你得了0.2，只能说明你的程序在部分情况下是正确的

*题面来源于HugeGun学姐*

*Author：cbd*

## 思路

$l\le L$ 时，直接套入Buffon抛针问题的公式即可。

那么如果 $l \ge \cfrac{2}{\sqrt3}L $ 那无论如何都会有交点

主要就是 $L\le l \le \cfrac{2}{\sqrt3}L$  这段需要好好讨论一下

假设这些直线都平行于 $ x $ 轴，这个时候概率取决于三角形在 $y$ 轴投影的长度了。

假设其投影长度是 $x$ ，那么相交概率就是
$$
p(x) = \begin{cases}

x/L& L > x\\

1&  L \le x

\end{cases}
$$
**所以关键的积分就是看这个角度，是否转到了 $b =\cfrac{\pi}{2} - \arccos{\cfrac{L}{l}} = \arcsin\cfrac{L}{l}  $    **

当 $L\ge l$ 的时候直接把b当做 $\cfrac{\pi}{2}$ 就行了

所以答案为
$$
ans = \cfrac{6}{\pi}\int_0^{{\pi}/{6}} p(l\sin(\theta+\pi/3))d\theta = \cfrac{6}{\pi}(\int_{{\pi}/{3}}^b\cfrac{l\sin\theta}{L}d\theta+\int_{b}^{\pi/2}1d\theta)\quad(b=\arcsin\cfrac{L}{l} )\\
=\cfrac{6}{\pi}(-\frac{l}{L}\cos\theta|^{\arcsin\frac{L}{l}}_{{\pi}/{3}} + (\frac{\pi}{2}-\arcsin\cfrac{L}{l}))
$$

# `J` 加密通话

时间限制：1000ms  内存限制：65536kb

通过率：3/8 `(37.50%) `  正确率：3/82 `(3.66%)`

## 题目背景

维吉尼亚密码是一种经典的加密的方式。维吉尼亚密码对明文进行加密需要密钥和密码表（大小为$26×26$）。

举例说明：

在本次加密中，密码表如下图**绿色**方框部分所示：

（图中第一行和第一列是密码表隐含的的**行列标识**，例如密码表的第`W`行第`F`列的字母是`B`）

![img](https://s1.ax1x.com/2020/05/25/t98PpR.png)

```
明文为 WaiBiWaiBi
密钥为 Fei
```

先将密钥本身进行重复，直至长度和明文相同，结果如下：

```
明文为 WaiBi WaiBi
密钥为 FeiFe iFeiF
```

接下来对于明文的第ii个字母，确定到密码表中这个字母对应的**行**；对于密钥的第$i$个字母，确定到密码表中这个字母对应的**列**。行列相交处的字母，就是密文的第ii个字母。（加密后字母的大小写保持不变，且空格不参与加密）

密文的第一个字母`B`的得出在图中已经形象的说明了，选取第`W`行第`F`列的字母`B`。

明文加密完毕的结果为：`BeqGm EfmJn` 。

那么维吉尼亚密码的密码表是如何得来的呢？本次加密使用的密码表实际上是经典的维吉尼亚密码表。但可以注意到，在这种加密方式下，只要密码表的**每一列中的字母都互不相同**，那么在密钥确定的情况下，明文和密文是一一对应的。因此在本题中，每一列中的字母都互不相同的密码表就认为是合法的。

## 题目介绍

给予加密所用的**密钥**以及**明文**，以及经过加密后得到的**密文**。如果加密的方法和题目背景所述的相同，请你求出加密所用的**密码表**。注意：

- 正确的加密方法同题目背景所述；
- 密钥只包含大小写英文字母；
- 明文和密文中包含大小写英文字母和空格，加密后字母的大小写保持不变，且空格不参与加密（应在密文中原样输出空格）。

## 输入格式

多组数据输入。

对于每组数据：

第一行是字符串，代表密钥，长度不超过 $10^3$ ；

第二行是字符串，代表明文。长度不超过 $10^5$ ；

第二行是字符串，代表密文。长度不超过 $10^5$ 。

## 输出格式

对于每组数据：

- 若无法正确得到密码表，输出一行字符串：`ARE YOU GOOD MALAYS1A?` ；
- 若能够得到正确的密码表，输出 $26$ 行，每行 $26$ 个字符，代表密码表。约定密码表隐含的**行列标识**和题目背景中描述得一样。对于密码表中可以确定的位置，输出该位置上应该填入的**大写字母**；对于密码表中不能确定位置，在这个位置上输出一个单引号 `'` 。
- 之后输出一行空行

## 输入样例

```
FEI
Wai Bi Wai Bi
Beq Gm Efm Jn
FEI
Wai Bi Wai Bi
Bmq Gm Efm Jn
```

## 输出样例

```
''''EF''''''''''''''''''''
'''''G''J'''''''''''''''''
''''''''''''''''''''''''''
''''''''''''''''''''''''''
''''''''''''''''''''''''''
''''''''''''''''''''''''''
''''''''''''''''''''''''''
''''''''''''''''''''''''''
''''MN''Q'''''''''''''''''
''''''''''''''''''''''''''
''''''''''''''''''''''''''
''''''''''''''''''''''''''
''''''''''''''''''''''''''
''''''''''''''''''''''''''
''''''''''''''''''''''''''
''''''''''''''''''''''''''
''''''''''''''''''''''''''
''''''''''''''''''''''''''
''''''''''''''''''''''''''
''''''''''''''''''''''''''
''''''''''''''''''''''''''
''''''''''''''''''''''''''
'''''B''E'''''''''''''''''
''''''''''''''''''''''''''
''''''''''''''''''''''''''
''''''''''''''''''''''''''

ARE YOU GOOD MALAYS1A?
```

*Author: Lucien Li*

## 思路

坑点较多，需要根据题意进行模拟。注意以下几点：

- 空格可能错位，我们需要直接忽略空格的干扰
- `isalpha`函数的返回值并非**非0即1**！这一点需要注意
- 如果去掉了所有的空格，他俩并不一样长，则直接判断是错误的
- 去掉空格干扰一一比对时，还需要观察空格是否对齐/大小写是否对齐
- 最后比较的时候，只需要密码表的列不重复就行，行重复无所谓

# `K` 五子棋大师

时间限制：1000ms  内存限制：65536kb

通过率：6/12 `(50.00%) `  正确率：6/48 `(12.50%)`

## 题目介绍

小x是一名五子棋小师。今天他遇到了五子棋大师`ziyer`，两人开始切磋棋艺。

请你当裁判，看看是否有人已经连成四子，并马上将要赢了。

具体来说，即：同一颜色的棋子在同一条横行、纵列或斜线上连成 $4$ 个棋子，且该 $4$ 个棋子的两端**至少有一端**为空位置。**不需要考虑先后手，当前执棋人是谁的问题。**（**不需要**考虑两端各 $3$ 个棋子组成双十字等其他复杂的情况，**只需要考虑这一种情况即可**）

## 输入格式

每一组数据为一个 $19×19$ 的数组，代表棋盘。

其中，棋盘上若是 $0$ 则代表此处未落子，是 $1$ 则代表黑子，是 $2$ 则代表白子。

**每个测试点有不定组数据，请用`EOF`判结束。**

## 输出格式

对于每组数据：

如果有人将要获胜： 第一行，一个数字（为 $1$ 或者 $2$ 的其中一个），如果是 $1$ 则代表黑子即将胜利，是 $2$ 则代表白子即将胜利。

第二行，一个整数，输出棋盘上黑子的个数。

第三行，两个整数，用空格分隔，代表连成4个棋子连线的起始位置的棋子坐标。（棋盘**横行自上往下、纵列自左往右**从 $1$ 开始计数，横行最小的棋子在棋盘上的横行数和纵列数作为连线的起始位置，若在同一行上，则纵列数最小的棋子位置作为起始位置）

如果没有人将要获胜： 输出`NO`。

**每组数据之间的输出用一个空行分隔。**

## 输入样例

```
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 0 1 1 2 0 0 0 0 0 0 0
0 0 0 0 0 2 1 1 1 1 2 2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 2 1 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 1 0 2 2 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 1 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 2 2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

## 输出样例

```
1
13
9 8

NO
```

## 样例解释

对于第一组数据： 以棋盘的左上角为第 $1$ 行第 $1$ 列，则从第 $9$ 行第 $8$ 列开始，往下共计 $4$ 个连续的黑子在统一纵列上，且该纵列的下方的是空位置。故黑子即将胜利。此时棋盘上黑子的总数为 $13$ 个。

对于第二组数据： 没有任何一方满足即将胜利的条件，故输出`NO`。

## 数据范围

同一颜色的棋子在同一条横行、纵列或斜线上连成的棋子个数**不会超过 $4$ 个**，并且**最多有一人**连成线的棋子个数为 $4$ (即不会出现二人同时满足即将胜利条件的情况，也不会出现一人有两处满足胜利条件的情况)。

## HINT1

在多组输入中，没有找到判断是否有新输入数据的标志性数据（比如说数据规模 $n$ 这样的，这道题的每一组数据只有 $361$ 个数，显然是没有这样的标志性数据的，又不能全都写在`scanf`函数当中进行判断）。

以**“每组数据固定输入 $10$ 个数”为例，**我们有两种完成多组输入的方式：

```
while(!feof(stdin)) {
    int i;
    for(i = 0; i < 10; i++) scanf("%d", &a[i]);
    //do something
}
```

或者

```
while(scanf("%d", &temp) != EOF) {
    a[0] = temp;
    int i;
    for(i = 1; i < 10; i++) scanf("%d", &a[i]);
    //do something
}
```

请同学们将提示中的代码类推到本问题，选择自己喜欢的方式进行书写。

## HINT2

关于如何求解本题，可以写一个函数，以某一棋子为首个棋子，向**[下、右、左下、右下]**四个方向，判断该棋子是否满足**以其为首有四连且至少又一边有空格**。

对于棋盘中的每一个棋子，调用这个函数。

要考虑所有情况呦，小 心 越 界。

*AUTHOR ziyer*

## 思路

模拟判断即可

# `L` 井字棋大师2.0

时间限制：1000ms  内存限制：65536kb

通过率：4/5 `(80.00%) `  正确率：4/8 `(50.00%)`

## 题目介绍

假设井字棋对弈双方棋子的标识符为`X`和`O`，规定`X`方为先手，现给定一个井字棋棋局，若对弈双方**在此棋局之后**均采用**最优策略**行棋，输出该棋局评估函数 e(p)e(p) 的值。

这次的评估函数有了新的定义：

- 如果**经过若干步**后`X`方获胜，则 e(p)=(最终`X`获胜的局面上空格数+1)
- 如果**经过若干步**后`O`方获胜，则 e(p)=−(最终`O`获胜的局面上空格数+1)
- 如果**经过若干步**后双方打平，则 e(p)=0

![井字棋1](https://image.accoding.cn/FiYnpjWLhfHKeoAAKpeRV4AR5Sao)

例如上图的棋局，`X`方已经获胜，同时棋盘上有两个空格，所以评估函数的值为 e(p)=2+1=3

与1.0版不同的是，评估函数不再仅与当前局面有关，而是同时**与最终局面有关**，具体请参照样例解释。

## 输入格式

对于每一组数据，每组数据共四行。

第一行一个正整数 $∈{1,2}$，$1$ 表示轮到`X`方落子，$2$ 表示轮到`O`方落子。（如果对局已经结束也会给出该数据）

接下来三行，为一个 $3×3$ 的数组，代表某个棋局。（保证所给棋局合法）

其中，棋盘上若是 $0$ 则代表此处未落子，是 $1$ 则代表`X`棋，是 $2$ 则代表`O`棋。

**本题有多组数据输入，请用`EOF`判定结束。**

## 输出格式

对于每一组数据，输出棋局评估函数的值。

**每组数据之间的输出用一个空行分隔。**

## 输入样例

```
1
1 1 0
2 2 2
1 0 0

2
1 2 0
0 1 0
0 0 0

1
0 0 0
0 0 0
0 0 0
```

## 输出样例

```
-4

3

0
```

## 样例解释

第一组数据，当前棋局为：

![井字棋2](https://image.accoding.cn/Fl3z0OEceNMSITRdxAmWnM1-3MdS)

对局已经结束，`O`方三子连成一线，$e(p)=−(3+1)=−4$

第二组数据，当前棋局为：

![井字棋3](https://image.accoding.cn/FulJjdBU-yqKWn0XcWmXHsuowfWM)

轮到`O`方落字，若双方在此之后均采取最佳策略，则会达到题目介绍中的局面，$e(p)=3$

第三组数据：

对局未开始，若双方均采取最佳策略行棋，则一定达成平局，$e(p)=0$

## HINT

当你完成这道题后，就可以自己做个井字棋小程序啦！

*Author:WQH*

## 思路

进行minimax对抗搜索+哈希记忆化即可

# `M` we have a city to burn

时间限制：1000ms  内存限制：65536kb

通过率：4/4 `(100.00%) `  正确率：4/7 `(57.14%)`

## 题目简介

五一假期终于到了，dch学长拿出了珍藏多年的2077。在打游戏的时候，他遇到了一个难题，你能帮帮他么？

我们对游戏进行一些简化，有一个$6×6$的代码矩阵，我们首先要从第一行选取代码1，再选取与代码1同列的代码2，再选取与代码2同一行的代码3,再选取与之处于同一列的代码4，...（详见样例解释）
这样就得到了一个`选用的代码序列`。

我们规定，选取代码的上限是$n$个，每个代码只能被选用一次。

如果有一种选取方法可以使`上传所需序列`成为`选用的代码序列`的子串，我们就认为这段`上传所需序列`破解成功了。

现在有一个`代码矩阵`，和$m$个`上传所需序列`，请你找出在规定的选取次数$n$内，最多可以同时满足多少个`上传所需序列`

![img](https://image.accoding.cn/FsCLVg0lxuWEbj7B0nWjRjLvtlld)

## 输入格式

第一行，用空格分开的两个正整数$m,n$
接下来六行，每行六个大写英文字母，表示代码矩阵。
接下了m行，每行一个由大写英文字母组成的`上传所需序列`

## 输出格式

一个整数，表示最多可以同时满足多少个`上传所需序列`

## 输入样例

```
3 5
ABCDAB
CDABCD
ABCDAB
DCBABA
BBAACD
DDBCAA
DCA
BDC
CCC
```

## 输出样例

```
2
```

## 样例解释

前四个依次选择：

第一行第六列的B

第二行第六列的D

第二行第五列的C

第四行第五列的A

即可完成前两个`上传所需序列`

第五个选啥都不会改变结果

## 数据范围

$1≤n≤9$

$1≤m≤9$

$1≤$`上传所需序列`长度$≤n$

`代码矩阵`、`上传所需序列`均由大写英文字母组成

## 思路

直接暴力搜索即可

# `N` 小迷弟的灵光两现

时间限制：300ms  内存限制：4096kb

通过率：6/10 `(60.00%) `  正确率：6/30 `(20.00%)`

## 题目描述

小迷弟这次真的变聪明了！变得和`lnx`一样聪明了（x）。 上次小迷弟找出了不同的数（见小迷弟的灵光一现），让lnx刮目相看，于是这次她带着更困惑的问题来了。

现在有n个数a1,a2,......,an，小迷弟和`lnx`手中每个人都有一个0，在一轮游戏中，每一个回合都由一个人选择这n个数中的一个数和自己手中或者对方手中的数进行**异或**操作，每个数用完之后不能再用，小迷弟先开始自己的回合，然后是`lnx`，小迷弟，`lnx`...以此类推，最后谁手中的数大谁就获胜。

## 输入

第一个数为数据组数t

对于每一组数据，输入第一个数n，接下来n个数，输入题中所述的a1,a2,......,an

## 输出

输出t行，每行一个数，如果小迷弟必胜输出1，平局输出0，`lnx`必胜输出−1−1，一切皆有可能输出`"unknown"`(双引号不输出)。

## 输入样例

```
2
3 2 2 1
1 0
```

## 输出样例

```
1
0
```

## 样例解释

第一组样例中：小迷弟先手拿1给自己，如果lnx拿2给自己异或，小迷弟拿走剩下的2给自己，这样小迷弟是3，lnx手里是2，小迷弟获胜。如果lnx拿2给小迷弟异或，小迷弟也是用剩下的2给lnx，这样小迷弟手里是3，lnx手里是2，小迷弟获胜。无论如何，都是小迷弟获胜，所以输出1。

第二组样例中：只有一个数0，小迷弟给自己还是给lnx都是平局，所以输出0。

## 数据范围

$1≤t≤10$，$1≤n≤2×105$，$0≤ai≤2^{20}$

*AUTHOR：今天是SE被lnx带飞的小迷弟*

## 思路

本题为一个异或博弈找规律的题目

首先所有数进行异或和，那么异或和的最高位1必然是可以攻占的“制高点”

如果对应位为1的数只有一个，那么先手只要拿下这个，就必然胜利了。

如果制高点唯一，则非制高点为奇数的时候同样能赢，偶数时反而会输（因为先手第一发拿制高点,后手就去抢次制高点 反之亦然）

唯一的平局局面，即为异或和为0的时候。

# `O` 五点共圆

时间限制：1000ms  内存限制：65536kb

通过率：3/3 `(100.00%) `  正确率：3/6 `(50.00%)`

## 题目描述

你知道吗？任意一个星形，五个三角形，外接圆交于五点。总有：这五点共圆。

![五点共圆](https://image.accoding.cn/FreuGczq18VxGDl3PLwJY_qieRHX)

那么，试着把这个圆算出来吧！

## 输入

五个坐标，共10个浮点数，分别是五角星五个顶点的坐标。每个坐标的横坐标在前，纵坐标在后。坐标按照顺时针或者逆时针转一圈的方式给出，即假如给出坐标顺序是12345，则星形一笔连线顺序是13524。

## 输出

一个方程，即待求的圆的标准方程，只需要输出一次项与常数项系数即可。系数保留5位小数，系数之间各有一个空格。

例如，假如待求的圆的方程是 $x^2+y^2−x−y−1=0$ ，就需要输出后三项系数 $−1,−1,−1$，并且都要保留 $5$ 位小数。

## 数据范围

每个点横纵坐标的绝对值在 $10$ 之内。输入样例保证构成合法的五角星。

## 输入样例

```
0.0 1.0
0.951056516295153572 0.309016994374947424
0.587785252292473129 -0.809016994374947424
-0.587785252292473129 -0.809016994374947424
-0.951056516295153572 0.309016994374947424
```

## 输出样例

```
0.00000 0.00000 -0.38197
```

## 样例解释

这个样例是正五角星。

## Hint

eps可以取1e-12。

求解过3点的圆可以考虑Cramer's Rule：圆的标准方程是 $x^2+y^2+Dx+Ey+F=0$

假如通过某三点，根据Cramer's Rule，可以解得相应系数：
$$
D=\frac{\left|\begin{array}{l} -({x_1}^2+{y_1}^2) & y_1 & 1 \\ -({x_2}^2+{y_2}^2) & y_2 & 1 \\ -({x_3}^2+{y_3}^2) & y_3 & 1 \end{array}\right|}{\left|\begin{array}{l} x_1 & y_1 & 1 \\ x_2 & y_2 & 1 \\ x_3 & y_3 & 1 \end{array}\right|}
$$
对于两圆的交点，既可以靠解二次方程计算解出，也可以使用韦达定理等巧妙的方法。

注意：四舍五入到0可能会出现-0.00000，那么这个时候应该怎么办？

*Author：助教LCY*

## 思路

计算几何模板题，可以直接计算外接圆，圆与圆之间的交点，以及3点生成一个圆

当然也可以利用HINT的韦达定理完成运算

# `P` ssd做逻辑

时间限制：1000ms  内存限制：65536kb

通过率：4/4 `(100.00%) `  正确率：4/20 `(20.00%)`

## 题目介绍

`ssd`和`cbd`助教一起上了一门课,课内常有逻辑表达式证明的作业,`ssd`学长实在是太菜了,没办法看清楚这些表达式的值,想请你写个程序画出这些表达式对应的真值表,求求你帮帮他。

### 真值表是什么?

对于只能取`真`和`假`的简单命题变元，通过`逻辑连接词`(例如`与`、`或`、`非`)等连接起来的表达式称为命题

表征命题在所有输入可能取值状态下对应的值的表格即为真值表。

例如现在有两个简单命题变元`p`和`q`,通过逻辑连接词$∧$连接为命题$p∧q$,则该命题的真值表即为

| $p$  | $q$  | $p∧q$ |
| :--- | :--- | :---- |
| F    | F    | F     |
| F    | T    | F     |
| T    | F    | F     |
| T    | T    | T     |

- 对于逻辑连接词而言，满足一元逻辑连接词优先于二元运算连接词，二元运算连接词之间优先级相同，但如果存在括号，则括号内的优先级最高
- 命题的同优先级的演算遵循从左到右的规则

## 输入格式

两行输入

第一行为多个字母,由空格隔开,表示这一组数据中的出现的简单变元的字符 **(简单变元字符仅可能为小写字母，保证不会重复)**

第二行为一行逻辑表达式,由第一行中出现过的字符和逻辑连接词组成,**为方便大家表示,本题规定逻辑连接词包括`&`,`|`,`~`,`(`,`)`**

其意义如下

- `&`:与运算
- `|`:或运算
- `~`:非运算
- `(`:左括号
- `)`:右括号

## 输出格式

令输入的简单变元个数为$n$(这个$n$需要大家自己计数)

则总输出为$2n+1$行,每行$n+1$列,列于列之间以`|`隔开,列内容与`|`符号之间留出一个空格

第一行为表头,前$n$列为输入的简单命题变元字符,第$n+1$列为RR,代表`Result`

接下来$n$行，每行代表每种取值可能对应的命题结果,真以**T**表示,假以**F**表示

输入顺序满足命题变元代表的二进制数的升序,以包括四个简单命题变元的命题为例

`FFFF`即`0000`代表`0`,则首先输出,`FFFT`即`0001`代表`1`,第二个输出，依次类推,直到所有情况输出完成

## 输入样例1

```
p q
p&q
```

## 输出样例1

```
| p | q | R |
| F | F | F |
| F | T | F |
| T | F | F |
| T | T | T |
```

## 输入样例2

```
p q r
(((p&~q)|(~p&q))&~r)|(~((p&~q)|(~p&q))&r)
```

## 输出样例2

```
| p | q | r | R |
| F | F | F | F |
| F | F | T | T |
| F | T | F | T |
| F | T | T | F |
| T | F | F | T |
| T | F | T | F |
| T | T | F | F |
| T | T | T | T |
```

## 数据范围

给出的简单命题变元不会超过$10$个

命题中逻辑连接词+命题变元长度不超过$300$个

## HINT

**本题输入末尾存在`'\r'`字符，请想办法消除它的干扰**

用栈可以解决表达式计算的问题

样例2是全加器的本位数真值哦嘻嘻

如果你不知道怎么遍历命题变元的各种取值可能的话，去E2请教一下木木枭学长吧!

*Author:ssd*

## **如果你已经有了完成这一任务的思路，请忽略下面的提示**

下面给出用栈计算包含(`+`,`-`,`*`,`/`)算数表达式的思路

(考虑括号的话要怎么样做呢?)

> 以表达式1+2*3-4/5为例
>
> 首先,我们建立两个栈分别为数字栈与符号栈
>
> 向数字栈中压入第一个数字1
>
> 判断符号栈为空,直接压入一个运算符+
>
> 再向数字栈中压入一个数字,为2
>
> 判断符号栈非空,判断待压字符与栈顶字符的优先级,*优先于+,将*压入字符栈
>
> 向数字栈中压入下一个数字3
>
> 判断符号栈非空，判断待压字符与栈顶字符优先级,-号的优先级低于*，暂缓压栈
>
> 弹出数字栈中顶部两个数字，弹出符号栈中的*号，计算2*3=6，将结果6压入数字栈
>
> 重复判断符号栈非空，判断顶部符号于-的优先级和+号相同，继续暂缓压栈
>
> 弹出数字栈中顶部两个数字1和6,弹出符号栈的+，计算1+6=7，将7压入数字栈
>
> 判断符号栈为空,压入-号
>
> 压入数字4
>
> 判断符号栈非空,判断待压运算符 / 与 - 的优先级, / 的优先级高于 - ,压入 / 号
>
> 向数字栈压入数字5
>
> 此时以及没有待读取的字符了，开始回溯栈中的信息
>
> 判断字符栈非空,弹出两个数字5和4,弹出符号 / 计算4/5=0.8,将0.8压入数字栈.
>
> 判断字符栈非空,弹出数字0.8和7,弹出 - 号,计算 7-0.8-6.2，将6.2压入数字栈
>
> 此时字符堆栈已空，弹出数字栈顶的数字，此时数字栈中唯一的数字即为结果6.2

## 思路

标准的逻辑表达式运算，可以用运算符优先级+栈，自顶向下，递归下降，爬升法等做法。

# `Q` 追寻表达式中的真理

时间限制：1000ms  内存限制：65536kb

通过率：3/4 `(75.00%) `  正确率：3/6 `(50.00%)`

注:为了在一些编程细节上为大家带来简便，我们允许各位选择`C`和`C++`两种编程语言进行提交，可以使用`C++`但并不推荐，用`C`并没有带来更大的麻烦，而且完全可以通过。

## 开头语

有一个问题一直在困扰开花学长。人可以一点点推演，计算出表达式的值。但是机器在没有人脑的各种判断下，也能快速计算出表达式的值。

凡事不能知其然而不知其所以然。抱着追寻真理的热忱之情，开花学长决定与你一起走入美妙的计算机科学的世界当中，一探究竟。看一看计算机到底是怎样一点点分析，最终完成对表达式的计算的。

路漫漫其修远兮，吾将上下而求索。虽然探寻真理的道路艰难坎坷，但是相信走完这趟旅途的你，一定会有全新的收获。

## 背景介绍1--C++结构体中的成员函数

本题需要用到一些`C++语言`的知识，**但是没学过也没有关系，直接看背景介绍就好啦！**

（如果对这里不熟悉的话，**请不要跳过背景介绍**）

在这里，我们将向大家介绍**普通函数调用**，结构体的**成员函数**和**成员函数调用**的概念。

在学习`C语言`的时候，当我们需要计算平方根的时候，我们会采用以下方式:

    double a = sqrt(b);
 调用`math.h`库函数中的`sqrt`函数进行运算，这就是**普通函数调用**。

我们在学习`C语言`结构体的时候，我们可以在结构体内定义**成员变量**

    struct info { 
        int a;
        int b;
        int c;
        int d;
    };
    struct info Information;
但是在`C++`当中，我们还可以在结构体内部定义**成员函数**

    struct info { 
        int a;
        int b;
        int c;
        int d;
        //计算两个数与其他4个成员类型变量的和
        int Calc(int e, int f) {
            return (a+b+c+d+e+f);
        }
    };
    struct info Information;
这样之后，如果我们要计算外部传入的两个数 $a,b$ 和该结构体内部的 $4$ 个数加和的时候，就可以写成以下形式:
    printf("%d\n", Information.Calc(a, b));

这样的写法在`C++`当中是合法的（注意不要将这种写法带入咱们平时的上机练习赛和期末考试当中哦！），这种写法即**成员函数调用**。

值得注意的是，表达式的计算结果**不一定是单纯的数值，也可以是结构体。比如说:**

    struct info { 
        int a;
        int b;
        int c;
        int d;
        //计算两个数与其他4个成员类型变量的和
        int Calc(int e, int f) {
            return (a+b+c+d+e+f);
        }
    };
    //按照某种规则构造一个info结构体
    struct info generate(int a, int b) {
        info ret;
        info.a = a; info.b = b;
        info.c = a + b; info.d = a - b;
        return info;
    }
    int c, d;
    ...
    int main() {
        ...
        printf("%d\n", generate(a, b).Calc(c, d));
        ...
    }

上述的

    generate(a, b).Calc(c, d)
同样也是一个合法的表达式，其中 `generate` 函数就是一个**普通函数调用**，`Calc`函数就是一个**成员函数调用**。

需要注意的是，成员函数的调用是可以进行“套娃”的，因为结构体内可以继续定义**结构体类型的成员变量**，而每一个成员函数的返回值也可以是不同的结构体。例如：

    struct A {
        struct B {
            struct C {
                ...
            }
            struct C calc_C(int b, int c, int d, int e) {
                ...
            }
        }
        struct B calc_B(int a) {
            ...
        }
    };
    struct A test_a;
在上述伪代码块中，`结构体A` 包含成员变量`结构体B`以及成员函数`calc_B`（其返回值为`结构体B`），`结构体B` 又包含成员变量`结构体C`以及成员函数`calc_C`（其返回值为`结构体C`）。

那么
     test_a.calc_B(a).calc_C(b,c,d,e)

同样是一个合法的表达式，其计算的值为一个`结构体C`类型。

## 背景介绍2--C++的函数重载

在`C++`当中，你甚至可以写一堆同名的函数，还有这种好事？还真有。

在同一个作用域内，可以声明几个功能类似的**同名函数**，但是这些同名函数的**形式参数（指参数的个数、类型或者顺序）必须不同**。不能仅通过返回类型的不同来重载函数。

举个例子，比如说`math.h`库当中**求绝对值的函数**包括:

    int abs(int _X);
    long labs(long _X);
    long long llabs(long long _X);
    double fabs(double _X);
    float fabsf(float _X);
    long double fabsl(long double _X);

而且必须要严格按照数据类型选取对应的函数，这就很麻烦了...

但是只要合理利用函数重载，就会轻松不少。

    #include<stdio.h>
    int abs(int x) { return x < 0 ? -x : x; }
    long abs(long x) { return x < 0 ? -x : x; }
    long long abs(long long x) { return x < 0 ? -x : x; }
    double abs(double x) { return x < 0 ? -x : x; }
    float abs(float x) { return x < 0 ? -x : x; }
    long double abs(long double x) { return x < 0 ? -x : x; }
    int main() {
        //do something
    }

这样的话，任何类型的数都可以直接调用名为`abs`的函数，完成绝对值的运算。

不仅可以像上面这样，完成不同参数类型的函数重载，还可以完成**不同参数个数的函数重载。**

    #include<stdio.h>
    void print(int i) {
        printf("一个整数为: %d\n", i);
    }
    
    void print(double  f, double g) {
        printf("两个浮点数为: %f %f\n", f, g);
    }
    
    void print(char c[], char d[], char e[]) {
        printf("三个字符串为 %s %s %s\n", c, d, e);
    }
    int main() {
        //do something
    }

只要传入了上述声明过的任意一种参数组合形式，都可以合理得调用`print`函数。

## 题目要求

一言以蔽之，在本题当中，你需要设法描述一个**类`C++`语法**的表达式的计算过程。

具体来说，你**不需要**求出这个表达式的具体值，你只需要**描述它的计算过程**，即将这个表达式分解为**若干次四则运算与函数调用**，且每次运算或调用的操作数都是**常量**或**之前的运算或调用的结果**。

## 具体的处理内容

这个表达式可能含有：

- 四则运算（加、减、乘、除，不会出现负号）
- 括号
- 函数调用（普通函数调用和成员函数调用）
- 一些常量。

为了简化题目，我们有如下的规定：

- 一个常量、普通函数、成员函数只可能是**一个小写英文字母**
- 在任何一个表达式中，一个字母至多只可能是常量、普通函数、成员函数的**一种**。
- 本题的所有普通函数、成员函数**参数表均不为空，即一定会接受至少 $1$ 个参数**
- 本题不会出现违反下方“定义规则”一栏所说的表达式形式，即不需要进行错误处理。

## 运算的优先级

在四则运算当中，有乘除法>加减法，同优先级从左到右运算的规则，在这里同理有:

- **运算的优先级：`括号`>`普通函数`>`成员函数`>`乘除法`>`加减法` **
- 同优先级的运算遵守从左到右的运算规则
- 注意:`普通函数`与`成员函数`的语法成分中所包含的括号，与计算表达式中的`括号`并非同一性质！

举例如下:

    f(g)

这是一个普通函数调用，但是其中出现的括号仅作为函数的语法表示成分，**并不作为**真正的括号参与到运算当中！

需要注意的是：运算符的优先级**并不代表**计算顺序的先后，在设计程序的时候，你会慢慢理解这一点。

## 简单示例

例如，给定如下的表达式: 

    (a+f((b-c+e)*d/c.h(d,d)).g(e)).g(d).h(f(a,c),f(b)/f(c),f(d))

这就是一个可能出现的表达式。其中：

- `a`,`b`,`c`,`d`,`e` 是常量。
- `f` 是普通函数。
- `g`,`h` 是成员函数。

## 表达式的定义规则

我们用**递归**的方式定义合法的表达式：

- **单独的一个常量**是一个合法的表达式。
- 如果`[EXPR]`是一个合法的表达式，那么`([EXPR])`（嵌套一层**括号**）是一个合法的表达式，其值与`[EXPR]`相同。
- 如果`[EXPR_1]`,`[EXPR_2]`,……,`[EXPR_n]`是 $n$ 个合法的表达式（ **$n$ 至少为 $1$** ），`[FUNC]`是一个**普通函数**，那么`[FUNC]([EXPR_1],[EXPR_2],……,[EXPR_n])`是一个合法的表达式，其值为将`[EXPR_1]`,`[EXPR_2]`,……,`[EXPR_n]`依次作为参数，调用普通函数`[FUNC]`所得的结果。注意**同一个函数在不同的调用中可能接受不同个数的参数**（详情见前面`背景介绍2`中所提到的`函数重载`的概念）。
- 如果`[EXPR]`是一个**由上述三条规则和本条规则或只由本条规则**定义的一个合法的表达式，`[EXPR_1]`,`[EXPR_2]`,……,`[EXPR_n]`是 $n$ 个合法的表达式（** $n$ 至少为 $1$**），`[FUNC]`是一个**成员函数**，那么`[EXPR].[FUNC]([EXPR_1],[EXPR_2],……,[EXPR_n])`是一个合法的表达式，其值为将`[EXPR_1]`,`[EXPR_2]`,……,`[EXPR_n]`依次作为参数，调用`[EXPR]`的**成员函数**`[FUNC]`所得的结果。注意**同一个函数在不同的调用中可能接受不同个数的参数。**（原因和上述规则相同）。
- 如果`[EXPR_0]`,`[EXPR_1]`,……,`[EXPR_n]`是 $n+1$ 个**上述四条规则**定义的合法的表达式（ $n$ 至少为 $1$ ），`[OPR_1]`,`[OPR_2]`,……,`[OPR_n]`是 $n$ 个**乘号或除号运算符**，那么`[EXPR_0][OPR_1][EXPR_1][OPR_2]……[OPR_n][EXPR_n]`是一个合法的表达式，其值为将`[EXPR_0]`,`[EXPR_1]`,……,`[EXPR_n]`依次进行`[OPR_1]`,`[OPR_2]`,……,`[OPR_n]`运算的结果。
- 如果`[EXPR_0]`,`[EXPR_1]`,……,`[EXPR_n]`是 $n+1$ 个**上述五条规则**定义的合法的表达式（ $n$ 至少为 $1$），`[OPR_1]`,`[OPR_2]`,……,`[OPR_n]`是 $n$ 个**加号或减号运算符**，那么`[EXPR_0][OPR_1][EXPR_1][OPR_2]……[OPR_n][EXPR_n]`是一个合法的表达式，其值为将`[EXPR_0]`,`[EXPR_1]`,……,`[EXPR_n]`依次进行`[OPR_1]`,`[OPR_2]`,……,`[OPR_n]`运算的结果。
- **只有符合以上几条定义的表达式才是合法的。**

容易看到，这样定义的每个合法的表达式都有唯一一种解读方式，即不会引起歧义。

## 表达式的求值顺序

上述规定确定了一个表达式的值，接下来我们确定一个表达式的求值顺序。我们用与定义类似的方式规定这个顺序：

- 对于单独的一个**常量**，不需要计算。
- 对于`([EXPR])`（**括号嵌套**），只需计算`[EXPR]`。
- 对于`[FUNC]([EXPR_1],[EXPR_2],……,[EXPR_n])`（**普通函数**），先依次计算`[EXPR_1]`、`[EXPR_2]`、……、`[EXPR_n]`，再调用`[FUNC]`。
- 对于`[EXPR].[FUNC]([EXPR_1],[EXPR_2],……,[EXPR_n])`（**成员函数**），先依次计算`[EXPR]`、`[EXPR_1]`、`[EXPR_2]`、……、`[EXPR_n]`，再调用`[FUNC]`。
- 对于`[EXPR_0][OPR_1][EXPR_1][OPR_2]……[OPR_n][EXPR_n]`（其中`[OPR_1]`、`[OPR_2]`、……、`[OPR_n]`**全为乘除运算符**），先计算`[EXPR_0]`，再计算`[EXPR_1]`，再调用`[OPR_1]`得出中间结果，再计算`[EXPR_2]`，再用上述中间结果和`[EXPR_2]`的结果调用`[OPR_2]`……直到计算完毕。
- 对于`[EXPR_0][OPR_1][EXPR_1][OPR_2]……[OPR_n][EXPR_n]`（其中`[OPR_1]`、`[OPR_2]`、……、`[OPR_n]`**全为加减运算符**），先计算`[EXPR_0]`，再计算`[EXPR_1]`，再调用`[OPR_1]`得出中间结果，再计算`[EXPR_2]`，再用上述中间结果和`[EXPR_2]`的结果调用`[OPR_2]`……直到计算完毕。

可以看出，除函数外，上述运算顺序均与我们日常使用的顺序相同（即**优先级更高的优先计算，同优先级的从左到右依次运算**）；函数的运算顺序在不同的标准中不同，这里我们规定为**函数的参数表从左至右依次运算**。



## 输入格式

输入文件**只有一行**，只包含一个需要处理的表达式。

**表达式的长度不超过 $120$**，不会出现任何空格等多余字符（也就是说，通过`scanf`或者`getchar`即可完成读入）。

## 输出格式


按计算顺序输出每一次的运算符与函数调用。每次调用的参数只能是**常量**或**之前某一次的运算结果**，其中**运算结果**我们用**从小到大的正整数**依次表示。即：我们用单个英文字母（与输入中的相同）表示一个常量（或者普通函数调用/成员函数调用），用一个正整数表示之前某一次的运算结果，设第 $i$ 次的调用产生的结果为 $i$ 。

以下用`[VALUE]`表示一个参数，`[OPR]`表示一个运算符，`[FUNC]`表示一个函数，`[空格]`表示一个单一的空格。

如果是**运算符调用（加减乘除）**，设这次要计算的是`[VALUE_1][OPR][VALUE_2]`，则你需要输出一行`[OPR][空格][VALUE_1][空格][VALUE_2]`。 

如果是**普通函数调用**，设这次要计算的是`[FUNC]([VALUE_1],[VALUE_2],……,[VALUE_n])`，则你需要输出一行`[FUNC][空格][VALUE_1][空格][VALUE_2][空格]……[空格][VALUE_n]`。

如果是**成员函数调用**，设这次要计算的是`[VALUE_0].[FUNC]([VALUE_1],[VALUE_2],……,[VALUE_n])`，则你需要输出一行`[FUNC][空格][VALUE_0][空格][VALUE_1][空格][VALUE_2][空格]……[空格][VALUE_n]`。

值得注意的是，本题的评测方法非SPJ，而是**直接进行文本比对。**因为从题中不难得出，**表达式的调用顺序一定是唯一的。**

## 输入样例1

    (a+b+c)+d+e+f+(a+a+a)

## 输出样例1

    + a b
    + 1 c
    + 2 d
    + 3 e
    + 4 f
    + a a
    + 6 a
    + 5 7	

## 样例解释1

这是一个只包含常量、加减号、括号的表达式，具体的运算顺序在下方的注释中有写到，每一次运算具体计算的是哪个**子表达式**的值

    + a b   // 1 a+b
    + 1 c   // 2 a+b+c
    + 2 d   // 3 (a+b+c)+d
    + 3 e   // 4 (a+b+c)+d+e
    + 4 f   // 5 (a+b+c)+d+e+f
    + a a   // 6 a+a
    + 6 a   // 7 a+a+a
    + 5 7	// 8 (a+b+c)+d+e+f+(a+a+a)

## 输入样例2

    a+b+c+d+e*f*g*h*i*(j-k-l-m-n)

## 输出样例2

    + a b
    + 1 c
    + 2 d
    * e f
    * 4 g
    * 5 h
    * 6 i
    - j k
    - 8 l
    - 9 m
    - 10 n
    * 7 11
    + 3 12

## 样例解释2	

这是一个包含常量、四则运算符、括号的表达式，具体的解释形式同上。

    + a b       // 1   a+b
    + 1 c       // 2   a+b+c
    + 2 d       // 3   a+b+c+d
    * e f       // 4   e*f
    * 4 g       // 5   e*f*g
    * 5 h       // 6   e*f*g*h
    * 6 i       // 7   e*f*g*h*i
    - j k       // 8   j-k
    - 8 l       // 9   j-k-l
    - 9 m       // 10  j-k-l-m
    - 10 n      // 11  j-k-l-m-n
    * 7 11      // 12  e*f*g*h*i*(j-k-l-m-n)
    + 3 12      // 13  a+b+c+d+e*f*g*h*i*(j-k-l-m-n)

## 输入样例3

    (a+f((b-c+e)*d/c.h(d,d)).g(e)).g(d).h(f(a,c),f(b)/f(c),f(d))

## 输出样例3

    - b c
    + 1 e
    * 2 d
    h c d d
    / 3 4
    f 5
    g 6 e
    + a 7
    g 8 d
    f a c
    f b
    f c
    / 11 12
    f d
    h 9 10 13 14

## 样例解释3

这是一个包含常量、四则运算符、普通函数调用、成员函数调用、括号的表达式，具体的解释形式同上。

    - b c         //  1  b-c
    + 1 e         //  2  b-c+e
    * 2 d         //  3  (b-c+e)*d
    h c d d       //  4  c.h(d,d)
    / 3 4         //  5  (b-c+e)*d/c.h(d,d)
    f 5           //  6  f((b-c+e)*d/c.h(d,d))
    g 6 e         //  7  f((b-c+e)*d/c.h(d,d)).g(e)
    + a 7         //  8  a+f((b-c+e)*d/c.h(d,d)).g(e)
    g 8 d         //  9  (a+f((b-c+e)*d/c.h(d,d)).g(e)).g(d)
    f a c         // 10  f(a,c)
    f b           // 11  f(b)
    f c           // 12  f(c)
    / 11 12       // 13  f(b)/f(c)
    f d           // 14  f(d)
    h 9 10 13 14  // 15  (a+f((b-c+e)*d/c.h(d,d)).g(e)).g(d).h(f(a,c),f(b)/f(c),f(d))

## 数据范围

对于其中 $40\%$ 的数据，保证只包含常量与四则运算符、括号中的**至少一种**。

对于其中 $30\%$ 的数据，保证只包含常量与普通函数调用、成员函数调用、括号中的**至少一种**。

对于总计 $100\%$ 的数据，保证为常量、四则运算符、普通函数调用、成员函数调用、括号的**各种可能组合所组成的合法表达式**。

**具体测试点如下:**

测试点 $01, 02$ : 包含常量，加减号

测试点 $03, 04$ : 包含常量，四则运算符

测试点 $05, 06$ : 包含常量，加减号，括号

测试点 $07, 08$ : 包含常量，四则运算符，括号

测试点 $09, 10$ : 包含常量，普通函数调用

测试点 $11, 12$ : 包含常量，成员函数调用

测试点 $13, 14$ : 包含常量，普通函数调用，成员函数调用，括号

测试点 $15, 16$ : 包含常量，四则运算符，普通函数调用，括号

测试点 $17, 18$ : 包含常量，四则运算符，成员函数调用，括号

测试点 $19, 20$ : 包含常量，四则运算符，普通函数调用，成员函数调用，括号

## HINT

如果觉得无从下手，推荐大家采用**自顶向下递归**的方式来完成表达式的解析。

以下是计算一个**只有四则运算+括号**的表达式的具体值的代码，可以在 [表达式求值](https://accoding.cn/problem/303/index) 一题内进行测试并且通过评测。

```c
#include<stdio.h>
#include<string.h>
#include<ctype.h>
char str[114514];
int len;
//获取字符串str[l...r]之间表示的数字
int getnum(int l,int r) {
    int i,ret=0;
    for(i=l;i<=r;i++)
        ret=ret*10+str[i]-'0';
    return ret;
}
//判断字符串str[l...r]之间是否是纯数字
int isnum(int l,int r) {
    int i;
    for(i=l;i<=r;i++)
        if(!isdigit(str[i])) return 0;
    return 1;
}
//判断字符串str[l...r]的最外层括号是否互相配对
int issub(int l,int r) {
    int i,in=0;
    if(str[l]!='('||str[r]!=')')
        return 0;
    for(i=l;i<r;i++) {
        in+=str[i]=='(';
        in-=str[i]==')';
        if(in==0)return 0;
    }
    return 1;
}
//获取str[l...r]当中的关键运算符，以此作为向下递归的依据
int getlst(int L,int R) {
    int i,ret=-1;
    int in=0;
    for (i=R;i>=L;i--) {
        in+=str[i]=='(';
        in-=str[i]==')';
        if(in!=0) continue;
        //优先级 1 : 加减号 (运算顺序是从左向右，所有向下递归是从右往左寻找)
        if(str[i]=='+'||str[i]=='-')
            return i;
        //优先级 2 : 乘除号 (运算顺序是从左向右，所有向下递归是从右往左寻找)
        if((str[i]=='*'||str[i]=='/')&&ret==-1)
            ret=i;
    }
    return ret;
}
//判断字符串str[l...r]组成的表达式的值
int c(int L,int R) {
    if(L>R)
        return 0;
    //如果全是数字，则返回对应表达的数字
    if(isnum(L,R))
        return getnum(L,R);
    //如果最外层括号互相匹配，则去掉最外层括号，只计算内部
    if(issub(L,R))
        return c(L+1,R-1);
    int mid=getlst(L,R);
    //获取关键的运算符，作为向下递归的依据，并分情况枚举递归情况（本代码只有加减乘除）
    if(str[mid]=='+')
        return c(L,mid-1)+c(mid+1,R);
    if(str[mid]=='-')
        return c(L,mid-1)-c(mid+1,R);
    if(str[mid]=='*')
        return c(L,mid-1)*c(mid+1,R);
    if(str[mid]=='/')
        return c(L,mid-1)/c(mid+1,R);
    return 0;
}

int main() {
    while(scanf("%s",str+1) != EOF)
        len=strlen(str+1), printf("%d\n",c(1,len));
}
```

上述的自顶向下递归求值运算方法，**其递归函数`c`的回溯顺序，与本题要求的表达式求值顺序完全相同。**各位同学可以根据上述代码进行改造，完成对本题的计算。

（即使不会完全归纳到普通/成员函数的调用上，仅完成四则运算与括号的部分，也可以得到 $40$ 分的成绩。）

本题除了**自顶向下递归**的分析方法，还可以采用**自底向上递归**的分析方法，感兴趣的同学可以看[这个链接](https://eli.thegreenplace.net/2012/08/02/parsing-expressions-by-precedence-climbing/) ，这里就不再做详细介绍了。

*p.s. 题目参考自THUPOST2016-2*

*Author: 计组OO两开花*

## Solution 1 : 自顶向下分析法

首先关于普通的四则运算中缀表达式，我们知道有很多方法求解，包括中缀表达式+栈(顺便转RPN) 递归下降法(构造可贪心的文法)。虽然递归下降也是一种自顶向下分析法，但是构造出来的语法树并不能代表调用的先后顺序。

**所以我们需要通过文法内部的左递归或者右递归的性质，来进行递归下降分析。** 

采用自顶向下分析求四则运算表达式的写法见上方。

那么在这里同样的，我们人为的根据运算的优先级，优先级越低在调用计算的时候越应该在顶层，所以我们可以得到类似的思路进行判断。

首先构造对应的语法树需要记录的东西

```c++
struct parse_tree_node {
	string content;
	int dfs_time;
	char key_link;
	vector<int> child_index;
	void add_child(int _index);//增加一个儿子结点
	//0代表空节点 如果是false 则需要标号dfs序 表示为非叶子结点
	bool is_leaf();
	//每个非叶子结点的格式化输出
	void print();
};
parse_tree_node memory_pool[maxn];
int node_cnt;//在内存池中开设的节点个数
int root;//语法树根节点的下标
```

然后需要对应的构造语法树的递归代码，在这之前，我们需要如下函数（暂时只给出函数接口）
假设我们输入的字符串变量名是`input`
```c++
int get_plus_or_minus(int l, int r);//是否能在input[l, r]中找到加减符号
int get_multi_or_div(int l, int r);//是否能在input[l, r]中找到乘除符号
int get_member_func(int l, int r);//是否能找到input[l, r]作为成员函数调用的'.'的位置
int is_stadard_func(int l, int r);//input[l, r]是否是普通函数调用
vector<int> get_all_comma(int l, int r);//找到input[l, r]作为普通/成员函数调用，参数表中的所有逗号
```
对应的构造语法树的代码如下:
```c++
int build(int l, int r) {
	if (l > r) return 0;	
	//pre-treat : 去掉所有括号
	while (is_duplicate_bracket(l, r)) l++, r--;

	int node = ++node_cnt, pos = -1;
	
	//特判 priority 5 : 常量
	if (l == r) {
		memory_pool[node].content = input.substr(l, r - 1 + 1);
		memory_pool[node].key_link = input[l];
		return node;
	}

	//priority 1 : 加减符

	pos = get_plus_or_minus(l, r);
	if (pos != -1) {
		memory_pool[node].content = input.substr(l, r - l + 1);
		memory_pool[node].key_link = input[pos];
		memory_pool[node].add_child(build(l, pos - 1));
		memory_pool[node].add_child(build(pos + 1, r));
		return node;
	}

	//priority 2 : 乘除符

	pos = get_multi_or_div(l, r);
	if (pos != -1) {
		memory_pool[node].content = input.substr(l, r - l + 1);
		memory_pool[node].key_link = input[pos];
		memory_pool[node].add_child(build(l, pos - 1));
		memory_pool[node].add_child(build(pos + 1, r));
		return node;
	}

	//priority 3 : 成员函数

	pos = get_member_func(l, r);
	if (pos != -1) {
		memory_pool[node].content = input.substr(l, r - l + 1);
		memory_pool[node].key_link = input[pos + 1];//注意字母在'.'后面
		memory_pool[node].add_child(build(l, pos - 1));
		vector<int> commas = get_all_comma(pos + 3, r - 1);
		commas.push_back(r);
		//if (commas.empty())
			//memory_pool[node].add_child(build(pos + 3, r - 1));
		int start = pos + 3;
		for (int i = 0; i < commas.size(); ++i) {
			memory_pool[node].add_child(build(start, commas[i] - 1));
			start = commas[i] + 1;
		}
		return node;
	}

	//priority 4 : 普通函数

	pos = is_stadard_func(l, r);
	if (pos) {
		memory_pool[node].content = input.substr(l, r - l + 1);
		memory_pool[node].key_link = input[l];
		vector<int> commas = get_all_comma(l + 2, r - 1);
		commas.push_back(r);
		int start = l + 2;
		for (int i = 0; i < commas.size(); ++i) {
			memory_pool[node].add_child(build(start, commas[i] - 1));
			start = commas[i] + 1;
		}
		return node;
	}

	return 0;
}
```
接下来则需要进行后序遍历，来获得每个节点的dfs序，注意只有非叶子结点才能获得dfs序
```c++
//后序遍历dfs序部分
void back_trace(int _index) {
	for (int i = 0; i < memory_pool[_index].child_index.size(); ++i) 
		back_trace(memory_pool[_index].child_index[i]);
	if (!memory_pool[_index].is_leaf())
		memory_pool[_index].dfs_time = ++dfs_cnt, time_table[dfs_cnt] = _index;
};
```
然后根据后序遍历的dfs序，调用print()函数依次输出。

完整代码见自顶向下分析的标程即可。该做法同样可以结合栈来完成(来自lxy同学的做法)。

## Solution 2 : 爬升法

转载自Great Designer的题解分析

我们可以将语法转为：

输入：
全称规则：Expr_all ::= Expr0 | Expr1 | Expr2
函数规则：Function ::= Func ‘(‘ Expr_all { ‘,’ Expr_all } ‘)’
元素规则：Expr0 ::= 常量 { ‘.’ Function } | ‘(‘ Expr_all ‘)’ { ‘.’ Function } | Function { ‘.’ Function }
乘法规则：Expr1 ::= Expr0 | Expr0 ‘*’ Expr1 | Expr0 ‘/’ Expr1
加法规则：Expr2 ::= Expr1 | Expr1 ‘+’ Expr2 | Expr1 ‘-‘ Expr2

优先级：
4：常量与函数
3：括号
2：点运算，左向右
1：乘除法，左向右
0：加减法，左向右

输出：
VALUE ::= 标识符 | 输出行号
加减乘除：一行OPR ‘ ‘ VALUE ‘ ‘ VALUE
函数：一行Func ‘ ‘ VALUE { ‘ ‘ VALUE }
点运算：一行Func ‘ ‘ 左值 ‘ ‘ VALUE { ‘ ‘ VALUE }

以此即可写出类似上一题的爬升法

## Solution 3 : 递归下降法

来自dhy的做法

虽然这题的语法是递归给出的，但是我们也可以由此构造递归下降需要用的BNF范式

```
<EXPR> ::= <TERM> {"+"|"-" <TERM>}
<TERM> ::= <FACTOR> {"*"|"/" <FACTOR>}
<FACTOR> ::= (<NAME> [<FUNC> | <METHOD> {<METHOD>}]) | ("(" <EXPR> ")" {<METHOD>})
<FUNC> ::= "(" <EXPR> {"," <EXPR>} ")"
<METHOD> ::= "." <NAME> <FUNC>
<NAME> ::= [IDENTIFIER]
```




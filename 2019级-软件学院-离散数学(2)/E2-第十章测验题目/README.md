# E2-第十章测验题目

# `A` 虫虫的最短通路

时间限制：1000ms  内存限制：65536kb

通过率：226/236 `(95.76%) `  正确率：226/558 `(40.50%)`

## 题目描述

给定一个带权有向图，试求从顶点 s 到 t 的最短通路 保证输入数据中不存在重边，不存在自环，边权都大于 0 ，注意各数据的范围 本题目仅能使用python语言提交，请不要用其他语言，否则可能在汇总数据的时候视为无效

## 输入

第一行四个由空格隔开的整数 n (顶点个数), m (边数), s (起点), t (终点)组成； 之后的 m 行，每行三个正整数 a, b, c，表示一条从顶点 a 到顶点 b 长度为 c 的边。

## 输出

一共两行 第一行：路径，从源点到终点依次输出所经过得节点；第二行：一个整数，表示从 s 到 t 的最短路长度。数据保证仅一条通路。

## 输入样例

```
8 15 1 8
1 2 5
2 5 6
5 8 5
1 3 2
3 6 3
6 8 9
1 4 3
4 7 1
7 8 11
3 2 1
3 5 7
4 3 6
3 7 1
7 6 3
6 5 1
```

## 输出样例

```
1 3 6 5 8
11
```

## 思路

**dijkstra+最短路径树模板**

**dijkstra跑最短路的同时需要存储最短路径树的边，并从终点回溯遍历到起点，即为起点到终点的最短路径**

# `B` 朱憨憨走在关键通路上

时间限制：1000ms  内存限制：65536kb

通过率：224/229 `(97.82%) `  正确率：224/461 `(48.59%)`

## 题目描述

朱憨憨要去虫虫的工厂打工，工厂给他安排了一个求关键通路的任务。朱憨憨很是苦恼：面对繁杂的工厂流水线，他是真的不知道怎么求，聪明的你能帮帮他吗？

## 输入

第一行是四个由空格隔开的整数 n (节点个数), m (边数), s (源点), t (终点)。此后的 m 行，每行三个正整数 a, b, c, 表示一条从节点 a 到节点 b 的一条长度为 c 的边。（节点个数小于 15 个）

## 输出

第一行输出关键通路的长度；

第二行到第 n+1 行输出每一个顶点的 TE, TL 和缓冲时间；

最后一行按Hint中所给格式，输出**所有**的关键通路。（若有多条，则根据关键通路中节点的个数排序进行输出，长度相同则按字典序排）

## 输入样例

```
9 15 1 9
1 2 3
1 3 2
1 4 4
2 5 4
2 3 0
3 5 4
3 6 4
3 4 2
4 7 5
5 9 6
5 7 3
5 6 0
6 8 3
8 9 1
7 8 1
```

## 输出样例

```
Dis=13
Node 1: TE=   0  TL=   0  TL-TE= 0
Node 2: TE=   3  TL=   3  TL-TE= 0
Node 3: TE=   3  TL=   3  TL-TE= 0
Node 4: TE=   5  TL=   6  TL-TE= 1
Node 5: TE=   7  TL=   7  TL-TE= 0
Node 6: TE=   7  TL=   9  TL-TE= 2
Node 7: TE=  10  TL=  11  TL-TE= 1
Node 8: TE=  11  TL=  12  TL-TE= 1
Node 9: TE=  13  TL=  13  TL-TE= 0
[[1, 2, 5, 9], [1, 2, 3, 5, 9]]
```

## Hint

```
 本题目仅支持Python，想通过默认c语言提交的同学注意了哦。
 得0.66的同学注意当长度相等时的排序问题
```

建立"数组"(其实这里是List列表数据类型)：

```
array = [value]*n
array = [[value for i in range(n)] for j in range(m)] # 二维
```

格式化输出：

```
print("Dis=", distance[end], sep="")
print("Node",i, end="")
print(": TE= %3d" % (te[i]), sep="", end=" ")
print(" TL= %3d" % (tl[i]), sep="", end=" ")
print(" TL-TE= ", tl[i] - te[i], sep="")
```

关键通路输出：

```
print(array)
# 如果你把所有的路径都存在一个List里，可以直接这样print，这里的array为二维的
```

对多条通路进行排序：

```
sorted(all_paths, key = len)
```

## 思路

**关键通路问题，求最长通路**

**具体的TL和TE的计算参考书籍即可，根据正向图与反向图分别进行BFS拓扑排序即可获得**

**具体求关键通路，则直接用dfs即可，结合TE和TL可以判断其是否是关键路径的节点**

**最后注意格式化输出**


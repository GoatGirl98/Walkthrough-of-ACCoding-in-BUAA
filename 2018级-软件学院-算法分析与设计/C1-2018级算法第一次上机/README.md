# C1-2018级算法第一次上机

# pair

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 124 总提交人数: 136

## 题面

c++中有一个非常方便的结构体pair<type,type>

现在我们定义一个合法的，只有pair和int构成的pair如下：

- 当且仅当type为int或者pair<type,type>时，pair<type,type> 合法

例如pair<int,int>和pair<pair<int,int>,int>是一个合法的pair

现在给你多个pair和int字符串，按照给出pair和int的顺序,添加'<' , '>' , ','这三个符号,使得给出的串成为一个合法的pair<type,type>。（如果没有pair，只有一个int，是不合法的）

如果不行，输出Error occurred

## 输入

第一行一个数字 𝑡t 表示数据组数。

每组数据两行，第一行一个数字 𝑛n 表示字符串个数，第二行 𝑛n 个字符串，只会是pair或者int。

## 输出

一行一个字符串

## 输入样例1

```
3
5
pair pair int int int
2
pair int
1
int
```

## 输出样例1

```
pair<pair<int,int>,int>
Error occurred
Error occurred
```

## 数据范围

1≤𝑡≤1001≤t≤100

0≤𝑛≤1000

## 思路

**这题其实是基于编译原理的语法分析出的一个递归调用问题，感觉上来说，只要是正经的做过编译课设，对这些互相调用的递归函数很熟悉了之后，这种题就随便锤了...**

**放在算法里这应该是纯递归问题的集大成者，确实算得上一道很好的题目了**

那么作为相当老练的编译原理课设选手，我们来分析一下这题...

**实际上需要分析的两个语法成分就是pair类型和type类型**

### pair

**首先第一个词得是pair，然后后面需要两个type类型做支撑，具体pair出来的结果是基础的字符串处理了**

### type

**根据题意，int和pair类型都符合type，所以判断如果是int，则返回正确，如果是type，则开始调用type的检测函数，返回其返回值，都不是则错误**

### 最终得到的BNF推导公式

```
<type> ::= "int" | <pair>
<pair> ::= "pair" "<" <type> "," <type> ">"
```

### 需要注意的错误

- **在做语法检测的时候，什么时候下标该往前挪什么时候不该，需要自己对着样例考虑一下**
- **最后别忘了，最外层的parse pair结果正确还不够，必须实打实地跑完n个单词才行**



# Zexal的过河

时间限制: 500 ms 内存限制: 65536 kb

总通过人数: 173 总提交人数: 188

## 题目描述

𝑍𝑒𝑥𝑎𝑙Zexal打算借助河中间的石砖**过到河对岸去**。𝑍𝑒𝑥𝑎𝑙Zexal从**第一块石砖出发**，接下来他可以走到第二块石砖或第三块石砖，有时候走的很不爽，甚至可以直接跨过两个石砖，到达第四块石砖，但是**不能连续两次这种操作**，因为这样消耗体能比较大。现在假设河中含𝑛n块石砖，且这些石砖呈直线分布，请你计算出Zexal**从第一块石砖出发**有多少种**安全**的过河方法。

## 输入

输入将由多组测试数据组成，以**EOF**结尾。

每组数据只有一行，为河中的总石砖数𝑛（0＜𝑛≤50）n（0＜n≤50）。

## 输出

对于每组数据，输出一行，为过河的方法数。

## 输入样例

```
1
2
3
```

## 输出样例

```
1
2
4
```

## 样例解释

1：一步走完；
2：先走到2再走完，或者直接走完；
3：111或12或21或3。

## 思路

**题目复用，搬运自16级算法上机C1-AlvinZH去图书馆**

解法有两种

### Solution 1

**我们首先可以这么想，到达n个点 包括n-1 n-2 n-3，但是实际上n-3是不可以连续走两次的，必须要保证n-3的前一步一定不是跨3个转的，所以实际上状态转移方程就有了**

**dp[n] = dp[n-1] + dp[n-2] + dp[n-4] + dp[n-5]**

### Solution 2

**直接用二维数组来标记是两步以内跨过去的还是三步跨过去的不就得了**

如果设dp(0, n)是两步以内，dp(1, n)是三步

那么很显然有

**dp(0, n) = dp(0, n-1)+dp(1, n-1)+dp(0, n-2)+dp(1, n-2)**

**dp(1, n) = dp(0, n-3)**

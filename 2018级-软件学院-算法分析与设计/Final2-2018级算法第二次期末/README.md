# Final2-2018级算法第二次期末

# 真二分查找

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 372 总提交人数: 393

## 题目描述

输入一个整数n和n个整数，保证这n个整数已经按照从小到大进行排序。

然后输入一个整数q（q≤100000）代表q次查询。接下来q行，每行含有一个整数m，代表一次查询。

对于每次查询，判断m是否在之前输入的n个整数中出现过。如果出现，输出一行"Yes"和其第一次出现的位置(下标从1开始)，否则输出"No"。

## 输入

第一行：一个整数n（𝑛≤100000）。

接下来n行，每行一个整数ai（1≤𝑎𝑖≤10^9）。

接下来一行，一个整数q。

接下来q行，每行输入一个整数x（1≤𝑥≤10^9）。

## 输出

q行字符串

如果出现过，为"Yes "和其第一次出现的位置，中间用空格隔开

否则输出"No"。

## 输入样例

```
5
1
3
4
5
7
3
4
5
0
```

## 输出样例

```
Yes 3
Yes 4
No
```

## 思路

签到题，直接用lower_bound即可

# 跳方格

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 78 总提交人数: 113

## 题目描述

n个方格排成一列，一开始，你在第一个方格，目标为跳到第n个方格。在每个方格i里面你可以做出两个选择:

选择「a」：向前跳ai步。 选择「b」：向前跳bi步。 把每步的选择写成一个关于字符 a 和 b的字符串。求到达方格n的方案中，字典序最小的字符串。当做出某个选择时，你跳出了这n个方格的范围，则这个选择是不合法的。

当没有合法的选择序列时，输出 No solution!。 当字典序最小的字符串无限长时，输出 Infinity!。 否则，输出这个选择字符串。

## 输入

输入有三行。 第一行输入一个整数n(1<=n<=1e5)。 第二行输入n个整数，分别表示ai 。 第三行输入n个整数，分别表示bi 。 (-n<=ai,bi<=n)

## 输出

输出一行字符串表示答案。

## 输入样例

```
7
5 -3 6 5 -5 -1 6
-6 1 4 -2 0 -2 0
```

## 输出样例

```
abbbb
```

## 思路

**图的dfs**

**主要判断的两个corner case就是no solution和infinity**

- 只要从第一个节点到不了n，那很显然就是无解的
- **如果是infinity，而且需要保证是字典序最小的串，那么就是除了最后的终点之外，存在一个序号，通过若干次a操作，即可回到自身，就能保证是无限长的（注意字典序当中 aaaaaab < ab）**

**那么剩下的就是通过dfs判环即可，而且需要加上上述的一些限制，这导致写出来会和原本的判环模板有一些变化**

# 手机靓号

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 45 总提交人数: 67

## 题目描述

人们选择手机号码时都希望号码好记、吉利。比如号码中含有几位相邻的相同数字、不含谐音不吉利的数字等。手机运营商在发行新号码时也会考虑这些因素，从号段中选取含有某些特征的号码单独出售。为了便于前期规划，运营商希望开发一个工具来自动统计号段中满足特征的号码数量。

工具需要检测的号码特征有两个：号码中要出现至少3个相邻的相同数字；号码中不能同时出现8和4 。号码必须同时包含两个特征才满足条件。满足条件的号码例如：13000988721、23333333333、14444101000。而不满足条件的号码例如：1015400080、10010012022。

手机号码一定是11位数，且不含前导的0 。工具接收两个数 L和R ，自动统计出[L,R]区间内所有满足条件的号码数量。 L和R也是11位的手机号码。

## 输入

输入文件内容只有一行，为空格分隔的两个正整数L和R。（1e10<=L<=R<=1e11）

## 输出

输出文件内容只有一行，为一个整数，表示满足条件的手机号数量。

## 输入样例

```
12121284000 12121285550
```

## 输出样例

```
5
```

## 样例解释

```
满足条件的号码有：12121285000、 12121285111、 12121285222、 12121285333、 12121285550。
```

## 思路

**本题是一个数位dp+记忆化搜索的综合问题，思维量并非十分大，但是这需要读者对于数位dp拥有相当丰富的经验，才有可能第一时间做出本题**

**首先设置函数,f(int now, int next, int nextnext, bool strike, bool less_n, bool have4, bool have8)**

**分别表示: 当前位,当前位+1,当前位+2,之前是否有连续3个数,之前是否有x<n,是否出现过4,是否出现过8**

**由于暴力搜索的信息量和重复率较高，所以可以采用对等的数组对已有搜索结果进行记忆**

**于是我们从最高为开始往下搜索**

- **有4有8不合法**
- **如果递归搜索到最低位，且出现过连续的3个数字了，直接返回1，表示这个手机号是靓号**
- **注意当前位是否有最高值的限制，如果没有严格小于,就最高到9,否则就是当前的这个数位**
- **枚举最高位，往下一位进行递归，假设当前位枚举为i，那么下一层的递归应当为**
- - **f(now - 1, i, next, strike || (i == next && i == nextnext), less_n || (i < limit), have4 || (i == 4), have8 || (i == 8))**

- **枚举了所有情况进行加和之后，则返回，此为当前情况下所查找到的靓号数量**

**而求L到R之间的数量，自然就应该想到变成R以内的靓号减去L-1以内的靓号即为所求**

**那么在求的时候具体如下**

- **判断非法情况返回0**
- **首先进行拆位**
- **然后从非0的最高位进行枚举，注意最高位不可以是0，在枚举的时候需要注意最高位限制**
- **因为省去前导0的麻烦，所以从第二高位开始往下搜索，于是顶层为**
- - **f(10, i, 0, 0, i < num[len], i == 4, i == 8);**
  - **其中num是拆完的每一位的数组，i表示当前这个数是多少，范围是1<=i<=num[len]**

然后相减，答案就有了

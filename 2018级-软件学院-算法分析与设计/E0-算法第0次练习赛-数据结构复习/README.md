# E0-算法第0次练习赛-数据结构复习

想当年，也正是因为这场比赛，我认识到了自己和他人的巨大差距，以及能力上的垃圾...也不知道到了现在，我是否也能独当一面了呢？

# `A` 二叉搜索树的和值

时间限制：1000ms  内存限制：65536kb

通过率：60/164 `(36.59%) `  正确率：60/558 `(10.75%)`

## 题目

知识点：二叉搜索树，不是模拟

二叉搜索树是一种特殊的二叉树（每个节点最多只有两个儿子的树）。树的每个节点上存有一个唯一的值，并且满足：这个节点的左子树内所有点的值都比这个节点的值小，且右子树内所有点的值都比这个节点的值要大。

我们定义一棵`二叉搜索树的和值`为当前树的所有节点的深度和（根节点的深度为0）。现在有 N 个数需要插入一棵空树中。给定插入序列，请在每个元素被插入之后，输出当前树的`和值`。

## 输入

第一行为一个整数 n 接下来一行是n个各不相同的数字，这些数字在[1, n]区间。

(0<n<3000000<n<300000)

## 输出

输出 n 行，第 i 行整数表示第 i个数插入树后，`当前树的和值`。

## 输入样例

```
8
3 5 1 6 8 7 2 4
```

## 输出样例

```
0
1
2
4
7
11
13
15
```

## 思路

**首先模拟肯定是不可以的，普通的二叉搜索树在极端情况下会退化成单链，复杂度O(n^2)**

**首先寻找规律，我们假设一个节点在二叉搜索树中序遍历意义下的前驱是pre，后继是succ，那么很显然有**

**dep(x)=1+max(dep(pre(x)),dep(succ(x)))**

**那么由于搜索树的性质，我们需要采用平衡搜索树（支持查询前驱后继排名），任写其一即可，或者直接使用红黑树实现的map类（但是恕我直言，不会还有人不会手写红黑树吧？不会吧不会吧不会吧？）**

**甚至如果你乐意的话，你甚至可以采用VEB树这样一个神棍数据结构，只能专门存放0到n-1这n个元素，支持插入删除查询最大最小是否存在，以及查询前驱后继。可以比平衡树进一步缩短查询的时间，而且这个东西算法导论上也是有的~**

**另一种比较高明的做法是，直接用链表预处理前驱后继，类似于线索二叉树的索引部分。这样的做法是比较难想的，但是也是最快的。**

# `B` Zexal的电影院

时间限制：1000ms  内存限制：65536kb

通过率：73/97 `(75.26%) `  正确率：73/514 `(14.20%)`

## 题目

知识点：优先队列，排序

ZexalZexal的电影院拿到了nn部电影的放映权，每部电影具有两个属性，LL（电影的时长），VV（电影给观众带来的愉悦值）。看KK部电影所带来的愉悦值为KK部电影的时长之和乘以KK部电影中最小的愉悦值。例如，喜欢看一套3部电影，其时长分别为 [5,7,4][5,7,4]和愉悦度分别为 [11,14,6][11,14,6]那么这一套电影所带来的愉悦值为(5+7+4）∗6=96(5+7+4）∗6=96现在电影院计划最多上映kk部不同的电影，那么电影院可以给观众带来的最大愉悦值是多少？

## 输入

第一行包含两个整数nn(1<n<1e51<n<1e5)和KK(1<k<1e31<k<1e3) 其中nn代表电影院所拥有放映权电影的总数，KK代表着可以上映的最大数量。

每个下一个nn行包含两个整数Li和ViLi和Vi（1<Li<1e6,1<Vi<1e61<Li<1e6,1<Vi<1e6)

## 输出

电影院可以带给观众的最大的愉悦值

## 输入样例

```
4 3
4 7
15 1
3 6
6 8
```

## 输出样例

```
78
```

## 样例解释

我们可以选择电影1,3,4，所以最大愉悦值是(4+3+6)∗6=78

## 思路

优先队列，这是一种利用二叉堆实现的结构。具体来说运用于各种需要贪心思想的场合。

首先根据愉悦值和时间对电影排序

接下来类似滑动窗口，保证队列里只留下k个电影，每次默认弹出最小的那个就行



# `C` 连续子序列的权值

时间限制：200ms  内存限制：65536kb

通过率：82/125 `(65.60%) `  正确率：82/553 `(14.83%)`

## 题目

知识点：单调栈

我们定义连续序列a[p],a[p+1]....a[q]a[p],a[p+1]....a[q]的权值为maxmax(a[p],a[p+1]....a[q])(a[p],a[p+1]....a[q])- minmin(a[p],a[p+1]....a[q])(a[p],a[p+1]....a[q])，给定一个由NN个整数组成的序列，请求出所有连续子序列的权值和。

## 输入

第11行：1个数NN，表示数组的长度。(1<=N<=50000)(1<=N<=50000)

第2−N+12−N+1行：每行1个数，表示数组中的元素(1<=A[p]<=50000)(1<=A[p]<=50000)

## 输出

输出所有连续子序列的权值和。

## 输入样例

```
5
1
2
3
4
5
```

## 输出样例

```
20
```

## 思路

首先知道单调栈，其本质就是贪心，可以在O(n)的时间内就同时求出前后第一个比自己大或者比自己小的数

虽然不像RMQ问题打稀疏表那样可以灵活运用，但是在求极大子矩阵等问题起到了关键的作用

那么这道题同样也是，求出来了左右第一个比自己大的数之后，就知道自己在所有子区间极大值占据的区间数是多少了，反过来子区间极小值是自己的个数也就有了，这个就和极大子矩阵的思路是完全类似的，复杂度O(n)

当然了，采用RMQ+分治求解的方法同样是可以的，复杂度是O(nlogn)，倒不如说，在想不到单调栈这种贪心到极致的想法的时候，这个算法其实是非常直接而自然能想到的

# `D` Zexal的拯救世界

时间限制：1000ms  内存限制：65536kb

通过率：111/161 `(68.94%) `  正确率：111/608 `(18.26%)`

## 题目

知识点：并查集

在一条数轴上坐落着NN个国家，分别是1～N1～N。一开始所有的国家都处于黑暗状态。接着ZexalZexal使用MM次魔法，第ii次魔法将会为[Li,Ri]这些国家带来光明。请输出每次魔法使用后仍然处于黑暗状态下的国家数量。

## 输入

输入一行为NN和MM。下面MM行每行两个数Li、RiLi、Ri (1<=Li<=Ri<=N<=200000,1<=M<=200000)(1<=Li<=Ri<=N<=200000,1<=M<=200000)

## 输出

输出MM行，每次魔法使用后仍然处于黑暗状态下的国家数量。

## 输入样例

```
10 3
3 3
5 7
2 8
```

## 输出样例

```
9
6
3
```

## Tips

线段树（×）

并查集（√）

## 思路

本题作为并查集的题目其实并不是比较好的并查集入门题

按秩合并或者路径压缩这两种并查集做法不详细介绍了，请自行学习

那么实际上本题只有两种集合，那么只要把所有拯救的国度合并，在区间上按顺序拯救的时候，每次都只需要找到下一个没拯救的即可

**然而本题作为线段树的基础入门题，确实是非常合适的，这就是很显然的区间赋值问题。**

# `E` Zexal的二叉树（签到）

时间限制：1000ms  内存限制：65536kb

通过率：217/225 `(96.44%) `  正确率：217/654 `(33.18%)`

## 题目

知识点：树，数论，dp，递归（都可以做）

上学期我们学习了二叉树，也都知道3个结点的二叉树有5种， 现给你二叉树的结点个数nn，要你输出不同形态二叉树的种数。

## 输入

第一个数为一个整数n(n<=30)n(n<=30)

## 输出

对于每组数据，输出一行，不同形态二叉树的种数。

## 输入样例

```
3
```

## 输出样例

```
5
```

## 思路

签到题，结论就是卡特兰数

# `F` 多多岛

时间限制：1000ms  内存限制：65536kb

通过率：51/67 `(76.12%) `  正确率：51/207 `(24.64%)`

## 题目

知识点：树，古典概率

多多群岛是一个群岛，由n个岛屿构成，不同的岛屿之间由桥梁连接，一共有n-1个桥梁，任意两个岛屿一定联通。从一座岛屿跨过一座桥梁到另一个岛屿的时间是1。

多多群岛在只有一座桥与其他岛屿相连的岛屿上设有餐厅，就餐时间时，游客会选择距离他最近的餐厅就餐。

假设就餐时间时，一个游客在每座岛屿的概率相等，那么请问他到达餐厅花费时间的期望是多少。

## 输入

第一行一个正整数n表示岛屿的个数(2≤n<1052≤n<105)

接下来n-1行，每行两个整数x，y，表示第x座岛和第y座岛之间有一座桥梁 (1≤x,y≤n1≤x,y≤n)

## 输出

每组数据输出一行，保留4位小数

## 输入样例

```
2
1 2
```

## 输出样例

```
0.0000
```

## 思路

图论水题

只要把所有的岛屿放入队列，进行bfs就完事了

# `G` 生日宴会

时间限制：1000ms  内存限制：65536kb

通过率：72/91 `(79.12%) `  正确率：72/329 `(21.88%)`

## 题目

知识点：拓扑排序，优先队列

贝克兰德的富商道恩.唐泰斯将要举办他的生日宴会，他将要邀请n个客人。现在他面临一个问题，安排客人的到场顺序。

在贝克兰德的社交礼仪中，一场宴会的客人总是一个接一个地到达，也就是说，没有两个客人可以在同一时间到达。到达顺序也有一定的限制，大佬应该在小弟全部到场后再到，丈夫应该在妻子之前入场等等。

满足礼仪的顺序有多种，但是因为不同的客人，道恩对他们的熟悉度程度不同，他想要在满足礼仪的情况下，使得他熟悉的人先到场。

现在，道恩对客人按照熟悉程度进行编号1-n，其中1号他最熟悉。然后客人之间有m个到场顺序限制。现在请你生成一个排序，使得在满足到场限制的条件下，使得1号尽可能早的入场，然后2号，3号……以此类推

## 输入

第一行两个正整数n,m(1≤n≤105,0≤m≤2×1051≤n≤105,0≤m≤2×105)

接下来m行，每行两个整数x，y，表示x应该比y先到 (1≤x,y≤n1≤x,y≤n)

## 输出

一行，n个人的排序，保证有解

## 输入样例

```
3 1
3 1
```

## 输出样例

```
3 1 2 
```

## 输入样例

```
5 6
2 1
5 2
4 1
5 4
3 1
5 3
```

## 输出样例

```
5 2 3 4 1 
```

## 思路

拓扑排序我觉得是没啥太多好说的，但是注意到字典序这种问题其实一般都不好想

一般来说针对字典序的套路就是直接建反向图，表示y比x后道，然后从求出从最晚到最早出场的拓扑排序

最后倒序即为所求

# `H` 魔法阵

时间限制：1000ms  内存限制：65536kb

通过率：42/50 `(84.00%) `  正确率：42/161 `(26.09%)`

## 题目

知识点：最短路

克莱恩在一场冒险中得到了得到了一个破损的魔法阵，这个魔法阵是一个有n个点m条边的有向有环图，任意两点之间最多只有一条边，每条边有一个能量值a（可能是负数，别问问就是magical），不存在负环。

克莱恩试图去修补这个魔法阵。已知，这个魔法阵缺少了3条边，且已经知道这3条边的起点和终点（有向）。对于每条边，克莱恩要赋予其一个能量值c，为了避免邪神出现，修补过程以及结束后也不能出现负环。

请问每次的最小花费是多少(保证有解，可以是负数)。

## 输入

第一行两个正整数n,m(1≤n≤300,n−1≤m≤5001≤n≤300,n−1≤m≤500)

接下来m行，每行三个整数x，y，z，表示x->y有一条权值为z的边 (0≤x,y<n，−1000≤z≤10000≤x,y<n，−1000≤z≤1000)

最后三行，每行两个整数u，v表示需要填补一条u->v的边

## 输出

三行，每行一个整数

## 输入样例

```
10 15
4 7 10
7 6 3
5 3 3
1 4 11
0 6 20
9 8 25
3 0 9
1 2 15
9 0 27
5 2 0
7 3 -5
1 7 21
5 0 1
9 3 16
1 8 4
4 1
0 3
6 9
```

## 输出样例

```
-11
-9
-45
```

## 思路

单源或多源最短路均可

只要求出了从这里到对面的单源最短路，然后答案就是最短路的相反数

**坑点在于，求出这个最短路之后，必须将这条边加入，重新进行计算**

**本题没有特别卡时间，采用SPFA或者floyd都是可以的（在这种情况下johnson显得非常的多余）**

# `I` 治安点

时间限制：300ms  内存限制：65536kb

通过率：33/45 `(73.33%) `  正确率：33/181 `(18.23%)`

## 题目

知识点：最短路，最短路的优化

贝克兰德有n个城镇，这些城镇之间有m条道路连接，每条道路有一个长度l。

zf在其中k个城镇设置了治安点。当一个城镇发生事件时，任意一个治安点都可以派人前往。但是为了节省资源，往往会选择距离最近的治安点。

那么请问，对于每一个城镇，最近的治安点距离为多少。

## 输入

第一行一个整数t表示数据组数(1≤t≤101≤t≤10)

每组数据第一行三个正整数n,m,k (1≤n≤103,n−1≤m≤n∗n/2,1≤k≤n1≤n≤103,n−1≤m≤n∗n/2,1≤k≤n)

第二行k个整数表示治安点所在的位置。

接下来m行，每行三个整数x，y，z，表示x,y之间有一条权值为z的边（无向边） (1≤x,y≤n，1≤z≤100001≤x,y≤n，1≤z≤10000)

## 输出

每组数据一行，n个数

## 输入样例

```
1
4 7 2 
1 4
1 2 7
1 3 2
1 4 6 
2 1 1
2 4 1
3 2 1
3 4 3
```

## 输出样例

```
0 1 2 0
```

## 思路

优化的话比较简单，**类似网络流的建模，建立一个超级源点，把所有的治安点连上他，把多源最短路优化为单源最短路**

**采用SPFA或者Dijkstra都可以，但是众所周知，非负边权最短路的背景中，SPFA已经亡了（bushi**

# `J` 不能和其他题目重名的最小生成树

时间限制：1000ms  内存限制：65536kb

通过率：54/66 `(81.82%) `  正确率：54/203 `(26.60%)`

## 题目

知识点：最小生成树的Kruskal 算法

已知一个完全图唯一的最小生成树（即知道这个树所有边的端点和权值）,其余的边权值未知，问这个完全图所有边权值和的最小值。

完全图是每对顶点之间都恰连有一条边的简单图。

## 输入

第一行一个整数t表示数据组数(1≤t≤101≤t≤10)

每组数据第一行一个正整数n，表示完全图的点数(2≤n≤1052≤n≤105)

接下来n-1行，每行三个整数x，y，z，表示x,y之间有一条权值为z的边（无向边） (1≤x,y≤n，1≤z≤100001≤x,y≤n，1≤z≤10000)

## 输出

每组数据一行一个整数

## 输入样例

```
2
3
1 2 2
1 3 3
4
1 2 3
2 3 4
3 4 5 
```

## 输出样例

```
9
29 
```

## 思路

这题属实有点意思，这需要读者对于Kruskal+并查集的最小生成树的算法有深刻的理解才行

首先对边权进行排序，并且从小到大依次合并两个不连通的点集

那么我们考虑其逆过程，给定了n-1条边指挥，我们先按照边权从小到大排序

然后接下来模拟并查集合并的过程，在合并的时候，**不仅需要记录其对应的父亲，还需要记录对应点集内的点的个数是多少**（题库中一道类似的题在15数据结构，名字为“Z君搬砖”）

**因为保证给定的最小生成树是本图唯一的最小生成树，那么这两个点集的其他的连接边的边权必须比选定的这条边要大。边的个数是两个点集的点个数乘积-1，保证加和最小的话，这些边的边权都是最小生成树边权+1即可**


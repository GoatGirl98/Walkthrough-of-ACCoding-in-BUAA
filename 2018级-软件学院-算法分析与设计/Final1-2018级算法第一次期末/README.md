# Final1-2018级算法第一次期末

# 网络吞吐量

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 21 总提交人数: 39

## 题目描述

路由是指通过计算机网络把信息从源地址传输到目的地址的活动，也是计算机网络设计中的重点和难点。网络中实现路由转发的硬件设备称为路由器。为了使数据包最快的到达目的地，路由器需要选择最优的路径转发数据包。例如在常用的路由算法 OSPF (开放式最短路径优先) 中，路由器会使用经典的 Dijkstra 算法计算**最短路径**，然后尽量沿最短路径转发数据包。

现在，若已知一个计算机网络中各路由器间的连接情况，以及各个路由器的最大吞吐量（即每秒能转发的数据包数量），假设所有数据包一定沿**最短路径**转发，试计算从路由器1到路由器n的网络的最大吞吐量。计算中忽略转发及传输的时间开销，不考虑链路的带宽限制，即认为数据包可以瞬间通过网络。路由器1到路由器n作为起点和终点，自身的吞吐量不用考虑，网络上也不存在将1和n直接相连的链路。

## 输入

输入文件第一行包含两个空格分开的正整数n和m ，分别表示路由器数量和链路的数量。网络中的路由器使用1到 n 编号。

接下来m行，每行包含三个空格分开的正整数 a、 b和 d，表示从路由器 a到路由器 b存在一条距离为 d的双向链路。

接下来 n行，每行包含一个正整数c ，分别给出每一个路由器的吞吐量。 (n<=500、m<=1e5、d,c<=1e9)

## 输出

输出一个整数，为题目所求吞吐量。

## 输入样例

```
7 10
1 2 2
1 5 2
2 4 1
2 3 3
3 7 1
4 5 4
4 3 1
4 6 1
5 6 2
6 7 1
1
100
20
50
20
60
1
```

## 输出样例

```
70
```

## 思路

**相当有意思的计网生成树协议+OSPF背景题目，做法为最短路+最大流**

**首先通过节点1开始跑一次dijkstra，得到所有节点的最短路径，但是注意，在这里不可以像实际当中那样，得到一个最短路径的生成树（因为很显然最短路径树是不唯一的）**

**所以在得到了1到所有节点的距离之后，需要对每条边做判断（无向边拆成两个有向边），对于边<u, v>，只要有dis[u]+w=dis[v]，那么就应该是这个最短路径网络中的边之一，随即加入网络**

**此处需要注意几点**

- **重边和自环需要考虑**
- **在加入网络的时候，关系到后续的网络流建模，不难想象，在这里分析的是有向边，那么加入的也是有向边，反向边的边权必须是0**

**接下来建模的时候，每个点自己的吞吐量上限，这就是网络流传统艺能的拆点了...所以整个图直接拆成二分图就直接ok，然后每个点内部的容量就是吞吐量上限**

**注意审题，1和n不需要考虑吞吐量，所以内部上限就是无穷大**

**最终将源点设为1的前节点，汇点为n的后节点，跑最大流即为所求解**

# 幸运盒

时间限制: 3000 ms 内存限制: 65536 kb

总通过人数: 5 总提交人数: 5

## 题目描述

小明有 n 个幸运盒，每次运转一个盒子的结果要么出现糖果，要么出现芥末。每一轮，小明可以每次选择恰好 𝑘k 个盒子一起运转，每个盒子有 p% 的概率开出糖果，(100−p)% 的概率开出芥末；或者他可以选择这一轮使用法术：选择恰好 t 个盒子，对这些盒子的开出糖果的概率进行调整，使这些盒子分别有 p%，(min(p+1,100))%，……，(min(p+t−1,100))% 的概率获得糖果；当然，他也可以什么都不做，放弃这一轮。

简单来说，就是

一开始有n个盒子，最开始的时候盒子都是空的。

可以进行m次操作，每次操作有三种选择：

1. 什么也不做，此时盒子的状态维持不变
2. 选择k个盒子，清空里面的东西，每个盒子现在有 p% 的概率开出糖果，然后重新开启它们
3. 选择t个盒子，清空里面的东西，每个盒子现在有 p%，(min(p+1,100))%，……，(min(p+t−1,100))% 的概率获得糖果，然后重新开启它们

小明很聪明，每一轮都会选择最优的策略运转这些盒子，包括选择 k 个盒子重新运转，或者选择 t 个盒子使用法术，亦或是放弃这一轮的运转。他可以进行 m 轮操作，在所有操作结束之前他不能拿走盒子里的东西。他想知道 m 轮操作之后，他期望获得多少的糖果。

## 输入

第一行一个整数 T，表示数据组数。

对每组数据，输入一行五个整数：n，m，t，k，p，分别表示盒子的数量 n、运转轮数 m、使用法术需要选择的盒子数量 t、不使用法术需要选择的盒子数量 k，以及 p 表示初始概率 p%。

1≤T≤100,1≤n≤500,1≤m≤500,1≤t≤20,t≤k≤n,1≤p≤100,

对于 T 组数据中 90% 组的数据，1≤n≤50， 1≤m≤50，1≤t≤10。

## 输出

每组测试数据输出一行，一个 5 位小数，表示最佳策略下的期望。

## 输入样例

```
2
500 500 19 300 50
39 42 4 27 86
```

## 输出样例

```
497.89734
39.00000
```

## 思路

**这是一道期望dp的问题，较为综合，需要结合概率dp的相关状态转移来做**

**因为状态转移不能光有一个期望，预处理概率这个过程无论如何是需要的**

**而每次的转移则需要计算法术和旋转所带来的不同情况的概率**



**首先二维数组可以预处理运转k个盒子出现糖的数量i对应的概率 spin(k, i) (法术同理,设为magic,其原理基本是一致的，除了spin的概率全都是一样的，而magic是会变化的，具体就不再赘述了)**

 然后在考虑状态转移的时候，需要考虑每一轮。

 **首先记录有多少个盒子开出了糖果，那么每一轮都可以枚举3种操作，开出了多少糖果**

 **然而不能直接的贪心，所以需要计算具体数值和对应的概率**

 **这一步较为基础，有初始的spin(1, 0)=1-p,spin(1, 1)=p,就不难得到**

- **spin(i, 0) = spin(i-1, 0)\*(1-p)**
- **spin(i, j) = spin(i-1, j)\*(1-p) + spin(i-1, j-1)\*p (j>0)**

**magic也是如出一辙的，但是每一次的概率都不一样，这需要进行一次预处理**



 不是所有的箱子都一定要打开，所以反向推导...

 **假设dp(i,j)是还剩下i轮，而且有j个箱子没有开出糖果时，期望得到的数量**

 **但是需要注意，就算盒子不够了，还是需要尝试两种运转的操作或者啥都不做**

 

 **每次在转移的时候,如果j的数量不小于k或者t的话,直接开箱子就行了**

 假设之前开过 **j-x(0<=x<=k)** 个箱子，那么从剩下i轮到剩下i-1轮，就是选择了k个箱子,开出了x个糖

 **其期望就是∑((dp(i-1,j-x)+x)\*spin(k,x))** 这个转移倒是不稀奇

 

 **如果j的数量小于k或者t的话,那么实际上就需要动到其他的开过的箱子了**

 假设之前开过 **x(0<=x<=k)** 个箱子,那么从剩下i轮到剩下i-1轮，需要选择k个箱子,**没有开过的箱子中开出j-x个**

 **然而其他的糖个数不能动，所以实际上必须开出k-x个糖(也就是重新动的箱子还得有k-j个糖才行)**

 **其期望就是∑((dp(i-1,x)+j-x)\*spin(k,k-x))**



**而magic的转换和上面类似，只要稍微更改变量即可得到**

**每一次的dp转移则是dp(i,j)=max(dp(i-1,j), Pspin, Pmagic),dp(i-1,j)则是本轮空过的最大期望，而另外两个分别是运转和法术的最大期望**

 

 **所以最后的dp(m,n)即为所求**



**本题也是考场上十分罕见的零提交的题目，所以奉劝各位在期末不要企图用dp/贪心的难题还提高名词，这需要做的工作量远比图论计算几何FFT来的大= =**


# C3-2018级算法第三次上机

# Zexal的矩阵链乘

时间限制: 5000 ms 内存限制: 65536 kb

总通过人数: 357 总提交人数: 382

## 题目描述

用加括号的方式给出最优的矩阵相乘方案

## 输入

多组数据输入

第一行一个整数 n，表示矩阵链的长度（1<=n<=300）

接下来一行n+1个数表示这些矩阵的行数和列数

别问我为什么只有n+1个数，每相邻的两个数表示一个矩阵的大小

## 输出

对于每组数据，输出两行，第一行为计算次数，第二行为计算方案，用加括号的方式给出最优的矩阵相乘方案

如果不幸最优方案不唯一，选择优先计算左边的矩阵

## 输入样例

```
3
10 30 5 60
3
10 20 5 4
```

## 输出样例

```
4500
((A1A2)A3)
1200
((A1A2)A3)
```

## Hint

在第二组样例中，选择((A1A2)A3)时，结果为10×20×5+10×5×4=1200

选择A1(A2A3)时，结果为20×5×4 + 10×20×4 = 1200

这时选择第一种，优先计算左边的！

## 思路

**算法导论经典的dp问题，不多说了，如何输出括号则是递归问题，也需要跟着链乘的次数一起做dp**

# Zexal的OBST

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 235 总提交人数: 246

## 题目描述

假设给定一个n个不同关键字的严格升序序列K=<k[1], k[2], …, k[n]>，用这些关键字构造二叉搜索树。对关键字k[i]，有p[i]次被检索到。有些搜索的值可能不在K中，假设n+1个伪关键字D=<d[0], d[1], …, d[n]>，对i=1, 2, ..., n-1，d[i]表示在k[i]和k[i+1]之间的值，d[0]表示小于k[1]的值，d[n]表示大于k[n]的值。对每个伪关键字d[i]，有q[i]次被检索到。请注意这里规定了每个关键字和伪关键字的检索次数。

用上述D序列作叶节点，K序列做内部节点，（可以参考算法导论第三版中文版226-230页，但注意题目定义的不同之处）构造一棵最优二叉搜索树。假设根节点深度为1，给定p, q，求出这二叉搜索棵树的最小总代价。

总代价定义为下面两式之和：

∑𝑖=1𝑛𝑑𝑒𝑝𝑡ℎ(𝑘[𝑖])×𝑝[𝑖]

∑𝑖=0𝑛𝑑𝑒𝑝𝑡ℎ(𝑑[𝑖])×𝑞[𝑖]

## 输入

第一行两个整数n。1≤n≤500

第二行n个整数 p[i]，表示关键字的出现次数。

第三行n+1个整数q[i]，表示i-1关键字与i关键字之间的出现次数。0≤p[i],q[i]≤1000

## 输出

一个整数，表示最小总代价。

## 输入样例

```
5
15 10 5 10 20
5 10 5 5 5 10
```

## 输出样例

```
275
```

## 思路

**也是算法导论的经典问题，不多说了...**


# C1-2017级算法第一次上机

# 比特手链

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 216 总提交人数: 223

## 题目描述

叶姐要想哥赠送一串比特手链，这个手链由0和1组成。想哥买了手链B，无意间得知叶姐想要同样长度的手链A。想哥囊中羞涩，只能手工调整手链。他希望最少通过以下操作进行最少步骤把B变成A。**注意：A != B**

```
对于一个串S：
操作1——选择下标i,j，i != j：
	·result = S[i] & S[j]
	·S[i] = result & S[i]
	·S[j] = result & S[j]


操作2——选择下标i,j，i != j：
	·result = S[i] | S[j]
	·S[i] = result | S[i]
	·S[j] = result | S[j]


操作3——选择下标i,j，i != j：
	·result = S[i] ^ S[j]
	·S[i] = result ^ S[i]
	·S[j] = result ^ S[j]

问想哥最少多少步能达成心愿。如果想哥无法达成心愿，输出-1。
```

## 输入

第一个数为数据组数T

接下来2T行，第2i - 1行为手链B，第2i行为手链A

## 输出

对于每组数据，输出一行，最少的步骤数。特别地，如果无法达成，输出-1。

## 输入样例

```
2
101
010
1111
1010
```

## 输出样例

```
2
-1
```

## Hint

```
T<=5；
长度<=10^6；
```

## 思路

**仔细分析一下，这三种操作是什么意思就明白了**

- **第一种操作在s[i]和s[j]都是1的时候没有任何卵用，其他时候两者都被无条件的置0**

- **第二种操作在s[i]和s[j]都是0的时候没有任何卵用，其他时候两者都被无条件的置1**

- **第三种操作在s[i]和s[j]都是1或者都是0的时候没有任何卵用，其他时候两者都被取反**

那么有了上面的分析之后我们可以看题了，分为两个方面来考虑

- **什么时候本题无解？**

**很显然，如果全0或者全1，那么将没有任何调整到余地，在保证两者不相等的情况下必然无解**

- **有解的情况下如何让本题为最优解?**

**首先计算不一样的位数，A是0B是1有多少位，B是0A是1有多少位，两者取最大值即可**（不难看出，其中两者的最小值可以通过第三种操作解决，剩下的利用第一种或者第二种解决）

**推荐16级C++的一道题叫做"王助教凑七对子"，在考虑最优解的问题上也是类似的思想**

# 芸如的入学测试

时间限制: 1500 ms 内存限制: 65536 kb

总通过人数: 217 总提交人数: 243

## 题目描述

芸如是一位天才科学家，为中国阵营效力。她有着出众的才智，在几年的军旅生活中，芸如研制了许多高科技武器，使得中国军队的武备可以与厄普西隆阵营狡猾的研究成果相抗衡，甚至还可以和整个盟军部队分庭抗礼。

芸如很小的时候就已经开始展现自己的才华，并作为最优秀的幼儿被送往保密培训学校。在她入校的第一天，校长决定亲自考一考这位被外界奉为"天才"的小姑娘。

校长的问题是这样的：

在一个长度为N的数字序列A，有Q组询问，每组询问给定𝑙l和𝑟r：𝑙≤𝑟l≤r，请求出𝐴[𝑙]+𝐴[𝑙+1]+...+𝐴[𝑟]A[l]+A[l+1]+...+A[r]的值。

由于这个结果可能很大，最终的结果要对10007取模（即取余数）。

## 输入

多组数据输入，数据组数不超过10。

第一行是一个数字N，Q，表示序列A中元素的个数和询问组数。（0<𝑁，𝑄≤1𝑒60<N，Q≤1e6）

第二行是N个整数，第i个整数A[i]表示序列A中的第i个元素，保证均为非负整数，且在INT范围内。

接下来Q行，每行是两个用空格分隔的整数l和r（保证l和r不会超出序列A下标的范围，且𝑙≤𝑟l≤r）。

注意序列A的下标从1开始。

## 输出

对于每组数据，每个询问输出一行，为和值。

## 输入样例

```
3 1
1 2 3
1 2
```

## 输出样例

```
3
```

## 特别说明

对20%的数据，𝑁,𝑄≤100N,Q≤100

数据量较大，读入请勿用过慢读入方式。 **该类提示以后上机将不再出现，请大家多总结相关经验**

## 思路

**前缀和，没什么好说的**

读入方式这里的话，前面几届算法都会说scanf is recommended，其实你要自己写快读/光速IO模板也好

# SkyLee的艾露猫

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 200 总提交人数: 208

## 题目描述

众所周知，怪物猎人中的艾露猫是猎人们狩猎时的好伙伴，不仅可以输出，还可以吸引仇恨，甚至还能帮助采集，实在是居家旅行必备之萌物。

艾露猫很可爱，但是寿命只有短短的2020年，艾露猫在出生后22年成年，且成年时每对艾露猫都会在年初产下一对小猫，艾露猫成年1010年后进入老年，老年持续88年后遗憾地去世。

现在SkyLee得到了一对可爱的艾露猫，他希望艾露猫越多越好，这样打起龙来就很轻松了。假设艾露猫很传统，都是一夫一妻制，并且生出的小猫也正好为一对，若现在为第11年年初，那么第𝑛n年SkyLee一共能有多少只可爱的艾露猫呢？

## 输入

第一个数为数据组数𝑇T

接下来𝑇T行，每行11个整数𝑛n(保证艾露猫数量不超过int)

## 输出

对于每组数据，输出一行，为第𝑛n年艾露猫的数量

## 输入样例

```
7
1
2
3
4
5
6
7
```

## 输出样例

```
2
2
4
6
10
16
26
```

## 思路

**斐波那契数列的变种，注意一下死亡的猫对答案的影响。在出现了死亡的猫之后，具体的递推公式到底该怎么计算，这是一个坑点。**

# SkyLee在GameStop

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 158 总提交人数: 165

## 题目描述

SkyLee有一天逛街的时候看到一家新开业的GameStop，里面卖各种各样的游戏。

商店里所有的游戏都按游戏名的字典序从小到大排列好了，小的在里面，大的在外面。

SkyLee想要把所有的游戏都试玩（买不起游戏只能看看），但是有些问题：

1.游戏只能从展示架的一侧拿出来

2.SkyLee只能拿11个游戏试玩

3.为了不被商店老板发现蹊跷，SkyLee把游戏光盘放回去的时候总要保证每个展示架的游戏仍然按照字典序从小到大排列(小的在里面，大的在外面)

4.SkyLee虽然没钱但是不可能偷游戏，离开时不能拿着游戏

5.SkyLee发现了两个空的展示架可以放游戏

SkyLee给摆放有游戏的那个展示架编号11，空的编号22和33。

假设SkyLee拿游戏、放游戏和试玩游戏都需要时间，现在由你来帮SkyLee提出一个最快的把所有游戏都试玩完的方案吧。

在同样快的试玩方案中，SkyLee会第一时间试玩他拿到的新游戏，然后尽量把字典序更小的游戏放在编号大的展示架上。

## 输入

多组数据

每组数据1个数𝑛n表示游戏的数量。

1≤n≤10

## 输出

对于每组数据，输出把所有游戏都试玩完的最快方案，按以下要求： 拿出游戏输出一行get game from board i，其中i是展示架的编号。 放回游戏输出一行put game to board i，其中i是展示架的编号。 试玩游戏输出一行playing。 离开商场输出一行leave。

## 输入样例

```
2
```

## 输出样例

```
get game from board 1
playing
put game to board 2
get game from board 1
playing
put game to board 3
leave
```

## 样例解释

1号展示架上放了两个游戏，字典序从小到大标为A,B。

首先SkyLee拿出B并试玩，然后放回到2号展示架上。

然后SkyLee拿出A并试玩，这样他就把所有的游戏都玩过一遍了。

SkyLee需要在同样快的方案里，把字典序更小的放到编号更大的展示架上。所以他玩完A后放回到3号展示栏上，然后就离开GameStop了。

## 思路

这是一个汉诺塔变种的问题

为了保证字典序最小，需要满足以下条件

n=1时，把第一个游戏挪到3号柱子上就可以了；

n=2时，较大的游戏挪到2，,较小的游戏挪到3即可；

n>2时，把最上面的n-2个游戏挪到2上，然后1–>3,1–>1即可。

# 芸茹的课堂测试

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 19 总提交人数: 20

## 题目描述

霍纳（Horner）规则是一种将一元n次多项式的求值问题转化为n个一次式的算法。采用最小的乘法运算策略，用于求多项式𝐴(𝑥)=𝑎0+𝑎1𝑥+𝑎2𝑥2+...+𝑎𝑛−1𝑥𝑛−1+𝑎𝑛𝑥𝑛A(x)=a0+a1x+a2x2+...+an−1xn−1+anxn在x处的值，转化为𝐴(𝑥)=𝑎0+𝑥(𝑎1+𝑥(𝑎2+...+𝑥(𝑎𝑛−1+𝑥𝑎𝑛)···))A(x)=a0+x(a1+x(a2+...+x(an−1+xan)···))。其伪代码如下：

```
y = 0
for i = n downto 0
    y = ai + x * y
```

给一个8进制数，这个数很大，他的长度甚至可以达到1e6（即10的6次方）。请输出这个数十进制意义下对1e9+7取模（即取余数）的结果。

## 输入

第一个数为数据组数n。n <= 10。

每组数据包括一行，一个大整数S，表示给定的8进制数x。S在字符串意义下长度不超过1e6。

## 输出

对于每组数据，输出一行，为其十进制下对1e9+7取模的值。

## 输入样例

```
2
22
2222222222222222222
```

## 输出样例

```
18
733442737
```

## 思路

霍纳法则
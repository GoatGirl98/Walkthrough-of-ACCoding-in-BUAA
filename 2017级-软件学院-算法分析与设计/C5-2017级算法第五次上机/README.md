# C5-2017级算法第五次上机

# 树形DP初步-二叉树

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 174 总提交人数: 176

## 题目描述

**一道简单的'伪'树形dp。**

**注意题目难度与顺序无关，请自行决策，不要卡在一道题目上太久。**

关于二叉树：

二叉树的递归定义：二叉树要么为空，要么由根结点，左子树，右子树组成。左子树和右子树分别是一棵二叉树。

请注意，有根树和二叉树的三个主要差别：

1. 树的结点个数至少为1，而二叉树的结点个数可以为0；
2. 树中结点的最大度数没有限制，而二叉树结点的最大度数为2；
3. 树的结点无左、右之分，而二叉树的结点有左、右之分。

关于最长链：

最长链为这棵二叉树中一条最长的简单路径，即不经过重复结点的一条路径。可以容易证明，二叉树中最长链的起始、结束结点均为叶子结点。

现给出一棵N(N<=100000)个结点二叉树，问这棵二叉树中最长链的长度为多少，保证了1号结点为二叉树的根。

## 输入

输入第1行为包含了一个正整数N，为这棵二叉树的结点数，结点标号由1至N。

接下来N行，这N行中的第i行包含两个正整数l[i], r[i]，表示了结点i的左儿子与右儿子编号。如果l[i]为0，表示结点i没有左儿子，同样地，如果r[i]为0则表示没有右儿子。

## 输出

输出包括1个正整数，为这棵二叉树的最长链长度。请注意，链长定义为经过的边的个数。

## 输入样例

```
6
2 3
4 5
0 6
0 0
0 0
0 0
```

## 输出样例

```
4
```

## 思路

**本题作为二叉树的特殊形式，其实基本上也就是个软院数据结构上机的水平，直接对二叉树dfs，把求二叉树深度的代码稍微改一下就OK了**

然而本题还有其他的方法

**如果当做一棵通用的普通树，则可以利用邓俊辉《数据结构》第6章介绍的算法，跑两次dfs，第一次从任意一个点dfs到最远的点，再从这个最远的点dfs一遍，其中最远的点就是了**

**如果这个是一个可能具有环形的图，则其做法才真正的接近于树形DP的雏形，通过多路记忆化dfs，分别求出从一个点为起点得到的最长链和次长链，两者相加即为解**

本题解提供前两个解法，最后一种解法参见17级信息大类程设C0的J题“小太阳”

# 树形DP初步-真树

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 170 总提交人数: 173

## 题目描述

新年到了,白兔家族要搞大大的聚会。但是并不是每只白兔都是同一辈分的，于是便有一棵以老白兔为根的家族树。

每只白兔都有它们自己唯一的整数编号（范围在1到N之间），并且对应一个参加聚会所得的开心值。为了使每个参加聚会的白兔都巨开心，老白兔想让每只白兔和他的上一代白兔不会同时参加聚会。

求参加聚会的白兔获得的最大总开心值。

## 输入

输入的第一行是一个整数N，1<= N <= 6000

以下的N行是对应的N个白兔的开心值（开心值是一个从-128到127之间的整数）

接着是白兔的家族树，树的每一行格式如下： 每行输入一对整数L,K。表示第K个白兔是第L个白兔的上一代。 输入以0 0表示结束

## 输出

参加聚会的白兔获得的最大总开心值

## 输入样例

```
7
1
1
1
1
1
1
1
1 3
2 3
6 4
7 4
4 5
3 5
0 0
```

## 输出样例

```
5
```

## 思路

**这题就是一个经典的树形DP入门题了，如果仅仅考虑通过bfs这样dp必然是错误的，因为这并不是一个线性结构，一个节点所有子节点的深度都是不一样的，树形dp的特质之一就是要以整棵树的规模去考虑问题**

所以我们这样来做...

- **假设f(x, 0)表示以x为根的子树，且x不参加聚会的最大快乐值**
- **假设f(x, 1)表示以x为根的子树，且x参加了聚会的最大快乐值**

**所以我们能推出f(x,0)=\sigma \max(f(y,0),f(y,1)) 其中y是x的儿子，即下一代白兔**

**f(x,1)=\sigma(f(y,0))+happy[x]   同样的y是x的儿子**

**然后根据图遍历找到树根，从树根开始做dfs的树形DP即为所求，最终在选择树根和不选择树根选最大解**



# 绝望的超时空步兵

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 11 总提交人数: 19

## 题目描述

超时空步兵的身上有一个可以用来短程传送的装置，但传送的距离是固定的，而且每次传送都要耗费使用者一定的体力值。

现在超时空步兵和大部队走散了，而且他不小心走到了辐射工兵们设下的辐射场里。留给他走出辐射场的时间已经不多了。已知：

- 超时空步兵每秒能奔跑17米。（请不要在意他这比博尔特还快的速度）
- 超时空步兵使用传送装置，可以在一秒向前突进60米。但是要消耗10点体力值。
- 超时空步兵在原地不动，每秒钟可以恢复4点体力值。
- 超时空步兵每秒钟能恢复1点体力值。（即使选择休息或者传送，也并不影响这1点体力的恢复）

现在已知超时空步兵的初始体力值M，他所在的初始位置和安全位置之间的距离S，他走出辐射场的安全时间T，请计算如何在最短的时间内跑到安全位置。如果不能跑到，则输出在时间T内超时空步兵能移动的最远距离。

为了简化问题，超时空步兵的奔跑、传送和休息均以秒为单位，且每次活动持续的时间为整数秒。（不能做出诸如休息0.5秒这样的行为）

## 输入

多组输入数据

每组数据一行，为用空格隔开的三个非负整数M，S，T

1 <= T <= 10000， 0 <= M<=100， 1 <=S <= 10^6

## 输出

对于每组数据，输出：

第1行为字符串“Yes”或“No” ，即超时空步兵是否能逃离辐射场。

第2行包含一个整数，

第一行为“Yes” 时表示超时空步兵跑到安全位置的最短时间

第一行为“No” 时表示超时空步兵能跑的最远距离。

## 输入样例

```
9 77 2
9 94 3
8 94 3
8 60 2
37 1000 28
```

## 输出样例

```
Yes
2
Yes
3
Yes
3
Yes
2
No
754
```

## 思路

很容易写错的贪心类问题

1.走17米的操作越靠前越好 因为可以先获得体力，然后传送可使用的就更多了

2.光走17米还是比传送要慢 1000个17，用时1000，产生1000体力 同样用时1000，等两次传一次，则3秒60米回1点体力 循环一定次数，剩余时间休息，得到的体力比刚才还要多

所以说就是在这两种操作中进行调整

安全时间的上限是10000，以此做搜索即可 也就是先只走17，后面休息 只是要看从哪里开始走得最远，时间最少
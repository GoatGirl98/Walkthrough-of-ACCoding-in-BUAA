# C4-2017级算法第四次上机

# SkyLee的补番计划

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 180 总提交人数: 181

## 题目描述

SkyLee最近想要补一下番，但是学业繁重没有时间全都补完，所以他需要选出一些番来补。

SkyLee想补的番一共有𝑛n部，每部的集数都不同，每集的长度也不同（别和我说标准番剧24分钟，还有剧场版呢orz）并且他对于每部番的喜好程度不同，即看每部番得到的愉悦度不同，现在SkyLee一共有𝑇T分钟来补番，那么他最多能有多愉（xing）悦（fen）呢？

## 输入

多组数据输入

第一行两个整数𝑛n,𝑇T（0<=n<=500，0<=T<=1e5）

接下来𝑛n行，每行三个整数，分别为集数𝑚m，每集时长𝑡t，看每集得到的愉悦度𝑣v（0<m<=1000，0<t<=200，0<=v<=1000）

## 输出

对于每组数据，输出一行，为最大愉悦度

## 输入样例

```
2 10
3 3 4
2 4 5 
```

## 输出样例

```
13
```

## 思路

基础的完全背包模板，不需要单调队列优化也能过

# RMQ问题

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 211 总提交人数: 223

## 题目描述

给定长度为N的序列，M个询问，每次询问两个数字A,B，要求求出属于A到B这段区间内的最大数。

## 输入

一个整数N表示数字的个数,接下来一行为N个数。第三行读入一个M，表示你看完那串数后需要被提问的次数，接下来M行，每行都有两个整数A,B。

## 输出

输出共M行，每行输出一个数。

## 输入样例

```
6 
34 1 8 123 3 2 
4 
1 2 
1 5 
3 4 
2 3 
```

## 输出样例

```
34 
123 
123 
8 
```

## HINT

对40%：𝑁≤6000,𝑀≤500N≤6000,M≤500

对100%： 𝑁≤200000,𝑀≤10000N≤200000,M≤10000,

所有数均在int范围内

## 思路

**经典的Range Maximum Query模型，一共有ST稀疏表和线段树两种做法。**

### 稀疏表Sparse Table

**这个东西本身的用法就是用来对一组静态数据(即元素不会更改的情况下)进行快速的查询，在预处理之后可以到达单次O(1)的查询时间**（无论是区间最值还是区间最大公约数等等的，都可以在静态情况下采用这个做法，后面这个RGQ我没做过，找机会可以做一下）

**具体来说其采用了倍增的思路，提前预处理2^k范围之内的区间数据，这个思想在图论的最近公共祖先LCA当中一样会出现**

设f[i] [j]为**从第i个数开始，连续2^j个数的最大值** 

于是状态转移方程为:**f[i] [j]=max(f[i] [j-1],f[i+2^(j-1)] [j-1]) 首先f[i] [0]就是自己**

然后通过2个单元素的最值获得f[i] [1]，再往后类推 

查询区间为[i] [j]时，该区间长度为j-i+1，所以取k=log2(j-i+1)，然后最大值 **target=max(f[i] [k],f[j-(2^k)+1] [k])** 只需要查表即可，每次O(1) 但是一旦完成建表，则不可改变。如果需要更新的话，则需要使用线段树模型

**本题解当中顺便把区间最值的数组下标给维护出来了，虽然在这题而言显然没有必要**

**预处理O(nlogn) 单次查询O(1)**

### 线段树

**这个我感觉基本不用介绍了，只要会线段树的话，这个就是最最基础的问题了，这个好的一点是支持区间值的各种修改**

**预处理O(nlogn) 单次修改和查询O(logn)**

**两者的空间复杂度都是O(nlogn)，但是常数上显然是下面有优势**



**然而本题的数据处理相当的不负责任，导致线段树做法竟然比稀疏表做法快非常多...**



# 凯恩·血蹄--烽火戏诸侯

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 163 总提交人数: 174

## 题目描述

牛头人酋长为了防御狗头人酋长的进攻，决定从营地到前线一条直线上，修筑一些烽火台来更好地传递消息，他让牛头人考察了许多地点，来决定修筑烽火台的位置。 N只小牛头人带回来了N条考察结果，分别为在距离前线Ai处，若是修烽火台，每修高一米，就要消费Pi 币，同时每修高一米，就使自己被点燃时，在多一单位距离内被看到。当然，只有一个烽火台看到前面有烽火台被点燃时，才会点燃自己而往下传递消息。现在牛头人酋长要从距离前线最近的烽火台，将消息传到距离前线最远的烽火台（这两座烽火台一定要修建），同时呢，也要尽可能少花点钱。 可是麻烦的是，有些小牛头人考察了同一个地点，甚至在同一地点修烽火台他们的价格都可能不同，这使本来就繁多的数据更乱了，于是牛头人酋长找到你，希望你计算出最少花费是多少。

## 输入

第一行一个数N，表示N个修烽火台位置

接下来N行，每行两个整数Ai,Pi,表示距离前线距离和单位高度（或警示范围）造价

## 输出

一个数，即最小造价

## 输入样例

```
6
1 100000
100 1000
20 80000
40 60000
60 40000
80 100000
```

## 输出样例

```
6300000
```

在1处修高度19的烽火台，20处修高度20的烽火台，40处修高度20的烽火台，60处修高度40的烽火台，80处不修烽火台，100处修高度为0的烽火台

对于100%的数据，0<N<=200000,0<=Ai<=100000000,0<=Pi<=200000000

## 思路

**基础的贪心问题，只需要对坐标左右进行排序，从头遍历到尾即可，因为这样的话遇到最小值的概率以及所占用的长度显然是最大的**


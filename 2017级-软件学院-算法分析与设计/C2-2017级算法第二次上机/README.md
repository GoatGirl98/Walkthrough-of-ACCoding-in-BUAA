# C2-2017级算法第二次上机

# W型串

时间限制: 1000 ms 内存限制: 131072 kb

总通过人数: 197 总提交人数: 203

## 题目描述

一个由括号构成的字符串称为W型串（W-string），当且仅当该串可以表示为(A)或(A)(B)的形式，其中A，B是空串或W型串.

例如()、((()))、(())()等是W型串，而()()()、(()(())())等不是W型串. 给出n个由括号构成的非空字符串，判断每个串是否为W型串.

## 输入

第一行为一个正整数n，表示需判断的字符串个数. 接下来n行，每行一个仅由左右括号（ASCII码分别为40和41）构成的非空字符串S.

0 < |S| <= 1000； n <= 100.

## 输出

输出n行，分别对应每个字符串是否为W型串，如果是则输出Yes，否则输出No.

## 输入样例

```
8
(((((())))))
))()(
((((()
(()(()))
((()())(()()))((()())(()()))
(()(())()((())))()
((())(()))((())(()))
(((()()(((()))))))
```

## 输出样例

```
Yes
No
No
Yes
Yes
No
Yes
No
```

## 思路

**递归/分治**

这其实就是一个递归分析错误的题目，只需要判断内部是否是2个以内，且闭合即可

注意在递归的时候，首先确定下两个子串递归的位置，**但是注意，这个递归的轴点不可以是这个串的右边界，这样会形成死循环**

**还需要注意空串是W型串**

# ModricWang's Real QuickSort Query

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 178 总提交人数: 184

## 题目描述

羊瑞大佬说：“现在的年轻人啊，写个快排都能写错，比如那个辣鸡的ModricWang”

ModricWang觉得他说的情况是真的，决定帮自己复习一下快排的写法。

快排的一个基础操作就是划分(𝑝𝑎𝑟𝑡𝑖𝑡𝑖𝑜𝑛)(partition) ，就是将当前的数组分为前后两个部分。

一种较为经典的𝑝𝑎𝑟𝑡𝑖𝑡𝑖𝑜𝑛partition 方法是，将数组中处于中间位置（注意，只和位置有关，和大小无关）的元素作为分隔元素，然后将小于它的元素放到左侧，大于它的元素放到右侧，然后对左右两侧分别进行递归操作。在此题中为了统一，如果数组长度为偶数，取靠后的一个作为分隔元素。

需要注意的是，快排的划分是一种原地划分，而且左右两边的长度是未知的，因此它在操作时采取以下的一种方式：

1. 设数组为𝑎𝑟𝑟[𝑛]arr[n] ，元素从0开始存储
2. 令𝑖=0，𝑗=𝑛−1,𝑚𝑖𝑑=𝑎𝑟𝑟[𝑛/2]i=0，j=n−1,mid=arr[n/2]
3. 如果𝑖≤𝑗i≤j，转到4，否则转到步骤7
4. 如果𝑎𝑟𝑟[𝑖]<𝑚𝑖𝑑,𝑖++arr[i]<mid,i++ ，重复执行直到𝑎𝑟𝑟[𝑖]≥𝑚𝑖𝑑arr[i]≥mid
5. 如果𝑎𝑟𝑟[𝑗]>𝑚𝑖𝑑,𝑗−−arr[j]>mid,j−− ，重复执行直到𝑎𝑟𝑟[𝑗]≤𝑚𝑖𝑑arr[j]≤mid
6. 如果𝑖≤𝑗i≤j, 交换𝑎𝑟𝑟[𝑖]arr[i] 和𝑎𝑟𝑟[𝑗]，𝑖++,𝑗−−arr[j]，i++,j−− , 转到步骤4
7. 退出

进行第一次递归时，数组被分为左右两个部分：[0,𝑖)和[𝑖,𝑛)，其中𝑖就是执行𝑝𝑎𝑟𝑡𝑖𝑡𝑖𝑜𝑛时的𝑖[0,i)和[i,n)，其中i就是执行partition时的i。进行第二层的递归时，数组总共被分为4个部分。现在ModricWang想让你输出第二层递归时从左往右的第二部分的元素。

## 输入

第一个数为数组长度𝑛n ,16≤𝑛≤10616≤n≤106

第二行n个整数，为待排序的元素，保证在int范围内且不重复

## 输出

输出一行，第二层递归时从左往右的第二部分的元素。

数据保证这一部分不为空。

## 输入样例

```
16
10 6 2 7 14 4 1 13 8 15 5 3 9 11 12 16
```

## 输出样例

```
7 6 8
```

## HINT

原数据

```
10 6 2 7 14 4 1 13 8 15 5 3 9 11 12 16
```

第一次递归

```
3 6 2 7 5 4 1 8 / 13 15 14 10 9 11 12 16
```

第二次递归

```
3 1 2 4 5 / 7 6 8 / 9 / 15 14 10 13 11 12 16
```

## 思路

**本题考查的是对于快速排序原理实现的内部原理的理解程度。**

其实快速排序的划分方式有很多，一般常用的，主要是能在相当多极端情况下(例如所有元素都一样)还能保持或者强行修正为O(nlogn)的划分算法。不同划分方式所带来的影响可以在邓俊辉《数据结构》上进行学习。不过这些都是后话了

**本题的正解是，首先按照题目所给的要求写出划分的函数，以及返回轴点，首先以0到n-1划分，本次选出的轴点两边分别划分，即完成了题目所说的“两次递归”**

需要从左往右的第二部分就是，**第二次划分的左侧轴点和第一次划分轴点之间的元素。**

# SkyLee的图书整理

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 195 总提交人数: 202

## 题目描述

SkyLee在图书馆帮忙整理图书，同学们在借阅时都比较随意，导致SkyLee面前有一堆顺序混乱的书。

图书馆管理员要求SkyLee整理出某本书的个数，可是面对这么多的书，SkyLee实在不知道如何下手，聪明的你能帮帮他么？

## 输入

多组数据输入

第一行两个数字，分别为书的总数量𝑛n，查询次数𝑡t

第二行𝑛n个数字，为𝑛n本书的编号

第三行𝑡t个数字，为要查询的书的编号𝑝p

## 输出

对于每组数据，输出一行，为查询的每种书的本数𝑛𝑢𝑚𝑏𝑒𝑟number

## 输入样例

```
5 3
2 2 3 1 3
1 2 3
```

## 输出样例

```
1 2 2
```

## 数据范围

1≤𝑛,𝑡≤100,0001≤n,t≤100,000，number在int范围内。

对于10%的数据, 1≤𝑛,𝑡≤1000

## 思路

**采用二分查找或者哈希存储均可**

# 天秤的烦恼

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 179 总提交人数: 193

## 题目描述

天秤是厄普西隆阵营的实际统治者——尤里大人的掌上明珠。从为数不多的情报上来看，天秤堪称厄普西隆阵营中拥有最强心灵力量的人。然而那些牺牲了多名情报人员换来的情报似乎暗示，出于某些自身的原因，她并不能运用自己的心灵力量去稳定地控制目标。

事实上，天秤的脊柱上被永久固定了一个名为CAS的系统，以防止天秤的心灵力量失控。

CAS由许许多多不同型号的晶体管组成，晶体管的型号越大，代表它的压制作用越大。这些晶体管合并在一起，共同形成了压制天秤力量的无形之手。

天秤想自作主张的拆掉自己身上的CAS，因为这样她就可以去放风筝了。但是有个严肃的问题等着她：CAS的拆除需要一个顺序，当她想拆除一根晶体管的时候，她需要知道这根晶体管的压制力是所有晶体管中第几大的。

## 输入

多组数据输入，第一个数为晶体管的数量n。(n<=1e6)

接下来一行，共计n个整数，为晶体管的压制力x。保证x满足-2^32<=x<=2^32-1，且之间用空格隔开。

最后一行是要拆除的晶体管的压制力。

## 输出

对于每组数据，输出一行，为晶体管的压制力在所有晶体管中为第几大。

## 输入样例

```
6
1 2 2 3 3 4
3
```

## 输出样例

```
2
```

## 思路

**二分查找，直接调用STL即可**

# 女娲加农炮

时间限制: 3000 ms 内存限制: 131072 kb

总通过人数: 190 总提交人数: 196

## 题目描述

（请不要带着科学的视角去看待题干故事，因为这本来就是以游戏为背景的）

女娲加农炮是中国阵营的专属T3战车单位。这种装备了250mm口径核裂变重磅炮的钢铁巨兽是一种极为恐怖的屠戮机器，常常被安置在中国大批机械化部队的最前端，形成一堵坚不可摧、势不可挡的钢铁长城。

表面上女娲加农炮是由东北重工集团研制而成，但事实上，东北重工只进行了方案论证和实车建造，女娲加农炮真正的缔造者，是来自中国的天才科学家芸如。

现在芸如想化核裂变为核聚变，从而让女娲加农炮的火力再上一层楼。已知有N种不同的原子核（这里请忽略自然界原子核的种类上限），第i种原子核的重量为a[i]。

将两种原子核聚合在一起，消耗的能量等于两种原子核的重量之和。在经过n-1次聚合之后，聚合完成。芸如想使整个聚合过程消耗的能量最小，请求出这个最小的能量值。

## 输入

多组数据输入，第一个数为原子核的种类N。（N<=1e6）

接下来N个整数，代表N种原子核的重量。（在int范围内并用空格隔开）

## 输出

对于每组数据，输出一行，为聚合过程能量消耗的最小值。（保证结果在int范围内）

## 输入样例

```
4
1 2 3 4
```

## 输出样例

```
19
```

## 思路

**二叉哈夫曼树的最小权值和，相当经典的问题了**

# 女娲加农炮II

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 181 总提交人数: 185

## 题目描述

（请不要带着科学的视角去看待题干故事，因为这本来就是以游戏为背景的）

女娲加农炮是中国阵营的专属T3战车单位。这种装备了250mm口径核裂变重磅炮的钢铁巨兽是一种极为恐怖的屠戮机器，常常被安置在中国大批机械化部队的最前端，形成一堵坚不可摧、势不可挡的钢铁长城。

表面上女娲加农炮是由东北重工集团研制而成，但事实上，东北重工只进行了方案论证和实车建造，女娲加农炮真正的缔造者，是来自中国的天才科学家芸如。

现在芸如想化核裂变为核聚变，从而让女娲加农炮的火力再上一层楼。已知有N种不同的原子核（这里请忽略自然界原子核的种类上限），第i种原子核的重量为a[i]。

将三种原子核聚合在一起，消耗的能量等于三种原子核的重量之和。在经过多次聚合之后，聚合完成。（如果原子核的数量小于3则不进行进一步的聚合）芸如想使整个聚合过程消耗的能量最小，请求出这个最小的能量值。

## 输入

多组数据输入，第一个数为原子核的种类N。（N<=1e6）

接下来N个整数，代表N种原子核的重量。（在int范围内并用空格隔开）

## 输出

对于每组数据，输出一行，为聚合过程能量消耗的最小值。（保证结果在int范围内）

## 输入样例

```
4
1 2 3 4
```

## 输出样例

```
6
```

## 思路

根据题目给出的思路，**最后只剩下4和6的时候不再需要合并了，把上面的代码改改就行，助教并没有为难大家**

**然而上面这个题和2叉huffman树不同，并不是一个真正的3叉huffman树，如果需要把所有的元素都取完得到最小值的话，首先假设是n个元素和m个huffman树，那么当(n-1)无法整除(m-1)的时候需要补充对应个数的0，使其整除**

**换句话说，如果这题改成了真正的3叉huffman，上述4个元素都要取出来的话，则需要先额外push一个0进去，再做模拟**

# 第k顺序统计量

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 181 总提交人数: 183

## 题目描述

给定3个整数A, B, C, 和数组第一个数a[1]。数组a由如下方式得到。询问a中第k小的数是多少。

```
for(int i = 2; i <= 3000000; ++i)
    a[i] = ((1LL * a[i - 1] * A ^ B) + C) % 1000000007;
```

## 输入

多组组数据，每组数据一行，数据组数不超过7

每行5个整数A, B, C, a[1], k (保证五个数为int范围内正整数且k在3000000范围内)

## 输出

对于每组数据，输出一行，第k小的数。

## 输入样例

```
4 5 6 7 8
```

## 输出样例

```
972
```

## 思路

**根据题目要求先打表，然后调用nth_element即可，如果WA了，考虑一下是否在排名上错开了1位**

# 堆积糖果

时间限制: 2000 ms 内存限制: 204800 kb

总通过人数: 3 总提交人数: 3

## 题目描述

本题作为补充介绍的题目（附加题），大家有兴趣有时间再来研究这道题，如果完成前面所有题目即使没完成这道题目也可以保证满分，即使有800分的人。

昕教留有n*m个抽屉的柜子，𝑛⋆𝑚≤1000000n⋆m≤1000000。昕教的女朋友（莫不是ljh）要往这个柜子里放T次糖果𝑇≤1000000T≤1000000 ，每次会在所有满足 𝑥1≤𝑥≤𝑥2x1≤x≤x2 且 𝑦1≤𝑦≤𝑦2y1≤y≤y2 的抽屉(𝑥,𝑦)(x,y)里放一个k类型的糖果。

但是昕教是一个强迫症患者，他希望每个抽屉只能放他规定类型的糖果。他想知道最后有多少个抽屉不能达到他的希望。

## 输入

每个测试样例一组数据。

第一行输入n, m, T。

接下来n行，每行m个在[1,n×m]范围整数，表示每个抽屉接纳的糖果类型。

接下来T行，每行五个整数x1,y1,x2,y2,k。(1≤𝑥1≤𝑥2≤𝑛,1≤𝑦1≤𝑦2≤𝑚,1≤𝑘≤𝑛∗𝑚1≤x1≤x2≤n,1≤y1≤y2≤m,1≤k≤n∗m)

## 输出

一个整数表示含有不接纳类型的抽屉数量。

## 输入样例

```
2 2 2
1 2
2 3
1 1 2 2 2
2 1 2 1 1
```

## 输出样例

```
3
```

## 提示

1.可以考虑vector存储

2.二维前缀和

3.利用概率知识，可以选择随机化，也可以用其他方式做一个大概率算法。

4.注意优化内存使用常数（保证标程的单测试点时空消耗在题目限制的2/3以内）

## 思路

**首先这题作为C2的附加题，本身就预计在上机当中的过题人数就小于3，所以乍一看没有很好的思路很正常...**

首先思路在于**随机化的概率算法**，这个想不出来就没辙

**如果一个格子没有加入其它糖果，那么加入的糖果编号之和一定是目标糖果编号的倍数（反之则不一定）**

对某个编号的糖果**随机某一个比较大的数，那大概率上不会冲突**（**1+3=2+2这种就不行**）

如果对**所有糖果序号都进行多次随机**，进行上述必要性判断，就可以认为:

**在概率上每个存在非接受序号糖果的格子，都存在一组随机数，使得各自的和并非其接受的对应随机数的倍数**

**也就是说这题完全拼的是概率，大随机数的出错概率很低，多试几次就几乎为0**

**其实随机化的算法并不算少见，随机划分这种和这里的用处不一样，硬要说什么随机化思想和这里类似，那自然还是要说到判断质数的Rabin-Miller算法...**



剩下的二维前缀和就不太多说了就是O(1)查询，子区间求和等要素，**准确的说应该是二维的差分+前缀和更加合适。如果觉得2维的vector太耗时空了，那么在已知xy乘积不大于100w的时候可以进一步进行降维优化**


# C8-士谔书院2017级程设基础训练第八次上机

# `A` 超简单表达式计算

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

给定如下表达式：
$$
aOPbOPc
$$
其中a,b,c为int类型非负数，OP为运算符，OP只能是*或+。

## 输入

多组数据输入。
第一行是输入数据组数T(0<T<20)。
接下T行，每行一个字符串，是对应表达式（保证表达式结果不超过int）。

## 输出

对于每个表达式输出一行，为该表达式的运算结果。

## 输入样例

```
3
2*3+1
3+2+1
2+3*1
```

## 输出样例

```
7
6
5
```

# `B` 双阶乘

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

双阶乘是一个数学概念，用n!!表示。正整数的双阶乘表示不超过这个正整数且与它有相同奇偶性的所有正整数乘积。现在给你一个正整数n，求(n!!)%(107+7)

## 输入

多组数据输入。

第一行是数据组数T(0<T<100)

接下来T行，每行一个整数n(0<n<1000)

## 输出

对于每组数据，输出一行，为其对应的(n!!)%(107+7)。

## 输入样例

```
2
5
2
```

## 输出样例

```
15
2
```



# `C` 最小周长

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

一个矩形的面积为S，已知该矩形的边长都是整数，求所有满足条件的矩形中，周长的最小值。例如：S = 24，那么有{1 24} {2 12} {3 8} {4 6}这4种矩形，其中{4 6}的周长最小，为20。

## 输入

输入1个整数S(1≤S≤109)(1≤S≤109)。

## 输出

输出最小周长。

## 输入样例

```
24
```

## 输出样例

```
20
```

## 思路

**很容易就发现，周长最小必然是最接近正方形的时候，所以从根号n开始往下搜索，第一个能整除面积S的长度即为矩形的其中一边**

# `D` Parallel Sort(伪)

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

每次上机的排名是按照如下规则产生的（xx代表分数，yy代表罚时）：

将nn个数对 (x,y)(x,y) 按照xx从大到小的顺序排序，若有数对xx值相同，则按照yy从小到大的顺序排序。请用一个程序来实现排名。

## 输入

第一行一个整数 n(1≤n≤1000)n(1≤n≤1000)。

第二行到第n+1n+1行，每行两个int型整数，分别为x y。

## 输出

输出n行，为排序后的结果，每行两个整数，分别为x' y'。

## 输入样例

```
4 
1 2 
5 6 
9 0 
5 3
```

## 输出样例

```
9 0
5 3
5 6
1 2
```

## 思路

这就是基础的**双关键字排序问题，在19程设目前的开放题目中，出现过k关键字排序，实际上是一样的**

只要根据要求进行排序即可，快排冒泡排序均可

# `E` debug

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

对于一个字符串，定义如下debug行为：字符串中若先后出现'b'，'u'，'g'字符（不要求彼此相邻），则将这三个字符从字符串中删去。对于长度为n的字符串，从第一个字符开始依次赋予1,2,3...n的权值，若存在多个"bug"时，优先de掉三个字母权值之和最大的"bug"，再de掉权值之和次之的"bug"，以此类推。

请你写出程序，实现如下功能：对给出的字符串，输出de完所有bug之后的结果。

## 输入

输入一行字符串，最大长度为100。

## 输出

输出de完**所有**"bug"之后的结果。

## 输入样例1

```
abcdefghiug
```

## 输出样例1

```
acdefghi
```

## 样例解释

debug过程如下：a **b** cdefghi **ug** → acdefghi（注：此处空格和黑体字仅帮助理解，非实际输出）

## 输入样例2

```
buzubugxgrg
```

## 输出样例1

```
uzgxr
```

## 样例解释

debug过程如下：buzu **b** **u** gxgr **g** → **b** uz**u** gx**g**r → uzgxr（注：此处空格和黑体字仅帮助理解，非实际输出）。

## 思路

字符串处理

每次找出了bug组合之后，直接重新构造新的字符串，直到找不出来了为止

# `F` 动了手脚的Fibonacci

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

在之前的理论课上，我们知道了Fibonacci序列的产生方式，在上机时也用“熊猫序列”更深入地理解了这种形式的序列。下面我们考察一种新的生物序列：假设一对鸽子从出生后的第三个月起具有生育能力，每月繁殖一对小鸽子，第八个月起失去生育能力（1月出生，3月开始生育， 8月失去生育能力），并且鸽子会健康生长不会死亡。下面我们研究由鸽子总对数构成的序列。

## 输入

假设第一个月第一对鸽子刚出生，序列的前几个数字如下：1 1 2 3 5 8... 第一行输入一个整数n 1≤n≤401≤n≤40

## 输出

该序列的第n个数

## 输入样例1

```
6
```

## 输出样例1

```
8
```

## 输入样例2

```
13
```

## 输出样例2

```
195
```

## 思路

斐波那契数列变种

**如果会死亡的话，答案又会是什么呢？**（参见16级c++的期末模拟上机）

# `G` Hanoi Again

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

还是汉诺塔，但是现在的汉诺塔只能在相邻的柱子间移动（A只能移动到B; B只能移动到A或C; C只能移动到B）。在整个移动过程中，任何时候都保证小盘子只能在大盘子上面。
还是给定层数数n，你需要输出把所有盘从A移到C的操作。

## 输入

多组数据输入。

第一行是输入数据组数T(0<T<11)(0<T<11)。

接下来T行，每行一个整数n(0<n<20)，代表层数(盘子个数)。

## 输出

对于每组数据输出其对应的操作，每组数据间用**一个空行隔开**（最后一组数据的空行不会进行评测），具体格式见样例。

## 输入样例

```
2
1
2
```

## 输出样例

```
A -> B
B -> C

A -> B
B -> C
A -> B
C -> B
B -> A
B -> C
A -> B
B -> C
```

## 思路

递归思路较为简单

先把上面n-1个从A以B为媒介挪到C，然后最底下的一个挪到B，然后再把那n-1个从C以B为媒介挪到A，最底下一个挪到C，那n-1个再挪回C即可


# E1-2015级算法练习题

## 注明

**所有重复题目不再予以整理，请读者自行到14级/15级算法课程的上机题中去找**

# `A` jhljx的GC处理

时间限制：500ms  内存限制：10000kb

通过率：/ `(%) `  正确率：/ `(%)`

## Problem Description

大家都知道java有GC垃圾回收机制。一次他在项目中发现了有一个含n字节的连续内存区域可能存在问题，他手中有一种检查软件，软件每次运行可以检查一段连续的内存区间。

由于检查的区间长度越长，要花费的时间就越多，因此他希望能在运行最多m次程序的情况下，每次检查的区间长度最大值最小，且检查的区间的并集包含了所有出现的1。

现给出内存的情况（0表示该字节不需要检查，1表示该字节需要检查），求最小的区间最大值。

## Input

输入多组数据。
每组数据第一行为两个正整数n，m（1<=n<=1000000，m<=n），表示内存总长为n个字节，检查软件运行的次数上限m。
第二行为一个长度为n的01串，表示待检查的内存区域的情况。0表示不需要检查，1表示需要检查。

## Output

对于每组数据，输出一行“Case %: A”，其中%表示第几组数据，A表示该组数据的答案。

## Sample Input

```
7 3
1100101
3 1
101
1 0
1
5 3
00000
5 2
10001
```

## Sample Output

```
Case 1: 2
Case 2: 3
Case 3: 0
Case 4: 0
Case 5: 1
```

## Source

本题改编自百度2017秋招笔试，以后想去BAT的小伙伴要努力学算法了。大型互联网公司必考算法，希望大家认真研究jhljx提供的笔试题，祝好。

## Hint

为防止大家WA和TLE，在样例中又增加了三组样例

## 思路

**首先看题目就知道这题不能暴力查询了，那么显而易见应该想到的做法是二分答案**

在对答案进行二分搜索的时候，只要需要检查的次数不超过上限即为有效，那么我们要找的就是答案的最大值

# `B` 模式查找

时间限制：2500ms  内存限制：5120kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

给你n位同学的学号和GPA（已经按照GPA降序为第一关键字、学号升序为第二关键字排好序），再给k次GPA为y分的查询，查查都有谁的GPA是y分吧~

## 输入

多组测试数据。

每组测试数据第一行为正整数n与k，表示n位同学与k次查询（0<n≤1000000, 0<k≤1000000）；

接下来n行，每行两个数，第一个数为学号（保证在int范围内且没有前导0），第二个数为该同学对应的GPA分数x（0≤x≤4且x保证为**至多保留两位小数**的浮点数），保证所给数据已经按照GPA降序为第一关键字、学号升序为第二关键字排好序；

接下来k行，每行一个浮点数GPA分数y，表示查询谁的GPA为y分，保证0≤y≤4且为**至多保留两位小数**的浮点数。

## 输出

对于每次查询，输出一行，GPA获得y分的同学的学号，按输入顺序输出。

如果没有同学GPA为y分，则输出"No solution!"（不含引号）。

## 输入样例

```
3 5
10061061 4
10061000 3.98
14211140 3.98
4.00
3.98
3.50
3.5
4
```

## 输出样例

```
10061061
10061000 14211140
No solution!
No solution!
10061061
```

## Hint

**数据量很大，请使用scanf/printf进行输入输出。**

**对浮点数进行强制类型转换有较大的误差。**

## 思路

本题卡常，所以在建模上需要进行一定程度的优化

首先GPA保留两位小数，那就知道GPA的可能性最多是401个

在保证了给定顺序是按照GPA降序，再按照学号升序之后，我们就可以逐一对特定的GPA，界定其开始和结束的下标，而不需要开其他的动态数组

# `H` Magry's Sum I

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

废话不多说。

给出n个数组，每个数组有n个元素。从每个数组中取出一个元素相加得到一个Sum值，于是我们有n^n种加法。请找出所有可能的Sum值中最小的n个。

## 输入

多组输入数据，对于每组数据而言：

第一行，一个整数n(不超过700)，表示n个数组，接下来n行，每行n个正整数，代表每个数组中的元素。这些元素的值不超过10000。

## 输出

对于每组数据，输出最小的n个Sum值。

**按从小到大的顺序输出，取所有sum值从小到大排列的前n个数输出即可。**

## 输入样例

```
2
1 1
1 2
```

## 输出样例

```
2 2 
```

## 思路

建议先看下一题，再回来看这一题

有了下一题的基础，对n个子数组，按照顺序两两做k路归并即可

# `I` Magry's Sum II

时间限制：1000ms  内存限制：204800kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

给定两个等长数组A、B，把A、B两个数组各取一个元素相加，总共有n2n2次加法得到的n2n2个结果，求这n2n2个结果的从小到大排好序后的第k个元素。

## 输入

多组输入数据（不超过10组），以EOF结尾。

第一行为两个数，第一个数为2个数组的长度n，第二个数为k，表示查询的是第几个元素。保证输入数据范围1≤n≤40001≤n≤4000，1≤k≤n21≤k≤n2

接下来2行，每行n个整数，分别为各数组。保证各个数组各个元素均在int范围内，两个数组各取任意一个元素**相加得到的结果也均在int范围内**。

## 输出

对于每组数据，输出一行，一个数，所求的数。

具体参见样例及解释。

## 输入样例

```
2 3
2 6
4 10
```

## 输出样例

```
12
```

## 样例解释

容易得出，两个数组{2,6},{4,10}各取一个元素相加并从小到大排好序得到的结果如下：

```
6 10 12 16
```

我们需要的是第3个数，即12，因此输出为12.

## 思路

先对子数组排序，然后利用优先队列做k路归并算法即可

虽说本题nth_element也能过，但是不适用于上一道题

# `J` Magry's Prime

时间限制：1000ms  内存限制：204800kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

废话不多说。

求**不大于n**的所有素数个数。

## 输入

多组输入数据（100组左右），以EOF结尾。

每组数据仅一行，一个数n，意义见题目描述。

保证n的取值范围是：1≤n≤50000000

## 输出

对于每组数据，输出一行，不大于n的所有素数个数。

## 输入样例

```
1
2
3
4
```

## 输出样例

```
0
1
2
2
```

## Hint

不大于50000000的素数个数x的大致范围为：3000000≤x≤3100000

## 思路

埃式筛法这个没什么可说，但是本题卡常

可以发现，偶数除了2以外全都不是质数，所以在打质数表的时候可以把2单独拎出来，再去掉所有的偶数

当然，在只求个数的情况下，直接用**Min25筛**可以保证非常优秀的时间空间复杂度。

本题查询次数较小，每查询一次做一次Min25筛可以快速通过，但是如果查询次数较多，我们就只能采用Meissel_Lehmer+记忆化搜索的做法来完成了

# `V` Magry的强迫症

时间限制：5000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

Magry的老豆因为工作的原因经常出差去海拉尔，回家的时候经常会带来来自俄罗斯的东西（毕竟那边靠近中俄边境，卖俄罗斯的东西特别多），比如套娃……以至于Magry的家里有好多好多的套娃。

现在Magry把家里的n个套娃排成一行，你的任务是把它们套成若干个套娃组，使得每个套娃组内的套娃编号恰好是**从1开始的连续编号**（套娃编号和它的大小是有关联的，编号越小套娃越小，1号套娃是最小的）。

然而Magry有强迫症，他需要你只能按照如下规则进行组套娃操作：

1. 套娃只能将小的套进大的里面，大小相等的套娃相互不能套；
2. 每次只能把**相邻的两个套娃组合**合并成一个套娃组；
3. 一旦有两个套娃属于同一个组，它们永远都属于同一个组（只有与相邻组合并的过程中会临时拆散）。

执行合并操作的前后，所有套娃都是关闭的。为了合并两个套娃组，**你需要交替地把一些套娃打开、重新套起来、关闭**。例如：为了合并[1,2,6]和[4]，需要打开套娃6和4；为了合并[1,2,5]和[3,4]，需要打开套娃5,4,3（只有先打开4才能打开3）。

Magry的强迫症还要求打开套娃的总次数最少，并且还要求把小的套娃组放进去后**马上关闭套娃**。

那么问题来了：打开套娃操作总次数是多少次才能满足Magry的强迫症？

## 输入

多组测试数据，以EOF结尾。

每组数据分为两行。

第一行为一个数n，表示套娃个数。1≤n≤2001≤n≤200

第二行，每行n个整数a，表示Magry桌上摆的各个套娃的大小标号。1≤a≤2001≤a≤200

## 输出

对于每组数据，输出**一行**。

若有解，则输出最少操作次数。

若无解，输出`There is no way to meet Magry's requirements.`

## 输入样例

```
4
1 2 4 3
4
2 3 1 2
```

## 输出样例

```
4
There is no way to meet Magry's requirements.
```

## 样例解释

对于样例一最少步骤4步的完成步骤如下：

设所求最小操作次数为cnt，初值为0.

1. 组装1,2，**需要打开套娃2**，将1放进2中，关闭2，成为[1,2]，此时**cnt+=1**；
2. 组装[1,2]和4，**需要打开套娃4**，将[1,2]放进4中，关闭4，成为[1,2,4]，此时**cnt+=1**；
3. 组装[1,2,4]和3，**需要打开套娃4，3**，将[1,2]放进3中，关闭3，再将[1,2,3]放进4中，关闭4，成为[1,2,3,4]，此时**cnt+=2**。

最后结果cnt=4。

## Source

UVa 1579

## 思路

**区间的双重dp...**

第一个dp，求**区间[l , r]全部合并的最小次数，可以采用区间[l, k]和[k+1, r]做状态转移**

第二个dp，求**前i个娃娃分隔成为多个套娃的最小合并次数**

分解成了两个常规dp

接下来考虑，怎样的区间才能搞成一个套娃，只需要保证这个区间的数互不相同，且最大值就是长度就行了

那么合并[l,k]&[k+1,r] 计算费用，假设m1=min[l,k] m2=min[k+1, r] 那么不用打开的套娃就是区间中小于max[m1, m2]的个数了

中间处理DP的细节较为繁琐，需要进行记忆化的搜索

# `BE` 自带究极坑属性任务之节点连接

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

`Magry`突然收到宋老师指派的任务，将n个节点（编号1，2，…，n）用m根究极坑的**容量不完全相同的单向传输链路**按照**指定的连接图**连接。当然，这个连接图也有些坑，可能存在某个节点无法访问另外一个或几个节点的情况，但是`Magry`不会管那么多的坑，直接按照这个连接图仔细连。

现在，`Magry`已经干完活了，尝试从编号为1的节点发送报文到编号为n的节点，不过需要知道从节点1到节点n传输信息的最大流。一脸懵逼的`Magry`把问题就这么抛给了你们……

## 输入

输入包含多组测试数据，以**EOF**结束。

每组数据第一行为2个整数n,m, n表示有n个节点，m表示有m条单向链路。保证2≤n≤202≤n≤20, 1≤m≤301≤m≤30

接下来m行，每行3个整数s, t, c, 表示从节点s到节点t的容量为c的单向链路。保证 1≤s,t≤n1≤s,t≤n, 0≤c≤10000≤c≤1000 且ss与tt不相等。**注意这里与第五次上机题E题的不同之处**

## 输出

对于每组数据，输出一行：

如果通过节点1无法访问节点n，输出`404 Not Found`

否则输出一个数，从编号为1的节点到编号为n的节点的最大流。

## 输入样例

```
3 2
1 2 18
2 3 11
3 1
1 3 0
3 1
1 2 18
3 3
1 2 1
2 3 1
1 3 1
```

## 输出样例

```
11
0
404 Not Found
2
```

## 思路

**最大流当中，如果出现了权值为0的流，那么最大流为0首先就不能代表源点无法抵达汇点**

另外，根据最大硫算法，有向图需要增加权值为0的反向边，很容易想到，这样加权值0的正向边会影响结果

那么很简单，只要所有正向权值是0的边，则正反向两条边全都不加入。

至于源汇点是否可达，采用最短路，dfs等任何图论的基础方法均可

# `BL` 模式寻数 II

时间限制：2000ms  内存限制：204800kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

给定一个长度为n的数组A，再给定一个数k，求数组A中任取两个元素相加得到的所有结果当中小于k的结果的数目。

需要注意的是，这里把每一个数当作独立的结果处理。

## 输入

第一个数为数据组数T（T不超过10）

对于每组数据，第一行为两个数 n, m，表示数组长度n与查询次数m 1<=n,m<=100000

接下来一行，n个整数，表示数组A. 保证对于每个数A[i]，0<=A[i]<=100000

接下来m行，每行一个数k，意义见题目描述。1<=k<=200000

## 输出

对于每次查询，输出一行，所求数组A中任取两个元素相加得到的所有结果当中小于k的结果的数目。

## 输入样例

```
1
5 2
1 5 3 4 2
7
5
```

## 输出样例

```
6
2
```

## 样例解释

下述数组是对样例中数组{1,5,3,4,2}任选两个数相加得到的所有的结果：

```
3 4 5 5 6 6 7 7 8 9
```

在这个结果中，小于7的数的数目应该为6，小于5的数的数目应该为2

## Source

哈尔滨理工大学2016年新生赛，有改动

## 思路

类似于C6的F题，看到了数据范围就可以立即想到这是一个FFT的问题，同样也是使用前缀和使用

比那题稍微少一些需要考虑的重复情况，不多说了

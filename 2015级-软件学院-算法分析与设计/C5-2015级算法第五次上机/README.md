# C5-2015级算法第五次上机

# `A` 大家一起来排队

时间限制：2000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

大家要以班级为单位按身高从小到大排好队，每班一列！

（排队ing...）

现在，队伍已经排好。我们已经知道的是：有1个班，这个班有多少人，还有从小到大排好序的身高数据。

那么，给定n个身高值h，请问这个班存不存在身高为h的童鞋呢？

时间很急很关键，大家一起找找看！

## 输入

输入包含多组测试数据，以**EOF**结束。

每组数据第一行为2个正整数n, m, 表示有 **n 次查询**，班上有 **m 个人**。其中**1≤n≤1,000,000，1≤m≤4,000,000**

接下来1行，m个整数，这个班所有同学的身高值，保证身高数值从小到大排好序，且每个数均在**INT**范围内。

接下来n行，每行一个数，表示需要查询的身高h，保证h在**INT**范围内

## 输出

对于每组数据，输出n+1行。

第一行输出`Case X:`，其中X表示第几组数据，注意是英文冒号；

接下来n行，对于每次查询，若存在身高为h的数据则输出 `Yes`, 否则输出 `No`

具体参见样例。

## 输入样例

```
1 2
155 160
158
2 3
170 179 182
158
170
```

## 输出样例

```
Case 1:
No
Case 2:
No
Yes
```

## 提示

数据量很大，请使用**`scanf/printf`**进行输入输出。

二分法，注意身高数值和h有正有负

## 思路

**水题，lower_bound可以直接水过**

# `B` 简单的贪心

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

N个人过河，船每次只能坐两个人，船载每个人过河的所需时间不同，每次过河的时间为船上的人的较慢的那个，问最快的过河时间。

```
船是要有人划回来的！ 
```

## 输入

输入包含多组测试数据。

每组数据第一行为人数N，N小于1000

接下来一行为N个整数，为N个人的过河时间

## 输出

对于每组数据，输出一行，为最短过河时间的值

## 输入样例

```
4
1 2 5 10
```

## 输出样例

```
17
```

## 提示

1.充分理解样例

2.只有两种运船策略，比较之后选最优的那个即可

## 思路

**经典的贪心问题**

- **当n=1的时候，自己过去即可，这个Corner case容易忘记**

- 当n=2的时候，取两者最长的max(a1,a2)

- 当n=3的时候，**先运送最快的2人，快的回来，再运第3人 答案是a1+a2+a3**

- 当n>=4的时候，**具体见样例进行思考，拥有相同的规律。**

n>=4的方法如下

**首先不妨根据时间排序，最快的是1最慢的是n**

最快的1载着n去对面，然后**再把次慢的载过去** 

**时间和是2a1+an+an-1**

**或者是1载2过去，再回来，让n和n-1过去，2回来（这个就是样例的方法）**

**时间和是a1+2a2+an**

**每一次该问题的规模都会减小2，直到最后剩下的人数为3个以下时采用上面特殊的情况，即为所求**



# `C` 无法停止的计数

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

`Magry`收到了个二进制计数器。忙碌而又无聊的他用这个计数器拿来数星星、数落叶、数羊、数算法上机签到人数等等等等，根本停不下来。并且这个计数器只有在显示为231−1231−1的时候**再数一个数**计数器示数才会变为0，于是`Magry`也自然也不一定清楚他自从拿到这个计数器到现在一共数数数了多少，但是知道计数器现在的数值——`Magry`也只需要知道计数器显示的是几。

已知计数器初值为 x，一共数了 n 回，对于第 i 回的数数，`Magry`用这个二进制计数器数了 a[i] 个数。

求：每当`Magry`数一个数的时候这个二进制计数器位翻转的运行代价以及摊还代价，以及每回数数之后计数器显示的值。

其中，运行代价是指二进制计数器二进制位翻转的次数，摊还代价最好理解的方法是由势能法算出。

## 输入

输入只包含一组测试数据，共有n+1行。

第一行为2个整数，n 与 x，n 代表`Magry`一共拿这个计数器数了多少回数，x 代表在第一回数数之前计数器的初值（十进制表示）。保证1≤n≤10001≤n≤1000，0≤x≤231−10≤x≤231−1

接下来n行，每行1个整数 a[i]，表示`Magry`第 i 回数数数了多少。保证1≤a[i]≤10001≤a[i]≤1000

## 输出

输出共包含`Magry`的 n 回数数的数据。

对于`Magry`的第 i 回数数，输出下述 a[i]+2 行数据：

第一行为`Case X:`，X表示`Magry`的第 i 回数数，如`Case 1:` `Case 2:` 等等

接下来 a[i] 行，每行2个数，以一个空格分隔，对于第 j 次数数（1≤j≤a[i]1≤j≤a[i]），分别表示该次数数的实际运行代价k与摊还代价c。

接下来还有一行，`Sum: %`，其中%代表这回数数之后计数器的十进制数值(注意冒号后面的一个英文空格)。

具体参见样例。

## 输入样例

```
3 0
1
2
6
```

## 输出样例

```
Case 1:
1 2
Sum: 1
Case 2:
2 2
1 2
Sum: 3
Case 3:
3 2
1 2
2 2
1 2
4 2
1 2
Sum: 9
```

## 提示

数据量很大， **请不要使用`std::endl`输出换行以免TLE到停不下来**

模拟二进制计数器递增的过程可过。大家加油(ง •_•)ง

不懂如何计算摊还代价的可参考《算法导论》中文第三版263-264页的内容

需要知道的是：势能法计算摊还代价时，需要假设势为**当前状态下二进制位为1的个数**

## 思路

**算法导论的摊还分析一章有明确的介绍，这是经典的二进制计数器问题。**

- **实际代价为变更前后两数在位数上的变化，所以需要异或之后计算这个数有多少个1，这个也有较快做法**
- **摊还代价分为两种情况，如果这一次计数归零了，则摊还代价为0，否则摊还代价为2**

最后输出最终结果即可

本题不卡复杂度，一个个地模拟计算肯定是必要的



# `D` 赢了这局我就睡觉

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

王木木总是失眠，因为他总是立一些奇怪的flag，比如给我幽鬼，不赢砍手；比如赢一把就睡觉，so...

王木木赢一局游戏的概率为p，一天晚上最多玩n局，当王木木某一局游戏结束时，他的胜率大于p，他就去睡觉，不然就继续玩。

如果某天打完n局，王木木的胜率还没有超过p，那么王木木会愤怒地把游戏删掉，求一个游戏能在王木木的硬盘中存活的天数的数学期望。

## 输入

第一行是数据组数N.

接着是N组数据. 每一组数据是一个分数p和一个整数n

1 ≤ N ≤ 3000, 0 ≤ p < 1, p的分母不会超过1000 1 ≤ n ≤ 100.

## 输出

对于每组数据，输出一行，为期望值，保留为整数

## 输入样例

```
4
1/2 1
1/2 2
0/1 10
1/2 3
```

## 输出样例

```
2
2
1
2
```

## 思路

**这是一个概率dp的问题。**

**那么第一步我们需要用几何分布进行考虑，一天之内打了n局胜率没有到p的概率是k，那么答案很显然就是1/k，根据题意，取倒数之后强制转换为int即可**

然后就是dp了

**我们假设dp(i, j)表示，打完了i盘，赢了j盘，但是依旧没有到达胜率p的概率（胜率大于p的概率显然是0）**

**然后我们通过给定的胜率进行考虑，给定了i之后，只需要满足j < 胜率分子/胜率分母\*i ，由于小数容易爆精度，不妨输入的时候设胜率分子是a，胜率分母是b，循环条件为j\*b<i\*a即可**

**初始的状态一定有dp(0,0)=1.0，这个过于显然**

接下来会有
$$
dp[i][j]=\begin{cases}dp[i-1][j]*(1-p) & j = 0\\ dp[i-1][j]*(1-p)+dp[i-1][j-1]*p& j>0\end{cases}
$$
**p又是概率又是胜率。**

**最终在答案这里把所有的dp(n,i)取一个加和，就是一天之内没有超过胜率的概率了，取倒数转int即为所求**

(github可能无法查看LaTeX公式，建议下载到本地利Typora阅读)

# `E` Magry遇上了初雪第三弹

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

又一年北京的初雪降临。（说好的大雪呢大雪呢大雪呢

去年初雪当天，`Magry`看到了新鲜值极其高的朋友圈；而今年初雪那天，`Magry`突然收到宋老师指派的任务，将n个节点（编号1，2，…，n）用m根究极坑的**容量不完全相同的单向传输链路**按照**指定的连接图**连接。当然，这个连接图也有些坑，可能存在某个节点无法访问另外一个或几个节点的情况，但是`Magry`不会管那么多的坑，直接按照这个连接图仔细连。

现在，`Magry`已经干完活了，尝试从编号为1的节点发送报文到编号为n的节点，不过需要知道从节点1到节点n传输信息的最大流。一脸懵逼的`Magry`把问题就这么抛给了你们……

## 输入

输入包含多组测试数据，以**EOF**结束。

每组数据第一行为2个整数n,m, n表示有n个节点，m表示有m条单向链路。保证2≤n≤202≤n≤20, 1≤m≤301≤m≤30

接下来m行，每行3个整数s, t, c, 表示从节点s到节点t的容量为c的单向链路。保证 1≤s,t≤n1≤s,t≤n, 1≤c≤10001≤c≤1000 且ss与tt不相等

## 输出

对于每组数据，输出一行：

如果通过节点1无法访问节点n，输出`404 Not Found`

否则输出一个数，从编号为1的节点到编号为n的节点的最大流。

## 输入样例

```
3 2
1 2 18
2 3 11
3 1
1 2 18
3 3
1 2 1
2 3 1
1 3 1
```

## 输出样例

```
11
404 Not Found
2
```

## 思考题

当边权可能为0的时候怎么办？[请戳我做这道题](https://accoding.cn/problem/585/index)

## 思路

**最大流模板，不多说了**

# `F` 二营长,你他娘的意大利炮呢

时间限制：300ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

李云龙是个节俭的人，即使是将敌人围困包围起来，他也想用一颗子弹爆两个人的头。

假设敌人被围困在一个1000*1000的正方形的坑中，东面和北面已经被封堵，而南面和西面假设起了意大利炮，一发意大利炮可以击杀一条线上的所有敌军，那么最少要几发意大利炮才能杀死所有敌军呢？

## 输入

多组数据输入

第一个数为数据组数n，为敌人数量

接下来n行，每行2个整数a,b(1 <= a,b <= 1000),表示一个敌人的坐标

## 输出

对于每组数据，输出一行，为最少的炮击次数的值

## 输入样例

```
3
1 2
2 2
3 4
3
1 3
2 3
3 3
```

## 输出样例

```
2
1
```

## 思路

**二分图最大匹配模板，用匈牙利匹配或者二分图最大流均可过**
# C3-2015级算法第三次上机

# `A` Nintendo Switch生产车间

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

任天堂决定将Nintendo Switch发售日期定于2017年3月。

F工厂收到了任务，要在发售日期之前把许多其他厂商生产的部件总装成一部一部Nintendo Switch。

F工厂有n条生产线用于生产Nintendo Switch，每条生产线都能完成组装一部Nintendo Switch所需要的m道工序，只是需要的时间不同。另外产品可在不同的流水线上完成不同的工序且流水线切换时间及进出流水线时间**忽略不计**，但一件产品完成一道工序只能在同一条流水线上做，不能中断。

F工厂的老板向你们提出这样的问题：

已经知道，n条流水线完成m道工序所需要的时间各是多少。

那么，完成组装一部Nintendo Switch所需要的最短时间是多少？

## 输入

第一个数为数据组数T

接下来T组数据，每组数据由下述内容组成：

第一行为两个数，以一个空格分隔，n与m，n代表流水线数目，m代表总装Nintendo Switch所需要的工序数目。其中1≤n≤10001≤n≤1000, 1≤m≤10001≤m≤1000

接下来n行，每行m个数，对于第i行的第j个数t，表示第i条流水线完成第j个工序需要t个单位时间。其中t>0t>0，且t在**int**范围内。

## 输出

对于每组数据，输出一行，`Case #X: A`, 其中X代表第几组数据，A代表该组数据的答案，即F工厂完成生产一部Nintendo Switch的最短时间。

具体参见样例。

## 输入样例

```
2
1 2
1 2
2 3
5 6 7
4 8 2
```

## 输出样例

```
Case #1: 3
Case #2: 12
```

## 样例解释

对于第二组数据，最短时间12可由下述工序得出：

1. 在第2条流水线完成工序1，时间花费为4；
2. 在第1条流水线完成工序2，时间花费为6；
3. 在第2条流水线完成工序3，时间花费为2.

总时间：4+6+2=12

## Hint

数据量很大，请使用**scanf/printf**进行输入输出操作。

## 思考题

若流水线间的切换、进入流水线、出流水线都需要时间，就像这样：（图片来源网络）

![img](http://images.cnitblog.com/blog/305504/201303/09172507-50134bd6ebc748df99ed71f00db74ea3.png)

如果有2条流水线用于总装Nintendo Switch, 那么总装一部Nintendo Switch最快需要多少时间？3条呢？4条呢？

## 思路

**基础贪心，每一条流水线选择最小值，加和即为所求解**



# `B` I have a tree

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

左树 右树 傻傻分不清楚

嘿，大家一起来~

小赌 豪赌 想AC就别怕苦

所以王木木去豪赌了，游戏规则如下：

在这样一棵奇怪的树中，每次王木木把一棵弹珠放在最上面的根上，然后让弹珠自由落体，弹珠有可能往左走，也有可能往右走，每次经过一个点，得分加上这个点的价值，那么王木木最多能得多少分呢？

## 输入

多组数据输入

每组数据第一行为正整数n(0<n<1000)，为树的深度

接下来n行，第i行有i个正整数(在int范围内)，表示这个点的价值

## 输出

对于每组数据，输出一行，最大得分的值

## 输入样例

```
4
1
3 2
4 10 1
4 3 2 15
```

## 输出样例

```
19
```

## 样例解释

```
                     1
                3         2
           4        10         1
      4         3         2        15
最优路径：1->2->1->15

得分：1+2+1+15 = 19
```

## 思路

基础dp，类似于杨辉三角

# `C` Magry的朋友很多 - 零食篇

时间限制：1500ms  内存限制：204800kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

Magry有个好朋友Ricardo快要过生日了。Ricardo突然想到可以借生日`坑蒙拐骗`点东西出来，于是就找了Magry要他买零食当生日礼物。

Magry手上没那么多钱，不过想了想还是上了天猫超市搜了一波，被那么多吃的看的眼花缭乱头晕目眩不知所措，因为Ricardo只有一个要求，那就是东西尽量好吃，而且还不要有Ricardo不喜欢的东西。。。

Magry已经知道的是：卖的零食总共有n种，不过比较坑爹的是一种零食一个用户**限购一件**；每种商品的价格为x元，好吃程度为w。另外，Magry已经知道在那些零食中有一部分是Ricardo不喜欢的（也许是忌口，总之这个和零食的好吃程度毫无关联，甚至对于一部分好吃程度为0甚至是负数的黑暗料理Ricardo也很有可能喜欢吃）。然后，Magry身上总共只有k元。

现在，Magry想要的是：如何确定购买方案使得在Magry手上的k元不会被透支（即商品总额不大于k元）的情况下买到总的好吃程度最高并且没有Ricardo不喜欢的零食呢？

时间很急很关键，亲们快帮他一把！(另请注意Hint很关键一定要看～)

## 输入

多组测试数据。

每组数据第一行为一个数，为商品种类数n，0≤n≤100000≤n≤10000

接下来n行，每行3个整数x,w,t，每行分别表示一种商品，x代表商品价格，w代表东西的好吃程度，t表示Ricardo喜不喜欢这个东西，1表示喜欢，0表示不喜欢。其中1≤x≤10001≤x≤1000，w在int范围内。

**还有最后一行**，一个数，k，表示Magry手头的钱。0≤k≤1000000≤k≤100000

## 输出

对于每组数据，输出一行，**一个数**，表示Magry在手头的k元不被透支的情况下所购商品的最大好吃程度。

## 输入样例

```
2
3 61 1
7 101 0
100
1
10 1 0
2
```

## 输出样例

```
61
0
```

## Hint 1（重要！）

作为生日礼物，Magry可是**不情愿买好吃程度为0或者负值的黑暗料理的**。

所以，碰见满满的零食列表，面对某些情况，Magry只好**什么都不买**，并且对Ricardo说：“很抱歉，我没法给你买合适的零食了。”

## Hint 2

本题为防止TLE到停不下来，建议如下：

1. 使用if条件语句比较而不用min(), max()等函数及类似ans=a>b?a:b这类条件传送语句；
2. 尽量避免使用乘法。

## 思路

**01背包模板，好吃而且背包价值为整数的才加入背包**

# `D` Longest Common Subsequence

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

嘿~前面的兄弟，我有一条祖传的DNA想和你配对(｡・`ω´･)

## 输入

多组数据输入

每组数据两行，分别为两条长度不超过100的DNA（仅由A,C,G,T组成）

保证两个字符串有公共子序列

## 输出

对于每组数据，输出一行，为两条DNA的最长公共子序列

如果有多解，请输出所有的解，每个解占一行，请按照字典序输出

## 输入样例

```
ACGT
CT
AAGG
AGAG
```

## 输出样例

```
CT
AAG
AGG
```

## 思路

**首先需要普通地进行LCS长度的dp，dp的状态转移方程是**
$$
dp[i][j]=\max\{dp[i-1][j],dp[i][j-1],dp[i-1][j-1]+1(A[i]==B[j])\}
$$
**关键在于保留dp数组，搜索所有的从dp[strlen(A)] [strlen(B)]到dp[0] [0]的所有道路，接下来就是dfs的事情了**

回溯的时候，**按照左方和上方进行回溯，只要其dp的序列比自己小，就可以以此递归**

**本题测试点不强，然而这种标程做法的最大复杂度在O(2^n)，具体的hack数据在下方给出**

# `D` LCS_Data_Enhanced

时间限制: 10000 ms 内存限制: 204800 kb

总通过人数: 2 总提交人数: 2

## 题目描述

题目同492，本题编号为89

提交评测的地址为[这里](https://accoding.cn/problem/89/index)

## 输入

参见492

## 输出

参加492

## 输入样例

```
AAAAAAAAAAAAAAAAAAAAAAAA
ABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
```

## 输出样例

```
A
```

## 思路

像上面的这个样例，普通版本的就过不去了

**所以我们需要类似于建立后缀数组那样，建立last(i,j) 表示到字符串下标i位置，字符'A'+j最后一次出现的位置**

**在搜索的时候，需要充分利用上述记忆化dp的信息，每次寻找的时候按照字符来找，只要找到的lasta和lastb对应位置的dp值等于当前搜索的深度，则可以根据其接着往下找。由于搜索的都是不重复的，所以接下来要从原数组的lasta和lastb值减1的位置开始**

# `E` 身可死，武士之名不可弃

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

源氏：你好，我叫岛田源氏，请多多指教！

王木木：源氏大人，请问您最重要的能力是哪个呢？

源氏：（爬墙）当然是每当我杀死一个敌人，shift就能刷新啦

王木木：团战时，如何选择击杀顺序呢？

源氏：（当然是先杀对面的欧尼酱）选最近的杀，然后刷新shift接着杀穿对方。

王木木：（原来是幼儿源啊。。。）原来如此！

半藏：愚蠢的欧豆豆，快来做这道简单的几何学！

## 输入

多组输入数据

每组数据第一个数为敌人数量n（0<n<100）

接下来n行，每行为一个敌人的坐标x，y（x,y为正整数）

## 输出

每组数据输出源氏的最短击杀路径长度（保留两位小数）

## 规则

源氏的特别击杀顺序——

1 源氏从最左边切入，也就是说，源氏的第一个击杀目标为x最小的敌人

2 源氏严格地从左到右击杀敌人直至最右边的敌人,然后源氏严格地从右到左直至杀回出发点，即保证总最左点到最右点的路线，X单调递增，最右点到出发点最左点的返回路径中，X单调递减。

3 如果有两个敌人X相同，按Y递增的原则排序

4 重要——每个敌人必须且只能被击杀一次

## 输入样例

```
3
1 1
2 3
3 1
4
1 1
2 3
4 2
3 1
```

## 输出样例

```
6.47
7.89
```

## 思路

**本题是算法导论上的一道课后习题，名为双调欧几里得TSP问题，一致这些点，需要绕一个圈从左到右再从右到左回来，求距离总和的最小值**

（1）首先将各点按照 x 坐标从小到大排列，时间复杂度为 O(nlgn)。 

（2）寻找子结构：**定义从 Pi 到 Pj 的路径为：从 Pi 开始，从右到左一直到 P1，然后从左到右一直到**

**Pj。在这个路径上，会经过 P1 到 Pmax(i,j)之间的所有点且只经过一次。**

在定义 d(i,j)为满足这一条件的最短路径。**我们只考虑 i>=j 的情况。**

同时，定义 dist(i,j)为点 Pi 到 Pj 之间的直线距离。

（3）最优解：**我们需要求的是 d(n,n)。**

关于子问题 d(i,j)的求解，分三种情况：

- 当 j < i - 1 时，d(i,j) = d(i-1,j) + dist(i - 1,i)。

由定义可知，点 Pi-1 一定在路径 Pi-Pj 上，而且又由于 j<i-1,因此 Pi 的左边的相邻点一定是 Pi-1.因此

可以得出上述等式。

- 当 j = i - 1 时，与 Pi 左相邻的那个点可能是 P1 到 Pi-1 总的任何一个。因此需要递归求出最小的

那个路径：

d(i,j) = d(i,i-1) = min{d(k,j) + dist(i,k)},其中 1 <= k <= j

- 当 j=i 时，路径上最后相连的两个点可能是 P1-Pi、P2-Pi...Pi-1-Pi。

因此有：

d(i,i) = min{d(i,1)+dist(1,i),...,d(i,i-1),dist(i-1,i)}

**时间复杂度O(n^2) 空间复杂度O(n^2)**

# `F` Magry猎奇的省钱策略

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

Magry猎奇的省钱策略有一百种，你想都想不到。

他去了超市买了一堆东西，然后在收银台结帐。然而Magry并不会老老实实把所有的东西都乖乖结帐，而是早早处心积虑想到了这么一个好（馊）主意：

**在收银员专注在商品上的时候，可以出其不意偷走一些东西。**

已知：Magry的购物车总共有nn件商品，每件商品价格为cici，另外这位收银员会专注于这件商品titi秒钟，Magry偷商品的时间为每件1秒。

重要的是，结帐的顺序由Magry决定。

求：Magry这一次购物最少花多少钱？

## 输入

多组测试数据。

每组数据第一行为1个正整数nn，表示nn件商品。1≤n≤20001≤n≤2000

接下来n行，每行2个整数cici, titi（其中ii代表第ii件商品），分别代表商品的价值和收银员专注于这件商品的时间。1≤ci≤1091≤ci≤109，0≤ti≤20000≤ti≤2000

需要特别注意的是，如果 ti=0ti=0，则代表在收银员在专注于这件商品的时候Magry没法偷走任何东西。

## 输出

对于每组数据，输出一行，Magry的最小花费。

## 输入样例

```
3
76 1
101 0
51 2
```

## 输出样例

```
51
```

## 思路

**这题是真的巧，巧到无与伦比...**

**可以说，是一个01背包/依赖背包的求解，而且是比较难想的巧妙应用**

此题需要一定的思考量，可以把这题套到背包模型里，**将价格视为value，时间+1（不是时间本身）视为weight，**要求为**(总时间>=总件数)的情况下，付出的价值尽量少，可以转化为，总weight>=n的情况下，总value最小**，用01背包模型求解即可。


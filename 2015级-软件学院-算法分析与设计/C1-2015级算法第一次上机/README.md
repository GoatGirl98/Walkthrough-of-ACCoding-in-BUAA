# C1-2015级算法第一次上机

# `A` 多项式计算器

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

Magry最近想要个计算器，其功能需求如下：

给定一元n次多项式的次数n、一个x的值与查询次数t，再输入t组系数a0,a1,...,an来分别求t个一元n次多项式a0+a1x+a2x^2+……+anx^n的值。

时间很急很关键，亲们快帮他一把！

## 输入

多组测试数据(不超过10组)，以**EOF**结尾。

每组测试数据第一行为**三个整数**n、x、t，其中n代表一元n次多项式的**次数**，x代表一元n次多项式的x值，t代表t组系数。

接下来t行，每行**n+1**个数，依次表示一个一元n次多项式的系数a0,a1,...,an.

保证输入数据 **t** 均为**不大于10000的正整数**， **n, x**值及系数 a0,a1,...,an 均为**不大于10000的非负数**。

## 输出

对于**每组数据**，在第一个一元n次多项式计算结果输出前输出一行，`Case #X:`（冒号为英文引号，X代表第几组数据，如第一组为`Case #1:`第二组为`Case #2:`,...,第十组为`Case #10:`,以此类推）

对于**每个一元n次多项式**，输出一行，一个数，一元n次多项式的最终计算结果。鉴于最终结果可能较大，每个结果均对**1e6+7**取模。

具体参见样例。

## 输入样例

```
3 1 3
0 1 2 3
1 2 3 4
6 9 0 0
2 10 1
1 2 3
```

## 输出样例

```
Case #1:
6
10
15
Case #2:
321
```

## Hint

鉴于运算过程中可能会出现超出int数据范围的情形，如会出现类似900000*10000的运算过程，请大家注意要在遵循“边加边取模，边乘边取模”的原则之上，对**各种数据使用long long数据类型**。

## 思路

霍纳法则模板，没什么好说的

# `B` 怠惰的园丁王木木

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

Magry同学家里请了一个怠惰的园丁王木木，主要工作就是除草，现在有高度为1,2,3...n的草，王木木很懒，想找到一种最简单的方式把所有草全除光。

王木木每点体力可以将一根或者多根草减掉相同的任意高度，求王木木同学所消耗的最少的体力值。

## 输入

多组测试数据。

每组输入数据为一个正整数n，n<=1000000

## 输出

对于每组数据，输出一行，王木木的最小体力

## 输入样例

```
1
2
3
```

## 输出样例

```
1
2
2
```

## 样例解释

只要两点体力就能把1,2,3的草除光哦！

第一点体力剪短2,3的草变为1,0,1

第二点体力剪短1,3的草变为0,0,0~

## 思路

**感觉上不像是算法，又或者说，应该是有结论的贪心题目**

直接进行位运算，每次右移以一位，直到答案变成0，运算的次数即为结果

# `C` jhljx学位运算

时间限制：300ms  内存限制：10000kb

通过率：/ `(%) `  正确率：/ `(%)`

## Problem Description

jhljx在C++程序设计课程中学习了位运算这个高端的知识，现在他开始上算法课，决定活学活用。。

位运算中异或是一个比较神奇的操作，有0^1=1,1^0=1,0^0=0,1^1=0。

于是jhljx给你了一个长度为n的数组，让你求出该数组的某个子数组（数组中下标连续的一些元素组成的数组）的异或值之和。

## Input

输入多组数据。
对于每组数据，第一个行为数据组数n（1<=n<=1000000）
第二行为n个数组元素（保证元素在int范围内）
第三行为一个正整数k（1<=k<=100），表示有k次询问。
接下来为k行，每行为两个数字i和j（1<=i,j<=n），表示子数组的边界。

## Output

对于每组数据，输出每次询问的子数组的元素异或值之和。

## Sample Input

```
4
1 2 3 4
3
1 2
2 4
1 4
```

## Sample Output

```
3
5
4
```

## Hint

- `异或的性质：a^a=0,a^b=c,a^c=b。`
- `数据量较大，请用scanf和printf来实现。`

## Trick

为了防止大家WA到停不下来，这里给出提示，询问时的i和j大小顺序不确定。

## Source

改编自小米2017校园招聘笔试，改动较大，已降低难度。

## Tutorial

本题帮助大家复习了sum和xor的用法。
如果你轻松地解决了本题，可以思考如何求解一个数组中所有子数组异或和中最大的那个？ 提示：trie
小米2017校招笔试原题：求解一个数组中满足两个数异或值大于m的个数。n~100000
求解算法:贪心+trie/map，复杂度O(nlg(100000))

## 思路

**异或前缀和，较为简单**

后面给出的题目**在leetcode有原题，感兴趣的朋友可以做做**

**准确的来说，Tutorial题目的解法是01Trie，字典树针对字符串而言可以等价哈希的开/闭散列作用，且做题的用处相当大，虽然对于这题是map比01Trie更快，但是作为对Trie树的基础了解，建议两者做法都做**

# `D` 股票交易

时间限制：1500ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

一般一家公司的股票价格是不稳定的，就像图里所展示的这样，每时每刻的价格都在变。（图片来源网络）

![img](http://ww4.sinaimg.cn/mw690/4b003419jw1f85s12o7y3j20br05x74z.jpg)

现在，有一份很长很长的连续时间点股票价格数据（按时间**从先到后**顺序），老板需要你快速的寻找在这段数据范围内一次买卖股票的每股最大收益（假设所有人买卖股票都在给定时间点的数据范围内）。

要想解决这个问题，你该怎么办？

## 输入

多组测试数据（10组左右），以**EOF**结尾。

每组测试数据分为两行第一行为数组长度n，正整数，代表股票价格数据长度，数据范围为0<n<=1000000

第二行为n个**正整数**，为股票价格数据数组an，保证数组中每个数在int范围内。

## 输出

对于每次查询，输出一行，每行一个数，代表所求每股最大收益。

若无论如何都无法取得收益，则输出`No solution`

具体参见样例。

## 输入样例

```
5
1 2 3 4 2
2
2 2
```

## 输出样例

```
3
No solution
```

## 样例解释

关于第一组数据，假定第一分钟价格为1，第二分钟价格为2，第三分钟价格为3，第四分钟价格为4，第五分钟价格为2。这段时间内买入卖出的最大收益方案是在第一分钟以价格1买进、第四分钟以价格4卖出，收益为每股3个单位。

## 思路

**经典的股票模型题，具体的做法不多说了，总之就是注意及时停止循环即可，可以保证在O(n)完成**

# `E` 模式寻对

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 概念回顾

```
逆序对：数列a[0],a[1],a[2]…中的任意两个数a[i],a[j]，

如果i<j, 并且a[i]>a[j],

那么我们就说这两个数构成了一个逆序对。

逆序数：一个数列中逆序对的总数。
```

## 题目描述

输入一个正整数n，随后给出一个长度为n的整数序列 a[0],a[1],a[2],...,a[n-1] ，再给定多组数组下标范围，求给定序列的逆序数。

## 输入

多组测试数据(不超过10组)，以**EOF**结尾。

每组测试数据第一行为数组长度n，正整数，代表数组长度，数据范围为0<n<=10000

第二行为n个整数，为数组an，保证数组中每个数在int范围内。

第三行为一个整数t，代表t次查询，0<t<=1000

接下来t行，每行两个数x，y，代表数组下标区间，保证0<=x<=y<=**n-1**

## 输出

对于每次查询，输出一行，每行一个数，代表所求逆序数。

具体参见样例。

## 输入样例

```
5
4 8 4 0 0
3
0 4
2 4
0 2
```

## 输出样例

```
7
2
1
```

## 提示

使用时间复杂度为 O(n2)O(n2) 的算法会超时。

```
联系下归并排序~
```

## 思路

**分区间进行归并排序即可**

**如果还想更快，而且不破坏原序列进行多次查询，可以采用树状数组/权值线段树等高级做法**

虽然存在在线的O(nsqrt(n))的做法，但是那需要所有数据不相同才能保证正确性，本题采用离线的莫队算法+离散化树状数组可以保证在O(nsqrt(n)logn)或者二次离线莫队O(nsqrt(n))内完成计算。

# `F` 究极汉诺塔

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

汉诺塔大家都清楚的啦，普通的汉诺塔肯定难不倒大家啦，于是王木木出了一道究极汉诺塔的题，做完这题，你就可以大声说——

**究极汉诺塔不知道比别的汉诺塔高到哪里去了，我和它谈笑风生**

![img](http://images0.cnblogs.com/blog2015/771341/201506/111726406296022.png)

如图，给定初始局面和目标局面，求最少步数。

```
难题慎入
```

## 输入

多组测试数据

第一个数为数据组数n （1<=n<=60）

第二行包含n个1~3的整数，第i个数也就是初始局面中的第i个盘子所在的柱子编号（1号盘子最小，n号盘子最大）

第三行与第二行格式相同，为目标局面。

当n位0时，输入结束

## 输出

对于每组数据，输出一行，为最小步数的值

## 输入样例

```
4
1 1 1 1
1 2 2 1
3
1 1 1
2 2 2
3
1 2 3
3 2 1
4
1 1 1 1
1 1 1 1
0
```

## 输出样例

```
6
7
3
0
```

## 提示

普通的汉诺塔的步数是(1<<n)-1

## 思路

其实这题其实并不好，**给出的标程答案就是错的**

标程的思路是使用类似DP的思路

如果最大的编号恰好在正确位置，则不需要动
如果一个编号为k的盘子不在自己的终点位置上
且对所有比自己大的盘子都在终点位置
那么只需要考虑所有小于等于k的盘子即可

所以设dp[start] [i] [final]
是把初始状态的i个盘子挪到final的最小步数

所以答案就是
dp[start] [k-1] [other]+dp[final] [k-1] [other]+1
而如果第i个正好正确了，那就同等于i-1个
如果不是的话，那就需要把前i-1个挪到另一根柱子
再挪回来 所以就是dp[p] [i-1] [other]+2^(i-1)-1+1

但是我们完全可以找出一个反例的Hack数据

```
3
3 3 1
1 1 3
```

**这个数据按照标程的思路做出来是7，然而实际的答案是5，这种hack数据的思路确实比较特殊**

补充一下具体的解法:

```
3 From T1 to T2
1 From T3 to T2
2 From T3 to T1
1 From T2 to T1
3 From T2 to T3
```

**本标程本质上所欠考虑的，就是当其比自己小的这些盘子不在目标位置上的时候，其他的盘子依旧可以在特定情况下拿自己当做跳板。**

所以这题并不是很好...

**本题将dp版和一步步进行模拟的做法全都放上来，以供参考。搜索版当中的special_dfs给出的就是这组hack数据的具体解法以及正确答案(虽然我的做法是完全针对这一组数据给出来的，目前没找出真正的通解是什么)**

(之前有幸跟Magry助教亲自讨论了一下这道题，感觉可以具体地将这组Hack数据的精髓再补充一下)

# C2-2015级算法第二次上机

# `A` 数论の初见

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

The empress of natural science is mathematics.

The crown of mathematics is number theory.

And Goldbach's conjecture is the most precious jewel on the crown.

## 输入

多组输入数据

每组数据仅一行，为正整数 n（2 <= n <= 1000000）

## 输出

对于每组数据，输出一行，为小于等于n的素数的个数

## 输入样例

```
9
```

## 输出样例

```
4
```

## 思考题

寻找一个单次查询时间复杂度为O（n）的算法

## 思路

**本题暴力打表是可以过的，但是大概期望的标程解法是埃式筛法**



# `B` 模式寻数

时间限制：100ms  内存限制：131072kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

给定两个等长数组A、B，把A、B两个数组各取一个元素相加，总共有n2n2次加法得到的n2n2个结果，求这n2n2个结果的最小元素。

## 输入

多组输入数据（不超过10组），以EOF结尾。

第一行为一个数，为2个数组的长度n。保证输入数据范围1≤n≤40001≤n≤4000

接下来2行，每行n个整数，分别为各数组。保证各个数组各个元素均在int范围内，两个数组各取任意一个元素**相加得到的结果也均在int范围内**。

## 输出

对于每组数据，输出一行，一个数，所求的数。

具体参见样例及解释。

## 输入样例

```
2
2 6
4 10
```

## 输出样例

```
6
```

## 样例解释

容易得出，两个数组{2,6},{4,10}各取一个元素相加并从小到大得到的结果如下：

```
6 10 12 16
```

我们需要的是最小的数，即6，因此输出为6.

## 思路

**这个题为什么会出现在算法课上？？？**



# `C` jhljx水水的补习班

时间限制：500ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## Problem Description

jhljx开了一家算法补习班，许多童鞋前来报名参加。对于一个学生A，他的学号为S,性别为G,成绩为Sc。其中S为8位整数，G为0或1（0表示男生，1表示女生，这里就不让大家输入字符了），Sc是整数（1<=Sc<=100）。

来jhljx的补习班参加补习的同学会按照一定的顺序前来，不过jhljx有一个怪癖，他每次只给一个当前这些人中最优秀的童鞋补习。

他喜欢先给成绩好的人补习，而对于那些成绩相同的人他又喜欢给男生♂补习，所以成绩相同的男生和女生，jhljx先给男生补习。

而他给补习的这些人中他又喜欢先给学号小的补习，比如两个男生他们成绩相同，那么jhljx会先给学号小的补习。

请你在jhljx需要的时候帮帮他，找出这些优秀的童鞋。

## Input

输入多组数据。
对于每组数据，第一个行为两个正整数n（1<=n<=100000）和m（1<=m<=1000000）,分别表示来补习班补习的学生人数，和操作的数量。
接下来为n行，分别为第1~n个学生的信息。
每一行有三个正整数S（8位正整数）,g（0或1）,Sc（0<=Sc<=100）分别表示学生的学号，性别和成绩。
接下来为m行，每一行为一个操作。
如果操作为“Add x”,其中x为学生的编号。表示第x个学生来找jhljx补习。
如果操作为“Delete”,表示jhljx已经给当前最优秀的那个学生补习完了。
如果操作为“Query”,表示jhljx想知道现在最优秀的学生是谁。

## Output

对于每组数据，当操作为“Query”时，请输出最优秀的学生的信息，按照学号，性别，成绩的顺序输出。

## Sample Input

```
15 25
13211026 0 80
13211027 0 98
13211028 1 80
13211029 0 100
13211030 0 36
14211026 1 69
14211027 1 89
14211028 1 57
14211029 1 79
14211030 1 80
15211026 0 86
15211027 0 84
15211028 0 93
15211029 0 92
15211030 0 80
Add 1
Add 3
Query
Add 14
Add 10
Add 8
Delete
Add 7
Query
Add 11
Add 12
Query
Add 2
Add 4
Add 6
Query
Add 5
Query
Add 13
Add 9
Delete
Query
Add 15
Delete
Query
```

## Sample Output

```
13211026 0 80
14211027 1 89
14211027 1 89
13211029 0 100
13211029 0 100
13211027 0 98
15211028 0 93
```

## Hint

- jhljx表示题目数据好难生成啊==

## 思路

**直接优先队列即可，根据权值的判断重载好运算符就可以了**



# `D` jhljx水水的最短路径

时间限制：500ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## Problem Description

jhljx是一只路痴，一天他不幸坠入一个迷宫中，他灰常想从迷宫中逃出去。
迷宫可以看成一个图，总共有n个节点，jhljx位于第1个节点，他想走最短的路逃出这个迷宫，迷宫节点之间由无向的道路相连接。
这个问题对于聪明的你来说肯定很简单，请你帮帮他吧~

## Input

输入多组测试数据。 对于每组测试数据，第一行为两个正整数n（1<=n<=100000），m（1<=m<=1000000），分别表示迷宫中节点的个数，道路的条数。节点编号从1到n。
下面m行为道路的信息。
每一行有三个数x，y，k，从x(y)节点走到y(x)节点之间需要花费k单位时间。（1<=k<=1000）

## Output

输出jhljx除入口外其他任意节点逃出迷宫的最短时间，如果无法从该节点逃出，则输出-1。（按照从2~n的顺序输出每个节点的最短时间）

## Sample Input

```
3 2
1 2 5
1 3 4
```

## Sample Output

```
5 4
```

## Hint

- 为了防止trick较多，数据中不存在重边，不存在自环，边权都大于0
- Dijkstra+heap / SPFA is needed

## 思路

**单源最短路模板，堆优Dijkstra/SPFA均可以过，即使是存在重边和自环，则不加入自环，采用链式前向星结构也可以解决，如果这题是负权的话，就只能用SPFA了**



# `E` 我有特殊的快排技巧

时间限制：300ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

王木木听说大家学习了快速排序，他感觉很兴♂奋，因为他以前上机的时候从来没有手写过排序算法，都是调用sort()函数来排序，嘿嘿！

快排是什么？

对不起，风好大听不清(๑˙ー˙๑)

## 输入

多组输入数据

第一行为正整数n（1 <= n <= 100000）

接下来n个int范围内的正整数

## 输出

对于每组数据，输出一行，为这n个数中的的中位数

## 输入样例

```
2
1 2
3
2 1 3
```

## 输出样例

```
1
2
```

## Hint

当n为奇数时，输出中间那个

当n为偶数时，输出第n/2个

**数据量很大，请使用 scanf & printf 进行输入输出。**

## 思路

**直接调用nth_element或者sort均可通过本题**

**说句题外话，虽然nth_element是O(n) sort是O(nlogn)，然而学习过线性划分的O(n)之后你会发现，其对应的常数是非常大的，这使得这两种方法在时间上的差距并没有想的那么大**

# `F` 四合归零

时间限制：1000ms  内存限制：131072kb

通过率：/ `(%) `  正确率：/ `(%)`

**每份测试数据**时限：1000ms

**总时限：**2000ms（共2份测试数据）

## Problem Description

Magry最近看到了一个问题——

**给定四个等长整数集合A,B,C,DA,B,C,D， 要求分别从中选取一个元素 a,b,c,da,b,c,d 使得 a+b+c+d=0a+b+c+d=0 成立。**

**问：有多少种选法？**

乍一看这问题挺简单的，他觉得完成它是一件轻而易举的事。

可是一看这计算量，他被吓成一团了……

你们能帮帮他么QWQ

## Input

多组测试数据（不超过5组），以**EOF**结尾。

每组测试数据第一行为一个正整数n，表示四个数组的长度。0<n≤4000

接下来4行，每行n个整数，各行分别是所给定 A,B,C,D 四个数组。各数组各元素取值范围为：−500000≤x≤500000

## Output

对于每组数据，输出一行，一个数，选择方法总数。

## Sample Input

```
2
1 2
3 4
-1 95
-95 -4
```

## Sample Output

```
2
```

## Sample Explanation

很显然，样例当中只有 1+4−1−4=0和 2+3−1−4=0这两种情况成立。

## 思路

采用散列的思想即可，**但是不要用unordered_map，数据没到那个地步，用了反而爆时间空间**

**把A[i]+B[j]放到桶中，然后记录-(C[i]+D[j])的出现次数即可，注意负数需要重新做映射，复杂度O(n^2)**


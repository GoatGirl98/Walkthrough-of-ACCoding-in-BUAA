# C7-2016级C++第七次上机

# `A` 崔哥的信仰

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

ModricWang的舍友崔明亮是1521大班唯一的一个原生党员。

崔哥有一个信仰，那就是买东西不买最贵的一个，只买参数最高的两个。

崔哥初步选中了n个物品，请你帮他选出参数最高的两个。

## 输入

第一个数为物品件数n

接下来一行有n个数，表示这n个物品的参数ai。

2≤n≤100002≤n≤10000
−231≤ai≤231−1−231≤ai≤231−1

## 输出

一行，两个数，崔哥会购买的两件物品的参数a,b。

规定a>=b

## 输入样例1

```
5
1 2 3 4 5
```

## 输出样例1

```
5 4
```

## 思路

排序即可

# `B` 王助教掷骰子

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

王助教手里有一颗正方体形状的骰子。他能够知道骰子的那个初始面朝上，还知道骰子会滚动几次。

现在由你来帮王助教计算一下每个面朝上的概率吧。

这个骰子比较重，所以它每次只能滚向相邻的四个方向（不能斜着滚）。假设骰子**每次滚动**滚向四个方向都是等概率的。

每次骰子滚动都是独立事件。

骰子的展开图是这样的：

```
    |3|     
---------
|6|2|1|5|   
---------
    |4|     
```

## 输入

**多组数据读入**（不超过20组）。

每组数据两个整数i与k，表示初始面i，滚动k次。

## 输出

对于每组数据，输出一行6个浮点数，分别表示1,2,3,4,5,6朝上的最终概率（按百分比）
保留两位小数。

1≤i≤6
0≤k≤2^31−1

## 输入样例

```
1 1
3 1
```

## 输出样例

```
0.00% 25.00% 25.00% 25.00% 25.00% 0.00%
25.00% 25.00% 0.00% 0.00% 25.00% 25.00%
```

## hint

使用printf的同学请使用%%来打出百分号。(用cout的同学就不用管了)

## 思路

先说较为粗暴的做法，我们考虑其概率转移方程（即概率动态规划），需要用到随机过程中的离散马尔科夫链的思想。

任意一个面朝上的时候，到除了自己对面的面之外的其他4面概率均为0.25，于是将当前的概率列向量右乘状态转移矩阵即为所求。

而本题的滚动次数可达2^31-1之多，所以在矩阵乘法的同时需要使用矩阵快速幂

注意按百分比保留两位小数，以及printf如何输出%

事实上本题的标程做法可以参见 https://github.com/GoatGirl98/Walkthrough-of-ACCoding-in-BUAA/issues/4 中，题目作者所说。一个六面均匀骰子在滚足够多次后，每个面朝上的概率应当相等，而本题只要求保留两位小数，所以k足够大的时候就可以大胆输出六个面均等的答案了。实际上又不超时又能正确的k的范围相当大，上机时随意试验几次就可以得到答案。经过笔者的计算，当k大于等于14的时候即可直接输出均等的结果。在这之前就可以暴力进行计算，不需要使用到矩阵快速幂。

证明过程也可以由上述概率dp+矩阵快速幂的做法推出，具体过程由Great-Designer提供。

我们仔细观察上述的概率转移矩阵A，那么我们只需要证明在k趋于无穷的时候，A^k 的极限为一个所有元素均为1/6的矩阵。

- A的特征值为1(1重) -0.5(2重) 0(3重)
- A^k即可表示为对其相似对角矩阵的k次方进行对应的相似变换，接下来我们分析该相似的对角矩阵
- 其中2重特征值-0.5^k的极限显然为0，而1重特征值1始终不变
- 所以可以得到A^k的极限是一个秩为1的矩阵。再加上由于A的特性，每一行的和固定为1，则每一行的6个元素均为1/6。由于对称性，每一列也是一样的。
- 由此，A^k 的极限为一个所有元素均为1/6的矩阵，证毕。

所以我们的做法和上述的概率状态转移类似，每当k加1，我们就将每一个元素当前概率的1/4加给相邻的4个面，而当k大于等于14的时候，直接输出6个16.67%。

# `C` DH分组员

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

最近DH 接手了一个项目组，这个项目组分为NN个小组，第ii个小组有aiai人，但他觉得这个分组方式不合理，想要换一种分组方式。DH的分组方式是把所有人平均分为KK组，但他也不想搞得太麻烦，就决定在重新分组时，只采取下面两种操作方法：

1、把两个相邻组合成一组，新组人数为原两组之和；

2、把一组拆成相邻的两组，两组人数可以随意设置，但总人数要等于原来那一组的人数。

问DH最少需要进行多少次操作才可以完成重新分组？

## 输入

第一行两个整数NN，KK（1≤N，K≤1000001≤N，K≤100000）

第二行NN个整数，a1a1,a2a2,......,anan（1≤ai≤1000001≤ai≤100000）

## 输出

如果可以DH可以完成分组，输出最少操作次数，否则输出−1−1

## 输入样例1

```
1 3
14
```

## 输出样例1

```
-1
```

## 输入样例2

```
3 1
2 3 4
```

## 输出样例2

```
2
```

## 思路

若总人数无法均分为k组，直接输出-1；反之，求出平均值作为每组标准人数，对每组人数a[i]分类讨论：

1.人数小于平均值，将这组人加到下一组中，操作数加一。

2.人数大于等于平均值但不均分，将余数人数加到下一组，操作数相应增加。

3.人数大于等于平均值且均分，将该组人数均分，操作数相应增加即可。

# `D` 混乱的辈分关系

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

称兄道弟的时代已经过去了（现在流行叫爸爸）。如果A有求于B，B可以问A“叫什么？” 然后大家都懂的。

A叫B爸爸，则B是A的爸爸，A是B的儿子。孙子、曾孙等同理。

例如A叫B爸爸，B叫C爸爸，则A是C的孙子。

**B不会是自己的爸爸或者儿子。**

假设我们有一个“爸爸值”，A叫B爸爸会导致A的爸爸值-1,B的爸爸值+1。现在我们想统计这群人中辈分最高（即爸爸值最高）的人和他的所有儿子们。

在爸爸值相同的时候，按如下规则确立辈分关系（标号在前的规则优先采用，举例时按B辈分高算）：

1. A叫过B或B的某个子孙（儿子、孙子或曾孙等）爸爸，但B没有这种情况；
2. A的年龄比B小。

## 输入

第一个数为人数n和叫爸爸次数m。

接下来m行，每行2个整数Ai,Bi，表示Ai曾叫Bi爸爸。

接下来一行n个整数，代表编号1~n的人的年龄gi（以秒计算）。

1≤n≤1001≤n≤100
1≤m≤n21≤m≤n2
1≤Ai≤n1≤Ai≤n
1≤Bi≤n1≤Bi≤n
1≤gi≤1000001≤gi≤100000
**输入保证他们的年龄各不相同。**

## 输出

输出2行，第一行为辈分最高的人的编号i。

接下来一行，输出这个辈分最高的人的所有儿子的编号。

儿子按爸爸值从高到低排序，爸爸值相同时按年龄从高到低排序。

## 输入样例

```
3 3
1 2
3 2
1 3
3 4 5
```

## 输出样例

```
2
3 1
```

## 思路

这道题如果不转换为图论去做，将会在讨论排序时非常困难。

基本思路比较好屡清楚，用floyd可以分清楚谁是谁的子孙
爸爸值相同时的判断需要注意读题，一共有多种情况
主要是注意m的上限，trick在于可能存在重边（A多次叫B爸爸）以及自环（自己叫自己爸爸）的情况，这样的话在输出所有儿子的步骤会出现错误（不能重复也不能包括自己）
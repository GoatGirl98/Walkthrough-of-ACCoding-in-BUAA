# C9-2016级C++第九次上机

# `A` ModricWang’s HASH

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

ModricWang有一些信息需要发给他的朋友JenayYang，但是很不幸，他的所有电脑都被臭名昭著的黑客FuBo入侵了，所有字母都打不出来。

ModricWang决定用数字f来代替若干个字符，具体操作如下：

如果只有一个字符c，那么f等于这个字符的ASCII码，即f=(int)c。

如果有k个字符，设前k-1个字符用数字f0代替，最后一个字母为c，那么f=f0*256+(int)c。

ModricWang最多只会发送8个字符，所以只要一个64位整型变量就可以存下这些信息。

JenayYang收到了ModricWang的信息，并成功读取了出来。黑客FB也获得了这些信息，但是无法理解其中的含义。现在FB钦定你帮他读出这条信息，不然他就黑进教务挂你高数。

## 输入

一个非负整数f，f在unsigned long long范围内。

## 输出

输出一行，f对应的字符串。

## 输入样例

```
448378203247
```

## 输出样例

```
hello
```

## 思路

本质上就是进制转换

# `B` 王助教查看内存

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

王助教听说你们学了指针，决定让你们感受一下用指针操作内存的过程。

王助教的内存里有一些double类型的浮点数，他想看一下这个浮点数的每个字节都是如何表示的。现在由你来编写程序帮他吧。

## 输入

第一行为浮点数的个数n

0<n≤1000<n≤100

接下来n行，每行一个浮点数，表示需要查看字节表示的数。

保证浮点数在double范围内。

## 输出

输出n行，每行sizeof(double)个2位十六进制数（大写），表示从第一字节开始浮点数的字节表示。

## 输入样例

```
3
3.02
2.07
0.00
```

## 输出样例

```
29 5C 8F C2 F5 28 08 40 
8F C2 F5 28 5C 8F 00 40 
00 00 00 00 00 00 00 00 
```

## hint

IEEE浮点数表示方法：

https://zh.wikipedia.org/wiki/IEEE_754

王助教觉得你们应该知道十六进制是怎么输出的。如果不知道可以查文档 ：

http://en.cppreference.com/w/cpp/io/manip

http://en.cppreference.com/w/c/io/fprintf

或者从其他的来源找到文档也可以。

## 思路

直接输入double，然后用一个long long的指针指向他，其对应的意义就变成了实际存储的数值了

对这个指针对应的值分空格输出即可。

等到学习计算机组成这门课程的时候，会专门再讲一次IEEE754的浮点表示法，进一步加深对这里的理解，并且明白为什么float与double都有致命的爆精度问题。

# `C` 王助教画div

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

王助教听说你们学了div，决定让大家感受一下div的绘制过程。

现在王助教知道每个div的起点、终点位置和背景颜色，请你帮王助教绘制一下吧。

n个div顺序绘制，后绘制的颜色会完全覆盖先绘制的颜色，绘制div时包含边界。

**屏幕是白色的（即#FFFFFF）。**

## 输入

第一行，3个数，为矩形的个数n，显示器宽度w，显示器高度h。

接下来n行，每行5个整数x1,y1,x2,y2,color，代表每个div对角线上的起点和终点坐标，和矩形的颜色（十进制数表示）。

1≤n≤1001≤n≤100
1≤w≤1001≤w≤100
1≤h≤1001≤h≤100
0≤x1<w0≤x1<w
0≤x2<w0≤x2<w
0≤y1<h0≤y1<h
0≤y2<h0≤y2<h
0≤color≤224−10≤color≤224−1

**所有的数都以十进制的形式输入。**

## 输出

输出一个矩阵， 代表显示屏上的颜色（每点的颜色值，以#+六位**十六进制值（大写）**表示，例如#123456。）

以左上角为(0,0)，向右为x轴正方向，向下为y轴正方向。

## 输入样例

```
2 3 4
0 0 2 2 7
1 1 2 3 5
```

## 输出样例

```
#000007 #000007 #000007
#000007 #000005 #000005
#000007 #000005 #000005
#FFFFFF #000005 #000005
```

## hint

王助教觉得你们应该知道十六进制是怎么输出的。如果不知道可以查文档 ：

http://en.cppreference.com/w/cpp/io/manip

http://en.cppreference.com/w/c/io/fprintf

或者从其他的来源找到文档也可以。

## 思路

首先注意到其边界数据，一旦右边界小于左边界，下边界小于上边界，则需要交换数值

由于矩阵元素个数非常少，直接穷举即可完成

本题也因为某些原因容易爆WA，得0.6分

如果这题数据再大一些，可以考虑采用二维线段树/kd-树/2d-range tree/树套树等数据结构完成，这就是后话了，不在这里介绍

# `D` 王助教填数独

时间限制：1000ms  内存限制：65536kb

通过率：/ `(%) `  正确率：/ `(%)`

## 题目描述

王助教想要填写一个数独。数独是说**每种数字每行、每列、每个3\*3区域中1~9每种数字都只能出现一个**。

王助教经常记不清自己可以填什么数字。现在王助教把这个数独给你，请你帮王助教看一看能够填写什么数字吧。

**就算你给王助教建议，王助教不会真的填的。王助教眼光很短浅，只要考虑当前能否成立就可以了。**

## 输入

先输入9行，每行9个整数dij，表示数独9*9的格子。

0表示这个地方可以填写数字，1~9代表王助教填写的数字。

然后输入n，代表王助教想要填写的位置数量。

接下来n行，每行2个整数i,j表示王助教想要填写的行坐标i和列坐标j。

0≤dij<100≤dij<10
0<n≤10000<n≤1000
0<i<100<i<10
0<j<100<j<10

## 输出

对于每个坐标，输出一行，表示能使数独能够成立的所有可能填写（从小到大排列）。 如果没有可能的填写请输出一行Impossible。

## 输入样例

```
0 4 0 0 0 0 0 0 5
0 0 2 0 0 0 7 0 0
0 0 0 6 8 0 0 0 0
0 0 6 0 0 0 0 3 0
0 0 0 0 0 5 0 0 0
0 0 0 0 0 4 0 0 2
1 0 0 0 0 0 8 6 0
0 0 0 0 0 0 0 2 0
0 5 0 0 0 9 0 0 0
2
4 5
4 3
```

## 输出样例

```
1 2 7 9
Impossible
```

## 样例解释

数独如下图。在(4,5)格填写3,4,5,6,8都会使数独无法成立。

## 思路

**首先注意:本题不是对数独的暴力搜索问题！**

于是我们直接穷举从1到9，填上去之后，**保证每一行每一列每一九宫格区域的所有数字出现频次都不大于1，即为合法**

**边界数据为:需要填的数据是非空的（样例就给了），以及数独在没填的时候本身就不合法**


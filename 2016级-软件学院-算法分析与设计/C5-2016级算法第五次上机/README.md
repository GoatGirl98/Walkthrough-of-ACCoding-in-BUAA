# C5-2016级算法第五次上机

# Bamboo和"Coco"

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 158 总提交人数: 165

## 题目描述

"我为你写了首歌，穿越浩瀚的岁月烟尘，捱过冰冷的孤独冬季，横跨漫长的天人之路，在你老去的时候，唱给你听。"
——豆瓣《寻梦环游记》热评

话说Bamboo听说亡灵世界准备开一个新活动，思念值不同的亡灵可以获得不同数目的花瓣，亡灵节享有优先安检权。像米格这样的大家庭带来的思念值自然是非常高的。

亡灵们排成一队来领花瓣。每个亡灵都至少有一个花瓣，但是得保证若某个亡灵要比它邻近（前或后）的亡灵的思念值高，则其获得花瓣也要更多。

但是上一个亡灵节收集到的花瓣就是这么多，所以主办方希望能分发尽量少的花瓣。请问主办方最少要准备多少花瓣才够发？

## 输入

多组输入。

第一个数为数据组数n（0<n<=1e6）。

接下来一行n个数，第i个数代表第i个人的思念值（0<i<1e7）。

## 输出

对于每组数据，输出一个行，为需要的最少的花瓣。

## 输入样例

```
3
1 2 2
```

## 输出样例

```
4
```

## Hint

第一个亡灵1个花瓣，第2个亡灵比第1个获得的思念值高，所以要比第一个多，为2，但是第三个就不比第二个思念值多了，1个就行。

数据量较大，建议使用scanf/printf。

## 思路

**核心条件就是自己如果亡灵值比左边和右边要大于的话，那么获得的花瓣也要更多**

**所以我们考虑O(n)的做法，先从左到右考虑，再从右往左考虑，当然了共用一个标志数组也是可以的**

当比左边的思念值更高，left[i]=left[i-1]+1

当比右边的思念值更高，right[i]=right[i+1]+1

**最后只需要答案ans[i]=max{left[i], right[i]}即可**

# ModricWang的水系法术

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 175 总提交人数: 178

## 题目描述

ModricWang和ZKx是好朋友。ZKx是一位强大的魔法师，掌握各种魔法。今天，ModricWang向ZKx学习水系魔法。

ZKx的魔法面板上有N个点，标号为1~N。ModricWang可以通过魔法让点a和点b之间能通过流量为c的水流。当ModricWang完成M次施法后，ZKx会从点1注入无穷多的水流，并引导它们向点N流动。请你帮ModricWang算出，点N处最多会收到流量为多少的水流？

## 输入

第一行两个整数，N和M，N为点数，M为边数，点的标号为1~N。

接下来M行，每行三个整数a, b, c, 表示边的两个端点和可以通过的流量的最大值。水流的方向没有限制。保证没有重边自环。

1≤𝑁≤10001≤N≤1000

1≤𝑀≤1000001≤M≤100000

1≤𝑎,𝑏≤𝑁,𝑎≠𝑏1≤a,b≤N,a≠b

1≤𝑐≤101≤c≤10

## 输出

输出一个整数，点N处会收到的流量的最大值

## 输入样例

```
4 6
1 2 5
1 3 2
1 4 3
2 3 3
2 4 3
3 4 10
```

## 输出样例

```
10
```

## HINT

方向没有限制意思是水可以流回来，也就是水往两个方向都可以流

只能帮你们到这里了

## 思路

**最大流模板，然而本题是无向图，双向都可以流动，所以增加反向边的时候，边权应该是相同的**

**一般来说，在通常的EK/SAP/Dinic当中，最优的做法是ISAP+当前弧优化+bfs这一套组合，写个模板出来就OK了，和其他运行时间相比，速度不知道高到哪里去了**

**另外介绍一种做法叫做HLPP预流推进，这在《算法导论》也有大致的介绍，这种做法平均的速度不一定比ISAP快，但是会在一些特定的图当中，将最差的O(m^2n)将至O(m^2√n) 虽然在一般的上机当中使用这种方法，无疑是拿大炮打蚊子...仅做参考了解即可。**